<!DOCTYPE html>
<html lang="en">
    <head>
        <!-- Global Site Tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-59055167-2"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments)};
          gtag('js', new Date());

          gtag('config', 'UA-59055167-2');
        </script>

        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://notes.shichao.io/gopl/ch2/">
        <link rel="shortcut icon" href="../../toki_32.png">
        

	<title>Chapter 2. Program Structure - Shichao's Notes</title>

        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../../css/base.css" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,400italic,500,600" rel="stylesheet">
        <link href="../../custom.css" rel="stylesheet">
        <link href="../../friendly.css" rel="stylesheet">
        <link href="../../theme.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        
<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../..">Shichao's Notes</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">APUE <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../apue/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch1/">Chapter 1. UNIX System Overview</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch2/">Chapter 2. UNIX Standardization and Implementations</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch3/">Chapter 3. File I/O</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch4/">Chapter 4. Files and Directories</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch5/">Chapter 5. Standard I/O Library</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch6/">Chapter 6. System Data Files and Information</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch7/">Chapter 7. Process Environment</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch8/">Chapter 8. Process Control</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch9/">Chapter 9. Process Relationships</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch10/">Chapter 10. Signals</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch11/">Chapter 11. Threads</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch12/">Chapter 12. Thread Control</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch13/">Chapter 13. Daemon Processes</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch14/">Chapter 14. Advanced I/O</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch15/">Chapter 15. Interprocess Communication</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch16/">Chapter 16. Network IPC: Sockets</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch17/">Chapter 17. Advanced IPC</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UNP <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../unp/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch2/">Chapter 2. The Transport Layer: TCP, UDP, and SCTP</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch3/">Chapter 3. Sockets Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch4/">Chapter 4. Elementary TCP Sockets</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch5/">Chapter 5. TCP Client/Server Example</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch6/">Chapter 6. I/O Multiplexing: The select and poll Functions</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch7/">Chapter 7. Socket Options</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch8/">Chapter 8. Elementary UDP Sockets</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">TCPv1 <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../tcpv1/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch2/">Chapter 2. The Internet Address Architecture</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch3/">Chapter 3. Link Layer</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch4/">Chapter 4. ARP: Address Resolution Protocol</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch5/">Chapter 5. The Internet Protocol (IP)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch6/">Chapter 6. System Configuration: DHCP and Autoconfiguration</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch7/">Chapter 7. Firewalls and Network Address Translation (NAT)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch8/">Chapter 8. ICMPv4 and ICMPv6: Internet Control Message Protocol</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch9/">Chapter 9. Broadcasting and Local Multicasting (IGMP and MLD)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch10/">Chapter 10. User Datagram Protocol (UDP) and IP Fragmentation</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch11/">Chapter 11. Name Resolution and the Domain Name System (DNS)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch12/">Chapter 12. TCP: The Transmission Control Protocol (Preliminaries)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch13/">Chapter 13. TCP Connection Management</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch14/">Chapter 14. TCP Timeout and Retransmission</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch15/">Chapter 15. TCP Data Flow and Window Management</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch16/">Chapter 16. TCP Congestion Control</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch17/">Chapter 17. TCP Keepalive</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch18/">Chapter 18. Security: EAP, IPsec, TLS, DNSSEC, and DKIM</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/headers/">Headers</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">GOPL <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../ch1/">Chapter 1. Tutorial</a>
                        </li>
                      
                        <li class="active">
                            <a href="./">Chapter 2. Program Structure</a>
                        </li>
                      
                        <li>
                            <a href="../ch3/">Chapter 3. Basic Data Types</a>
                        </li>
                      
                        <li>
                            <a href="../ch4/">Chapter 4. Composite Types</a>
                        </li>
                      
                        <li>
                            <a href="../ch5/">Chapter 5. Functions</a>
                        </li>
                      
                        <li>
                            <a href="../ch6/">Chapter 6. Methods</a>
                        </li>
                      
                        <li>
                            <a href="../ch7/">Chapter 7. Interfaces</a>
                        </li>
                      
                        <li>
                            <a href="../ch8/">Chapter 8. Goroutines and Channels</a>
                        </li>
                      
                        <li>
                            <a href="../ch9/">Chapter 9. Concurrency with Shared Variables</a>
                        </li>
                      
                        <li>
                            <a href="../ch10/">Chapter 10. Packages and the Go Tool</a>
                        </li>
                      
                        <li>
                            <a href="../ch11/">Chapter 11. Testing</a>
                        </li>
                      
                        <li>
                            <a href="../ch12/">Chapter 12. Reflection</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">CSN <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../csn/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../csn/part1/">Part 1: Language</a>
                        </li>
                      
                        <li>
                            <a href="../../csn/part2/">Part 2: Advanced</a>
                        </li>
                      
                    </ul>
                </li>
            <li>
                    <a href="../../toc/">TOC</a>
                </li>
            </ul>
            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    
                        <a href="https://github.com/shichao-an/notes/blob/master/docs/gopl/ch2.md">
                    
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#chapter-2-program-structure">Chapter 2. Program Structure</a></li>
        
    
        <li class="main "><a href="#names">Names</a></li>
        
            <li><a href="#local-and-exported-names">Local and exported names *</a></li>
        
            <li><a href="#naming-convention-and-style">Naming convention and style *</a></li>
        
    
        <li class="main "><a href="#declarations">Declarations</a></li>
        
    
        <li class="main "><a href="#variables">Variables</a></li>
        
            <li><a href="#short-variable-declarations">Short Variable Declarations</a></li>
        
            <li><a href="#pointers">Pointers</a></li>
        
            <li><a href="#the-new-function">The new Function</a></li>
        
            <li><a href="#lifetime-of-variables">Lifetime of Variables</a></li>
        
    
        <li class="main "><a href="#assignments">Assignments</a></li>
        
            <li><a href="#tuple-assignment">Tuple Assignment</a></li>
        
            <li><a href="#assignability">Assignability</a></li>
        
    
        <li class="main "><a href="#type-declarations">Type Declarations</a></li>
        
            <li><a href="#example-of-type-declarations-temperature-scales">Example of type declarations: temperature scales *</a></li>
        
            <li><a href="#type-conversion">Type conversion *</a></li>
        
            <li><a href="#advantages-of-named-types">Advantages of named types *</a></li>
        
            <li><a href="#the-string-method">The String method *</a></li>
        
    
        <li class="main "><a href="#packages-and-files">Packages and Files</a></li>
        
            <li><a href="#doc-comment-of-a-package">Doc comment of a package *</a></li>
        
            <li><a href="#imports">Imports</a></li>
        
            <li><a href="#package-initialization">Package Initialization</a></li>
        
    
        <li class="main "><a href="#scope">Scope</a></li>
        
            <li><a href="#scope-vs-lifetime">Scope vs. Lifetime *</a></li>
        
            <li><a href="#lexical-blocks">Lexical Blocks *</a></li>
        
    
        <li class="main "><a href="#doubts-and-solutions">Doubts and Solutions</a></li>
        
            <li><a href="#verbatim">Verbatim</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">
              

<h3 id="chapter-2-program-structure"><strong>Chapter 2. Program Structure</strong><a class="headerlink" href="#chapter-2-program-structure" title="Permanent link">&para;</a></h3>
<p>This chapter provides details about the basic structural elements of a Go program.</p>
<h3 id="names">Names<a class="headerlink" href="#names" title="Permanent link">&para;</a></h3>
<p>In Go, the names of functions, variables, constants, types, statement labels, and packages follow a simple rule: a name begins with a letter (anything that Unicode deems a letter) or an underscore and may have any number of additional letters, digits, and underscores. The names are case-sensitive: <code>heapSort</code> and <code>Heapsort</code> are different names.</p>
<p>Go has 25 keywords like <code>if</code> and <code>switch</code> that may be used only where the syntax permits; they can't be used as names.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>break</code></td>
<td><code>default</code></td>
<td><code>func</code></td>
<td><code>interface</code></td>
</tr>
<tr>
<td><code>case</code></td>
<td><code>defer</code></td>
<td><code>go</code></td>
<td><code>map</code></td>
</tr>
<tr>
<td><code>chan</code></td>
<td><code>else</code></td>
<td><code>goto</code></td>
<td><code>package</code></td>
</tr>
<tr>
<td><code>const</code></td>
<td><code>fallthrough</code></td>
<td><code>if</code></td>
<td><code>range</code></td>
</tr>
<tr>
<td><code>continue</code></td>
<td><code>for</code></td>
<td><code>import</code></td>
<td><code>return</code></td>
</tr>
</tbody>
</table>
<p>In addition, there are about three dozen <em>predeclared</em> names like <code>int</code> and <code>true</code> for built-in constants, types, and functions:</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Constants:</td>
<td><code>true</code> <code>false</code> <code>iota</code> <code>nil</code></td>
</tr>
<tr>
<td>Types:</td>
<td><code>int</code> <code>int8</code> <code>int16</code> <code>int32</code> <code>int64</code> <code>uint</code> <code>uint8</code> <code>uint16</code> <code>uint32</code> <code>uint64</code> <code>uintptr</code> <code>float32</code> <code>float64</code> <code>complex128</code> <code>complex64</code> <code>bool</code> <code>byte</code> <code>rune</code> <code>string</code> <code>error</code></td>
</tr>
<tr>
<td>Functions:</td>
<td><code>make</code> <code>len</code> <code>cap</code> <code>new</code> <code>append</code> <code>copy</code> <code>close</code> <code>delete</code> <code>complex</code> <code>real</code> <code>imag</code> <code>panic</code> <code>recover</code></td>
</tr>
</tbody>
</table>
<p>These names are not reserved, so you may use them in declarations. Beware of the potential for confusion.</p>
<h4 id="local-and-exported-names">Local and exported names *<a class="headerlink" href="#local-and-exported-names" title="Permanent link">&para;</a></h4>
<p>If an entity is:</p>
<ul>
<li>Declared within a function: it is <em>local</em> to that function.</li>
<li>Declared outside of a function: it is visible in all files of the package to which it belongs.</li>
</ul>
<p>The case of the first letter of a name determines its visibility across package boundaries:</p>
<ul>
<li>If the name begins with an upper-case letter, it is <em>exported</em> (visible and accessible outside of its own package and may be referred to by other parts of the program), as with <code>Printf</code> in the <code>fmt</code> package.</li>
<li>Package names themselves are always in lower case.</li>
</ul>
<h4 id="naming-convention-and-style">Naming convention and style *<a class="headerlink" href="#naming-convention-and-style" title="Permanent link">&para;</a></h4>
<ul>
<li>There is no limit on name length;</li>
<li>Short names are preferred, especially for local variables with small scopes (<code>i</code> is better than <code>theLoopIndex</code>);</li>
<li>The larger the scope of a name, the longer and more meaningful it should be.</li>
<li><a href="https://en.wikipedia.org/wiki/CamelCase">Camel case</a> are used when forming names by combining words, e.g. <code>QuoteRuneToASCII</code> and <code>parseRequestLine</code> (instead of <code>quote_rune_to_ASCII</code> or <code>parse_request_line</code>).</li>
<li>The letters of acronyms and initialisms like <code>ASCII</code> and <code>HTML</code> are always rendered in the same case, so a function might be called <code>htmlEscape</code>, <code>HTMLEscape</code>, or <code>escapeHTML</code>, but not <code>escapeHtml</code>.</li>
</ul>
<h3 id="declarations">Declarations<a class="headerlink" href="#declarations" title="Permanent link">&para;</a></h3>
<p>A <strong>declaration</strong> names a program entity and specifies its properties. There are four major kinds of declarations:</p>
<ol>
<li><code>var</code> (variables)</li>
<li><code>const</code> (constants)</li>
<li><code>type</code> (types)</li>
<li><code>func</code> (functions)</li>
</ol>
<p>This chapter discusses variables and types. Constants are disucssed in <a href="../ch3/">Chapter 3</a>, and functions in <a href="../ch5/">Chapter 5</a>.</p>
<p>Each <code>.go</code> file has declarations in the following order:</p>
<ol>
<li>A <code>package</code> declaration that says what package the file is part of.</li>
<li>Any <code>import</code> declarations</li>
<li>A sequence of package-level declarations of types, variables, constants, and functions, in any order.</li>
</ol>
<p>For example, the following program declares a constant, a function, and a couple of variables:</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch2/boiling/main.go">gopl.io/ch2/boiling/main.go</a></small></p>
<div class="codehilite"><pre><span class="c1">// Boiling prints the boiling point of water.</span>
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">const</span> <span class="nx">boilingF</span> <span class="p">=</span> <span class="mf">212.0</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">f</span> <span class="p">=</span> <span class="nx">boilingF</span>
    <span class="kd">var</span> <span class="nx">c</span> <span class="p">=</span> <span class="p">(</span><span class="nx">f</span> <span class="o">-</span> <span class="mi">32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">/</span> <span class="mi">9</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;boiling point = %g°F or %g°C\n&quot;</span><span class="p">,</span> <span class="nx">f</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
    <span class="c1">// Output:</span>
    <span class="c1">// boiling point = 212°F or 100°C</span>
<span class="p">}</span>
</pre></div>


<ul>
<li>Each package-level name is visible in all the files of the package.</li>
<li>Local declarations are visible only within the function in which they are declared.</li>
</ul>
<p>A function declaration has a name, a list of parameters an optional list of results (omitted if the function does not return anything), and the function body.</p>
<h3 id="variables">Variables<a class="headerlink" href="#variables" title="Permanent link">&para;</a></h3>
<p>A <code>var</code> declaration creates a variable of a particular type, attaches a name to it, and sets its initial value, with the general form:</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">name</span> <span class="kd">type</span> <span class="p">=</span> <span class="nx">expression</span>
</pre></div>


<p><u>Either the type or the <code>= expression</code> part may be omitted, but not both:</u></p>
<ul>
<li>If the type is omitted, it is determined by the initializer expression.</li>
<li>If the expression is omitted, the initial value is the <strong>zero value</strong> for the type, which is:<ul>
<li>0 for numbers</li>
<li><code>false</code> for booleans</li>
<li><code>""</code> for strings</li>
<li><code>nil</code> for interfaces and reference types (slice, pointer, map, channel, function).</li>
</ul>
</li>
</ul>
<p>The zero value of an aggregate type like an array or a struct has the zero value of all of its elements or fields.</p>
<p>The zero-value mechanism ensures that a variable always holds a well-defined value of its type; in Go there is no such thing as an uninitialized variable. This simplifies code and often ensures sensible behavior of boundary conditions without extra work. For example,</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">s</span> <span class="kt">string</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="c1">// &quot;&quot;</span>
</pre></div>


<p>Go programmers often go to some effort to make the zero value of a more complicated type meaningful, so that variables begin life in a useful state.</p>
<p>It is possible to declare and optionally initialize a set of variables in a single declaration, with a matching list of expressions. Omitting the type allows declaration of multiple variables of different types:</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">,</span> <span class="nx">k</span> <span class="kt">int</span> <span class="c1">// int, int, int</span>
<span class="kd">var</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">f</span><span class="p">,</span> <span class="nx">s</span> <span class="p">=</span> <span class="kc">true</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">,</span> <span class="s">&quot;four&quot;</span> <span class="c1">// bool, float64, string</span>
</pre></div>


<ul>
<li>Initializers may be literal values or arbitrary expressions.</li>
<li>Package-level variables are initialized before <code>main</code> begins (<a href="#package-initialization">Section 2.6.2</a>).</li>
<li>Local variables are initialized as their declarations are encountered during function execution.</li>
</ul>
<p>A set of variables can also be initialized by calling a function that returns multiple values:</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="c1">// os.Open returns a file and an error</span>
</pre></div>


<h4 id="short-variable-declarations">Short Variable Declarations<a class="headerlink" href="#short-variable-declarations" title="Permanent link">&para;</a></h4>
<p>Within a function, an alternate form called a short variable declaration may be used to declare and initialize local variables. It takes the form <code>name := expression</code>, and the type of name is determined by the type of expression. For exmaple (<a href="../ch1/#animated-gifs">Animated GIFs</a>),</p>
<h5 id="when-to-use-short-variable-declaration-and-var-declaration"><strong>When to use short variable declaration and <code>var</code> declaration</strong> *<a class="headerlink" href="#when-to-use-short-variable-declaration-and-var-declaration" title="Permanent link">&para;</a></h5>
<ul>
<li>Short variable declarations are used to declare and initialize the majority of local variables, for brevity and flexibility.</li>
<li>A <code>var</code> declaration tends to be reserved for:<ul>
<li>Local variables that need an explicit type that differs from that of the initializer expression;</li>
<li>Local variables when they will be assigned a value later and its initial value is unimportant.</li>
</ul>
</li>
</ul>
<div class="codehilite"><pre><span class="nx">i</span> <span class="o">:=</span> <span class="mi">100</span> <span class="c1">// an int</span>
<span class="kd">var</span> <span class="nx">boiling</span> <span class="kt">float64</span> <span class="p">=</span> <span class="mi">100</span> <span class="c1">// a float64</span>
<span class="kd">var</span> <span class="nx">names</span> <span class="p">[]</span><span class="kt">string</span>
<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="nx">Point</span>
</pre></div>


<p>As with <code>var</code> declarations, multiple variables may be declared and initialized in the same short variable declaration:</p>
<div class="codehilite"><pre><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
</pre></div>


<p>However, declarations with multiple initializer expressions should be used only when they help readability, such as for short and natural groupings like the initialization part of a for loop.</p>
<p>Keep in mind that <code>:=</code> is a declaration, whereas <code>=</code> is an assignment. A multi-variable declaration should not be confused with a <a href="#tuple-assignment">tuple assignment</a>, in which each variable on the left-hand side is assigned the corresponding value from the right-hand side:</p>
<div class="codehilite"><pre><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="p">=</span> <span class="nx">j</span><span class="p">,</span> <span class="nx">i</span> <span class="c1">// swap values of i and j</span>
</pre></div>


<p>Like <code>var</code> declarations, short variable declarations may be used for calls to functions like <code>os.Open</code> that return two or more values:</p>
<div class="codehilite"><pre><span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
<span class="c1">// ...use f...</span>
<span class="nx">f</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
</pre></div>


<h5 id="one-subtle-but-important-point"><strong>One subtle but important point</strong> *<a class="headerlink" href="#one-subtle-but-important-point" title="Permanent link">&para;</a></h5>
<p>A short variable declaration does not necessarily declare all the variables on its left-hand side. If some of them were already declared in the same lexical block , then the short variable declaration acts like an assignment to those variables. For example,</p>
<div class="codehilite"><pre><span class="nx">in</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="nx">infile</span><span class="p">)</span>
<span class="c1">// ...</span>
<span class="nx">out</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Create</span><span class="p">(</span><span class="nx">outfile</span><span class="p">)</span>
</pre></div>


<p>In the above code:</p>
<ul>
<li>The first statement declares both <code>in</code> and <code>err</code>.</li>
<li>The second declares <code>out</code> but only assigns a value to the existing <code>err</code> variable.</li>
</ul>
<p>A short variable declaration must declare at least one new variable. Therefore, the following code will not compile:</p>
<div class="codehilite"><pre><span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="nx">infile</span><span class="p">)</span>
<span class="c1">// ...</span>
<span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Create</span><span class="p">(</span><span class="nx">outfile</span><span class="p">)</span> <span class="c1">// compile error: no new variables</span>
</pre></div>


<p>The fix is to use an ordinary assignment for the second statement.</p>
<p>A short variable declaration acts like an assignment only to variables that were already declared in the same lexical block; declarations in an outer block are ignored.</p>
<h4 id="pointers">Pointers<a class="headerlink" href="#pointers" title="Permanent link">&para;</a></h4>
<p>A <strong>variable</strong> is a piece of storage containing a value.</p>
<ul>
<li>Variables created by declarations are identified by a name, such as <code>x</code></li>
<li>Many other variables are identified only by expressions like <code>x[i]</code> or <code>x.f</code>.</li>
</ul>
<p>All these expressions read the value of a variable, except when they appear on the lefthand side of an assignment, in which case a new value is assigned to the variable.</p>
<p>A <strong>pointer</strong> value is the address of a variable. A pointer is thus the location at which a value is stored. Not every value has an address, but every variable does. With a pointer, we can read or update the value of a variable indirectly, without using or even knowing the name of the variable, if indeed it has a name.</p>
<h5 id="pointer-type-type-and-address-of-operators"><strong>Pointer type (<code>*type</code>) and address-of (<code>&amp;</code>) operators</strong> *<a class="headerlink" href="#pointer-type-type-and-address-of-operators" title="Permanent link">&para;</a></h5>
<p>If a variable is declared <code>var x int</code>, the expression <code>&amp;x</code> ("address of <code>x</code>") yields a pointer to an integer variable (a value of type <code>*int</code>, which is pronounced "pointer to <code>int</code>"). If this value is called <code>p</code>, we say "<code>p</code> points to <code>x</code>", or equivalently "<code>p</code> contains the address of <code>x</code>". The variable to which <code>p</code> points is written <code>*p</code>. The expression <code>*p</code> yields the value of that variable, an <code>int</code>, but since <code>*p</code> denotes a variable, it may also appear on the left-hand side of an assignment, in which case the assignment updates the variable.</p>
<div class="codehilite"><pre><span class="nx">x</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="nx">p</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">x</span>          <span class="c1">// p, of type *int, points to x</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">)</span>  <span class="c1">// &quot;1&quot;</span>
<span class="o">*</span><span class="nx">p</span> <span class="p">=</span> <span class="mi">2</span>           <span class="c1">// equivalent to x = 2</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>   <span class="c1">// &quot;2&quot;</span>
</pre></div>


<p>Each component of a variable of aggregate type: a field of a struct or an element of an array, is also a variable and thus has an address too.</p>
<p>Variables are sometimes described as <em>addressable</em> values. Expressions that denote variables are the only expressions to which the <em>address-of</em> operator <code>&amp;</code> may be applied.</p>
<h5 id="comparing-pointers"><strong>Comparing pointers</strong> *<a class="headerlink" href="#comparing-pointers" title="Permanent link">&para;</a></h5>
<p>The zero value for a pointer of any type is <code>nil</code>. The test <code>p != nil</code> is true if <code>p</code> points to a variable. Pointers are comparable; two pointers are equal if and only if they point to the same variable or both are <code>nil</code>.</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">x</span> <span class="o">==</span> <span class="o">&amp;</span><span class="nx">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">x</span> <span class="o">==</span> <span class="o">&amp;</span><span class="nx">y</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">x</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span> <span class="c1">// &quot;true false false&quot;</span>
</pre></div>


<p><u>It is perfectly safe for a function to return the address of a local variable.</u> For example:</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">p</span> <span class="p">=</span> <span class="nx">f</span><span class="p">()</span>

<span class="kd">func</span> <span class="nx">f</span><span class="p">()</span> <span class="o">*</span><span class="kt">int</span> <span class="p">{</span>
    <span class="nx">v</span> <span class="o">:=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">v</span>
<span class="p">}</span>
</pre></div>


<p><u>The local variable <code>v</code> created by this particular call to <code>f</code> will remain in existence even after the call has returned, and the pointer <code>p</code> will still refer to it.</u> Each call of <code>f</code> returns a distinct value:</p>
<div class="codehilite"><pre><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">f</span><span class="p">()</span> <span class="o">==</span> <span class="nx">f</span><span class="p">())</span> <span class="c1">// &quot;false&quot;</span>
</pre></div>


<p>Passing a pointer argument to a function makes it possible for the function to update the variable that was indirectly passed. For example:</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">incr</span><span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="o">*</span><span class="nx">p</span><span class="o">++</span> <span class="c1">// increments what p points to; does not change p</span>
    <span class="k">return</span> <span class="o">*</span><span class="nx">p</span>
<span class="p">}</span>

<span class="nx">v</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="nx">incr</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">v</span><span class="p">)</span>
<span class="c1">// side effect: v is now 2</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">incr</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">v</span><span class="p">))</span> <span class="c1">// &quot;3&quot; (and v is 3)</span>
</pre></div>


<h5 id="pointer-aliasing"><strong>Pointer aliasing</strong> *<a class="headerlink" href="#pointer-aliasing" title="Permanent link">&para;</a></h5>
<p>Each time we take the address of a variable or copy a pointer, we create new aliases or ways to identify the same variable. For example, <code>*p</code> is an alias for <code>v</code>. Pointer aliasing is useful because it allows us to access a variable without using its name, but this is a double-edged sword: to find all the statements that access a variable, we have to know all its aliases. <u>Aliasing also occurs when we copy values of other reference types like slices, maps, and channels, and even structs, arrays, and interfaces that contain these types.</u></p>
<h5 id="pointer-and-the-flag-package"><strong>Pointer and the <code>flag</code> package</strong><a class="headerlink" href="#pointer-and-the-flag-package" title="Permanent link">&para;</a></h5>
<p>Pointers are key to the <code>flag</code> package, which uses a program's command-line arguments to set the values of certain variables for the entire program. To illustrate, this variation on the earlier <code>echo</code> command takes two optional flags:</p>
<ul>
<li><code>-n</code> causes <code>echo</code> to omit the trailing newline that would normally be printed;</li>
<li><code>-s sep</code> causes it to separate the output arguments by the contents of the string <code>sep</code> instead of the default single space.</li>
</ul>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch2/echo4/main.go">gopl.io/ch2/echo4/main.go</a></small></p>
<div class="codehilite"><pre><span class="c1">// Echo4 prints its command-line arguments.</span>
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;flag&quot;</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;strings&quot;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">n</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nx">Bool</span><span class="p">(</span><span class="s">&quot;n&quot;</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="s">&quot;omit trailing newline&quot;</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">sep</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nx">String</span><span class="p">(</span><span class="s">&quot;s&quot;</span><span class="p">,</span> <span class="s">&quot; &quot;</span><span class="p">,</span> <span class="s">&quot;separator&quot;</span><span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">flag</span><span class="p">.</span><span class="nx">Parse</span><span class="p">()</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nx">Join</span><span class="p">(</span><span class="nx">flag</span><span class="p">.</span><span class="nx">Args</span><span class="p">(),</span> <span class="o">*</span><span class="nx">sep</span><span class="p">))</span>
    <span class="k">if</span> <span class="p">!</span><span class="o">*</span><span class="nx">n</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>The function <code>flag.Bool</code> creates a new flag variable of type <code>bool</code>. It takes three arguments:</p>
<ul>
<li>The name of the flag (<code>"n"</code>),</li>
<li>The variable's default value (<code>false</code>),</li>
<li>A message that will be printed if the user provides an invalid argument, an invalid flag, or <code>-h</code> or <code>-help</code>.</li>
</ul>
<p>This is similar to <code>flag.String</code>.</p>
<p>The variables <code>sep</code> and <code>n</code> are pointers to the flag variables, which must be accessed indirectly as <code>*sep</code> and <code>*n</code>.</p>
<p>When the program is run, it must call <code>flag.Parse</code> before the flags are used, to update the flag variables from their default values. The non-flag arguments are available from <code>flag.Args()</code> as a slice of strings. If <code>flag.Parse</code> encounters an error, it prints a usage message and calls <code>os.Exit(2)</code> to terminate the program.</p>
<p>The following are some test results:</p>
<div class="codehilite"><pre><span class="gp">$</span> go build gopl.io/ch2/echo4
<span class="gp">$</span> ./echo4 a bc def
<span class="go">a bc def</span>
<span class="gp">$</span> ./echo4 -s / a bc def
<span class="go">a/bc/def</span>
<span class="gp">$</span> ./echo4 -n a bc def
<span class="go">a bc def$</span>
<span class="gp">$</span> ./echo4 -help
<span class="go">Usage of ./echo4:</span>
<span class="go">  -n    omit trailing newline</span>
<span class="go">  -s string</span>
<span class="go">        separator (default &quot; &quot;)</span>
</pre></div>


<h4 id="the-new-function">The <code>new</code> Function<a class="headerlink" href="#the-new-function" title="Permanent link">&para;</a></h4>
<p>Another way to create a variable is to use the built-in function <code>new</code>. The expression <code>new(T)</code> creates an <strong>unnamed variable</strong> (<a href="https://golang.org/ref/spec#Variables">anonymous variable</a>) of type <code>T</code>, initializes it to the zero value of <code>T</code>, and returns its address, which is a value of type <code>*T</code>.</p>
<div class="codehilite"><pre><span class="nx">p</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>    <span class="c1">// p, of type *int, points to an unnamed int variable</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">)</span>  <span class="c1">// &quot;0&quot;</span>
<span class="o">*</span><span class="nx">p</span> <span class="p">=</span> <span class="mi">2</span>           <span class="c1">// sets the unnamed int to 2</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">)</span>  <span class="c1">// &quot;2&quot;</span>
</pre></div>


<p>A variable created with <code>new</code> is no different from an ordinary local variable whose address is taken, except that there's no need to invent (and declare) a dummy name, and we can use <code>new(T)</code> in an expression. <u>Thus <code>new</code> is only a syntactic convenience, not a fundamental notion.</u></p>
<p>The two <code>newInt</code> functions below have identical behaviors:</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">newInt</span><span class="p">()</span> <span class="o">*</span><span class="kt">int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">new</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">newInt</span><span class="p">()</span> <span class="o">*</span><span class="kt">int</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">dummy</span> <span class="kt">int</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">dummy</span>
<span class="p">}</span>
</pre></div>


<p>Each call to new returns a distinct variable with a unique address:</p>
<div class="codehilite"><pre><span class="nx">p</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
<span class="nx">q</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span> <span class="o">==</span> <span class="nx">q</span><span class="p">)</span> <span class="c1">// &quot;false&quot;</span>
</pre></div>


<p>There is one exception to this rule: two variables whose type carries no information and is therefore of size zero, such as <code>struct{}</code> or <code>[0]int</code>, may have the same address (depending on the implementation).</p>
<p>The <code>new</code> function is relatively rarely used because the most common unnamed variables are of struct types, for which the struct literal syntax (<a href="../ch4/#struct-literals">Section 4.4.1</a>) is more flexible.</p>
<p>Since new is a predeclared function, not a keyword, it's possible to redefine the name for something else within a function, for example:</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">delta</span><span class="p">(</span><span class="nx">old</span><span class="p">,</span> <span class="nx">new</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">new</span> <span class="o">-</span> <span class="nx">old</span> <span class="p">}</span>
</pre></div>


<p>Within <code>delta</code>, the built-in <code>new</code> function is unavailable.</p>
<h4 id="lifetime-of-variables">Lifetime of Variables<a class="headerlink" href="#lifetime-of-variables" title="Permanent link">&para;</a></h4>
<p>The lifetime of a variable is the interval of time during which it exists as the program executes.</p>
<ul>
<li>The lifetime of a package-level variable is the entire execution of the program.</li>
<li>Local variables have dynamic lifetimes: a new instance is created each time the declaration statement is executed, and the variable lives on until it becomes <em>unreachable</em>, at which point its storage may be recycled.</li>
<li>Function parameters and results are also local variables; they are created each time their enclosing function is called.</li>
</ul>
<p>For example, in this excerpt from the Lissajous program of <a href="#animated-gifs">Section 1.4</a>:</p>
<div class="codehilite"><pre><span class="k">for</span> <span class="nx">t</span> <span class="o">:=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="nx">t</span> <span class="p">&lt;</span> <span class="nx">cycles</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="nx">math</span><span class="p">.</span><span class="nx">Pi</span><span class="p">;</span> <span class="nx">t</span> <span class="o">+=</span> <span class="nx">res</span> <span class="p">{</span>
    <span class="nx">x</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Sin</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
    <span class="nx">y</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Sin</span><span class="p">(</span><span class="nx">t</span><span class="o">*</span><span class="nx">freq</span> <span class="o">+</span> <span class="nx">phase</span><span class="p">)</span>
    <span class="nx">img</span><span class="p">.</span><span class="nx">SetColorIndex</span><span class="p">(</span><span class="nx">size</span><span class="o">+</span><span class="nb">int</span><span class="p">(</span><span class="nx">x</span><span class="o">*</span><span class="nx">size</span><span class="o">+</span><span class="mf">0.5</span><span class="p">),</span> <span class="nx">size</span><span class="o">+</span><span class="nb">int</span><span class="p">(</span><span class="nx">y</span><span class="o">*</span><span class="nx">size</span><span class="o">+</span><span class="mf">0.5</span><span class="p">),</span>
        <span class="nx">blackIndex</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<ul>
<li>The variable <code>t</code> is created each time the for loop begins.</li>
<li>New variables <code>x</code> and <code>y</code> are created on each iteration of the loop.</li>
</ul>
<h5 id="how-does-the-garbage-collector-know-that-a-variables-storage-can-be-reclaimed"><strong>How does the garbage collector know that a variable's storage can be reclaimed?</strong> *<a class="headerlink" href="#how-does-the-garbage-collector-know-that-a-variables-storage-can-be-reclaimed" title="Permanent link">&para;</a></h5>
<p>The basic idea is that every package-level variable, and every local variable of each currently active function, can potentially be the start or root of a path to the variable in question, following pointers and other kinds of references that ultimately lead to the variable. If no such path exists, the variable has become unreachable, so it can no longer affect the rest of the computation.</p>
<p><u>Because the lifetime of a variable is determined only by whether or not it is reachable, a local variable may outlive a single iteration of the enclosing loop. It may continue to exist even after its enclosing function has returned.</u></p>
<h5 id="heap-or-stack"><strong>Heap or stack?</strong> *<a class="headerlink" href="#heap-or-stack" title="Permanent link">&para;</a></h5>
<p>A compiler may choose to allocate local variables on the heap or on the stack, but this choice is not determined by whether <code>var</code> or <code>new</code> was used to declare the variable.</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">global</span> <span class="o">*</span><span class="kt">int</span>

<span class="kd">func</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">x</span> <span class="kt">int</span>
    <span class="nx">x</span> <span class="p">=</span> <span class="mi">1</span>
    <span class="nx">global</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">x</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">g</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">y</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
    <span class="o">*</span><span class="nx">y</span> <span class="p">=</span> <span class="mi">1</span>
<span class="p">}</span>
</pre></div>


<p>In the above code:</p>
<ul>
<li><code>x</code> must be heap-allocated because it is still reachable from the variable <code>global</code> after <code>f</code> has returned, despite being declared as a local variable; we say <code>x</code> <em>escapes</em> from <code>f</code>.</li>
<li>Conversely, when <code>g</code> returns, the variable <code>*y</code> becomes unreachable and can be recycled. Since <code>*y</code> does not escape from <code>g</code>, it's safe for the compiler to allocate <code>*y</code> on the stack, even though it was allocated with <code>new</code>.</li>
</ul>
<p>In any case, the notion of escaping is not something that you need to worry about in order to write correct code, though it's good to keep in mind during performance optimization, since each variable that escapes requires an extra memory allocation.</p>
<h5 id="thoughts-on-garbage-collection"><strong>Thoughts on garbage collection</strong> *<a class="headerlink" href="#thoughts-on-garbage-collection" title="Permanent link">&para;</a></h5>
<p>Garbage collection is a tremendous help in writing correct programs, but it does not relieve you of the burden of thinking about memory. You don't need to explicitly allocate and free memory, but to write efficient programs you still need to be aware of the lifetime of variables.  For example, keeping unnecessary pointers to short-lived objects within long-lived objects, especially global variables, will prevent the garbage collector from reclaiming the short-lived objects.</p>
<h3 id="assignments">Assignments<a class="headerlink" href="#assignments" title="Permanent link">&para;</a></h3>
<p>The value held by a variable is updated by an assignment statement. In its simplest form, an assignment has a variable on the left of the <code>=</code> sign and an expression on the right:</p>
<div class="codehilite"><pre><span class="nx">x</span> <span class="p">=</span> <span class="mi">1</span>                       <span class="c1">// named variable</span>
<span class="o">*</span><span class="nx">p</span> <span class="p">=</span> <span class="kc">true</span>                   <span class="c1">// indirect variable</span>
<span class="nx">person</span><span class="p">.</span><span class="nx">name</span> <span class="p">=</span> <span class="s">&quot;bob&quot;</span>         <span class="c1">// struct field</span>
<span class="nx">count</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span> <span class="p">=</span> <span class="nx">count</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span> <span class="o">*</span> <span class="nx">scale</span> <span class="c1">// array or slice or map element</span>
</pre></div>


<p>Each of the arithmetic and bitwise binary operators has a corresponding <em>assignment operator</em>, which allows the last statement to be rewritten like <code>count[x] *= scale</code>. This saves us from having to repeat (and re-evaluate) the expression for the variable.</p>
<p>Numeric variables can also be incremented and decremented by <code>++</code> and <code>--</code> statements:</p>
<div class="codehilite"><pre><span class="nx">v</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="nx">v</span><span class="o">++</span> <span class="c1">// same as v = v + 1; v becomes 2</span>
<span class="nx">v</span><span class="o">--</span> <span class="c1">// same as v = v - 1; v becomes 1 again</span>
</pre></div>


<h4 id="tuple-assignment">Tuple Assignment<a class="headerlink" href="#tuple-assignment" title="Permanent link">&para;</a></h4>
<p><strong>Tuple assignment</strong> allows several variables to be assigned at once. <u>All of the right-hand side expressions are evaluated before any of the variables are updated, making this form most useful when some of the variables appear on both sides of the assignment.</u></p>
<p>Tple assignment can be used in the following scenarios and examples:</p>
<p>Swapping the values of two variables:</p>
<div class="codehilite"><pre><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">=</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">x</span>
<span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">a</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">a</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
</pre></div>


<p>Computing the <a href="https://en.wikipedia.org/wiki/Greatest_common_divisor">greatest common divisor</a> (GCD) of two integers:</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">gcd</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">y</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">=</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="o">%</span><span class="nx">y</span>
<span class="p">}</span>
    <span class="k">return</span> <span class="nx">x</span>
<span class="p">}</span>
</pre></div>


<p>Computing the <em>n</em>-th Fibonacci number iteratively:</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">fib</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">=</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="o">+</span><span class="nx">y</span>
<span class="p">}</span>
    <span class="k">return</span> <span class="nx">x</span>
<span class="p">}</span>
</pre></div>


<p>Tuple assignment can also make a sequence of trivial assignments more compact:</p>
<div class="codehilite"><pre><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">,</span> <span class="nx">k</span> <span class="p">=</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span>
</pre></div>


<p>However, as a matter of style, avoid the tuple form if the expressions are complex, since a sequence of separate statements is easier to read.</p>
<h5 id="expressions-that-produce-multiple-results"><strong>Expressions that produce multiple results</strong> *<a class="headerlink" href="#expressions-that-produce-multiple-results" title="Permanent link">&para;</a></h5>
<p>Certain expressions produce several values.  When such a call is used in an assignment statement, the left-hand side must have as many variables as the function has results.</p>
<p>For example, a function call with multiple results:</p>
<div class="codehilite"><pre><span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="s">&quot;foo.txt&quot;</span><span class="p">)</span> <span class="c1">// function call returns two values</span>
</pre></div>


<p>Often, functions use these additional results to indicate some kind of error by returning either of the following:</p>
<ul>
<li>An <code>error</code> (as in the call to <code>os.Open</code>)</li>
<li>A <code>bool</code>, usually called <code>ok</code>.</li>
</ul>
<p>There are three operators that sometimes also behave this way:</p>
<ul>
<li>Map lookup (§4.3)</li>
<li>Type assertion (§7.10)</li>
<li>Channel receive (§8.4.2)</li>
</ul>
<p>When any of the above three appears in an assignment in which two results are expected, each produces an additional boolean result:</p>
<div class="codehilite"><pre><span class="nx">v</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="c1">// map lookup</span>
<span class="nx">v</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nx">x</span><span class="p">.(</span><span class="nx">T</span><span class="p">)</span>  <span class="c1">// type assertion</span>
<span class="nx">v</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="o">&lt;-</span><span class="nx">ch</span>   <span class="c1">// channel receive</span>
</pre></div>


<p>As with variable declarations, we can assign unwanted values to the blank identifier:</p>
<div class="codehilite"><pre><span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Copy</span><span class="p">(</span><span class="nx">dst</span><span class="p">,</span> <span class="nx">src</span><span class="p">)</span> <span class="c1">// discard byte count</span>
<span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nx">x</span><span class="p">.(</span><span class="nx">T</span><span class="p">)</span>              <span class="c1">// check type but discard result</span>
</pre></div>


<h4 id="assignability">Assignability<a class="headerlink" href="#assignability" title="Permanent link">&para;</a></h4>
<p>Assignment statements are an explicit form of assignment. There are many places in a program where an assignment occurs implicitly:</p>
<ul>
<li>A function call implicitly assigns the argument values to the corresponding parameter variables;</li>
<li>A <code>return</code> statement implicitly assigns the <code>return</code> operands to the corresponding result variables;</li>
<li>A literal expression for a <a href="../ch4/">composite type</a> such as this slice:</li>
</ul>
<div class="codehilite"><pre><span class="nx">medals</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&quot;gold&quot;</span><span class="p">,</span> <span class="s">&quot;silver&quot;</span><span class="p">,</span> <span class="s">&quot;bronze&quot;</span><span class="p">}</span>
</pre></div>


<p>This implicitly assign each element, as if written like this:</p>
<div class="codehilite"><pre><span class="nx">medals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="s">&quot;gold&quot;</span>
<span class="nx">medals</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="s">&quot;silver&quot;</span>
<span class="nx">medals</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="s">&quot;bronze&quot;</span>
</pre></div>


<p>This implicit assignment also applies to the elements of maps and channels.</p>
<h5 id="assignability-rule"><strong>Assignability rule</strong> *<a class="headerlink" href="#assignability-rule" title="Permanent link">&para;</a></h5>
<p><u>An assignment, explicit or implicit, is always legal if the left-hand side (the variable) and the right-hand side (the value) have the same type. More generally, the assignment is legal only if the value is <em>assignable</em> to the type of the variable.</u></p>
<p>The rule for assignability has cases for various types. Relevant cases will be explained when each new type is introduced.</p>
<p>For the types discussed so far, the rules are simple:</p>
<ul>
<li>The types must exactly match.</li>
<li><code>nil</code> may be assigned to any variable of interface or reference type.</li>
</ul>
<p><a href="../ch3/#constants">Constants</a> have more flexible rules for assignability that avoid the need for most explicit conversions.</p>
<h5 id="assignability-and-comparability"><strong>Assignability and comparability</strong> *<a class="headerlink" href="#assignability-and-comparability" title="Permanent link">&para;</a></h5>
<p>Whether two values may be compared with <code>==</code> and <code>!=</code> is related to assignability: in any comparison, the first operand must be assignable to the type of the second operand, or vice versa. As with assignability, relevant cases for comparability will be explained when each new type is introduced.</p>
<h3 id="type-declarations">Type Declarations<a class="headerlink" href="#type-declarations" title="Permanent link">&para;</a></h3>
<p>The type of a variable or expression defines the characteristics of the values it may take on, such as:</p>
<ul>
<li>Size.</li>
<li>How they are represented internally.</li>
<li>Intrinsic operations that can be performed on them.</li>
<li>Methods associated with them.</li>
</ul>
<p>Variables can share the same representation but signify very different concepts. [p39]</p>
<p>A <code>type</code> declaration defines a new <em>named type</em> that has the same <em>underlying type</em> as an existing type. <u>The named type provides a way to separate different and perhaps incompatible uses of the underlying type so that they can't be mixed unintentionally.</u></p>
<div class="codehilite"><pre><span class="kd">type</span> <span class="nx">name</span> <span class="nx">underlying</span><span class="o">-</span><span class="kd">type</span>
</pre></div>


<p>Type declarations most often appear at package level, where the named type is visible throughout the package; if the name is exported (it starts with an upper-case letter), it's accessible from other packages as well.</p>
<h4 id="example-of-type-declarations-temperature-scales">Example of type declarations: temperature scales *<a class="headerlink" href="#example-of-type-declarations-temperature-scales" title="Permanent link">&para;</a></h4>
<p>The following example turns different temperature scales into different types:</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch2/tempconv0/celsius.go">gopl.io/ch2/tempconv0/celsius.go</a></small></p>
<div class="codehilite"><pre><span class="c1">// Package tempconv performs Celsius and Fahrenheit temperature computations.</span>
<span class="kn">package</span> <span class="nx">tempconv</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">type</span> <span class="nx">Celsius</span> <span class="kt">float64</span>
<span class="kd">type</span> <span class="nx">Fahrenheit</span> <span class="kt">float64</span>

<span class="kd">const</span> <span class="p">(</span>
    <span class="nx">AbsoluteZeroC</span> <span class="nx">Celsius</span> <span class="p">=</span> <span class="o">-</span><span class="mf">273.15</span>
    <span class="nx">FreezingC</span>     <span class="nx">Celsius</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="nx">BoilingC</span>      <span class="nx">Celsius</span> <span class="p">=</span> <span class="mi">100</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">CToF</span><span class="p">(</span><span class="nx">c</span> <span class="nx">Celsius</span><span class="p">)</span> <span class="nx">Fahrenheit</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">Fahrenheit</span><span class="p">(</span><span class="nx">c</span><span class="o">*</span><span class="mi">9</span><span class="o">/</span><span class="mi">5</span> <span class="o">+</span> <span class="mi">32</span><span class="p">)</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nx">FToC</span><span class="p">(</span><span class="nx">f</span> <span class="nx">Fahrenheit</span><span class="p">)</span> <span class="nx">Celsius</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">Celsius</span><span class="p">((</span><span class="nx">f</span> <span class="o">-</span> <span class="mi">32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">/</span> <span class="mi">9</span><span class="p">)</span> <span class="p">}</span>
</pre></div>


<p>This package defines two types, <code>Celsius</code> and <code>Fahrenheit</code> for the two units of temperature. <u>Even though both have the same underlying type, <code>float64</code>, they are not the same type, so they cannot be compared or combined in arithmetic expressions.</u> Defining two types avoids errors like inadvertently combining temperatures in the two different scales; an explicit type conversion like <code>Celsius(t)</code> or <code>Fahrenheit(t)</code> is required to convert from a <code>float64</code>.</p>
<ul>
<li><code>Celsius(t)</code> and <code>Fahrenheit(t)</code> are conversions, not function calls. <u>They don't change the value or representation in any way, but they make the change of meaning explicit.</u></li>
<li>The functions <code>CToF</code> and <code>FToC</code> convert between the two scales; they do return different values.</li>
</ul>
<h4 id="type-conversion">Type conversion *<a class="headerlink" href="#type-conversion" title="Permanent link">&para;</a></h4>
<p>For every type <code>T</code>, there is a corresponding conversion operation <code>T(x)</code> that converts the value <code>x</code> to type <code>T</code>. A conversion from one type to another is allowed if any of the following holds:</p>
<ul>
<li>Both have the same underlying type.</li>
<li>Both are unnamed pointer types that point to variables of the same underlying type.</li>
</ul>
<p>These conversions change the type but not the representation of the value.</p>
<p>If <code>x</code> is assignable to <code>T</code>, a conversion is permitted but is usually redundant.</p>
<p>Conversions are also allowed in the following cases:</p>
<ul>
<li>Between numeric types</li>
<li>Between string and some slice types (discussed in <a href="../ch3/">Chapter 3</a>).</li>
</ul>
<p>These conversions may change the representation of the value. For instance, converting a floating-point number to an integer discards any fractional part, and converting a string to a <code>[]byte</code> slice allocates a copy of the string data. In any case, a conversion never fails at run time.</p>
<p>The underlying type of a named type determines its structure and representation, and also the set of intrinsic operations it supports, which are the same as if the underlying type had been used directly. That means that arithmetic operators work the same for <code>Celsius</code> and <code>Fahrenheit</code> as they do for <code>float64</code>.</p>
<div class="codehilite"><pre><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%g\n&quot;</span><span class="p">,</span> <span class="nx">BoilingC</span><span class="o">-</span><span class="nx">FreezingC</span><span class="p">)</span> <span class="c1">// &quot;100&quot; °C</span>
<span class="nx">boilingF</span> <span class="o">:=</span> <span class="nx">CToF</span><span class="p">(</span><span class="nx">BoilingC</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%g\n&quot;</span><span class="p">,</span> <span class="nx">boilingF</span><span class="o">-</span><span class="nx">CToF</span><span class="p">(</span><span class="nx">FreezingC</span><span class="p">))</span>  <span class="c1">// &quot;180&quot; °F</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%g\n&quot;</span><span class="p">,</span> <span class="nx">boilingF</span><span class="o">-</span><span class="nx">FreezingC</span><span class="p">)</span>        <span class="c1">// compile error: type mismatch</span>
</pre></div>


<p>Comparison operators like <code>==</code> and <code>&lt;</code> can also be used to compare a value of a named type to another of the same type, or to a value of the underlying type. But two values of different named types cannot be compared directly:</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">c</span> <span class="nx">Celsius</span>
<span class="kd">var</span> <span class="nx">f</span> <span class="nx">Fahrenheit</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">c</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>          <span class="c1">// &quot;true&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">f</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>          <span class="c1">// &quot;true&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">c</span> <span class="o">==</span> <span class="nx">f</span><span class="p">)</span>          <span class="c1">// compile error: type mismatch</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">c</span> <span class="o">==</span> <span class="nx">Celsius</span><span class="p">(</span><span class="nx">f</span><span class="p">))</span> <span class="c1">// &quot;true&quot;!</span>
</pre></div>


<p>Note that in the last case, the type conversion <code>Celsius(f)</code> does not change the value of its argument, just its type. The test is true because <code>c</code> and <code>f</code> are both zero.</p>
<h4 id="advantages-of-named-types">Advantages of named types *<a class="headerlink" href="#advantages-of-named-types" title="Permanent link">&para;</a></h4>
<p>A named type provides notational convenience if it helps avoid writing out complex types over and over again. The advantage is small when the underlying type is simple like <code>float64</code>, but big for complicated types (detailed when discussing <a href="../ch4/#structs">structs</a>).</p>
<p>Named types also make it possible to define new behaviors for values of the type. These behaviors are expressed as a set of functions associated with the type, called the type's <strong>methods</strong>. Methods are discussed in <a href="../ch6/">Chapter 6</a>. The following example of the <code>String</code> method gives a taste the mechanism.</p>
<p>The declaration below, in which the <code>Celsius</code> parameter <code>c</code> appears before the function name, associates with the <code>Celsius</code> type a method named <code>String</code> that returns <code>c</code>'s numeric value followed by <code>°C</code>:</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">Celsius</span><span class="p">)</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%g°C&quot;</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="p">}</span>
</pre></div>


<h4 id="the-string-method">The <code>String</code> method *<a class="headerlink" href="#the-string-method" title="Permanent link">&para;</a></h4>
<p>Many types declare a <code>String</code> method of this form because it controls how values of the type appear when printed as a string by the <code>fmt</code> package, discussed in <a href="../ch7/#interfaces-as-contracts">Section 7.1</a>.</p>
<div class="codehilite"><pre><span class="nx">c</span> <span class="o">:=</span> <span class="nx">FToC</span><span class="p">(</span><span class="mf">212.0</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span> <span class="c1">// &quot;100°C&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%v\n&quot;</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>   <span class="c1">// &quot;100°C&quot;; no need to call String explicitly</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%s\n&quot;</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>   <span class="c1">// &quot;100°C&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>          <span class="c1">// &quot;100°C&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%g\n&quot;</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>   <span class="c1">// &quot;100&quot;; does not call String</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">c</span><span class="p">))</span> <span class="c1">// &quot;100&quot;; does not call String</span>
</pre></div>


<h3 id="packages-and-files">Packages and Files<a class="headerlink" href="#packages-and-files" title="Permanent link">&para;</a></h3>
<p>Similar to libraries or modules in other languages, packages in Go supports modularity, encapsulation, separate compilation, and reuse. The source code for a package resides in one or more <code>.go</code> files, usually in a directory whose name ends with the import path; for instance, the files of the <code>gopl.io/ch1/helloworld</code> package are stored in directory <code>$GOPATH/src/gopl.io/ch1/helloworld</code>.</p>
<ul>
<li>Each package serves as a separate <em>name space</em> for its declarations.
    For example, within the <code>image</code> package the identifier <code>Decode</code> refers to a different function than does the same identifier in the <code>unicode/utf16</code> package. To refer to a function from outside its package, we must <em>qualify</em> the identifier to make explicit whether we mean <code>image.Decode</code> or <code>utf16.Decode</code>.</li>
<li>Packages hides information by controlling which names are visible outside the package, or <em>exported</em>. In Go, exported identifiers start with an upper-case letter.</li>
</ul>
<p>Suppose we want to make our temperature conversion software available to the Go community as a new package.</p>
<p>Create a package called <a href="https://github.com/shichao-an/gopl.io/tree/master/ch2/tempconv"><code>gopl.io/ch2/tempconv</code></a>, a variation on the previous example. The package itself is stored in two files to show how declarations in separate files of a package are accessed.</p>
<p>The declarations of the types, their constants, and their methods are in <code>tempconv.go</code>:</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch2/tempconv/tempconv.go">gopl.io/ch2/tempconv/tempconv.go</a></small></p>
<div class="codehilite"><pre><span class="kn">package</span> <span class="nx">tempconv</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">type</span> <span class="nx">Celsius</span> <span class="kt">float64</span>
<span class="kd">type</span> <span class="nx">Fahrenheit</span> <span class="kt">float64</span>

<span class="kd">const</span> <span class="p">(</span>
    <span class="nx">AbsoluteZeroC</span> <span class="nx">Celsius</span> <span class="p">=</span> <span class="o">-</span><span class="mf">273.15</span>
    <span class="nx">FreezingC</span>     <span class="nx">Celsius</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="nx">BoilingC</span>      <span class="nx">Celsius</span> <span class="p">=</span> <span class="mi">100</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">Celsius</span><span class="p">)</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span>    <span class="p">{</span> <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%g°C&quot;</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">Fahrenheit</span><span class="p">)</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%g°F&quot;</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span> <span class="p">}</span>
</pre></div>


<p>The conversion functions are in <code>conv.go</code>:</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch2/tempconv/conv.go">gopl.io/ch2/tempconv/conv.go</a></small></p>
<div class="codehilite"><pre><span class="c1">// Package tempconv performs Celsius and Fahrenheit conversions.</span>
<span class="kn">package</span> <span class="nx">tempconv</span>

<span class="c1">// CToF converts a Celsius temperature to Fahrenheit.</span>
<span class="kd">func</span> <span class="nx">CToF</span><span class="p">(</span><span class="nx">c</span> <span class="nx">Celsius</span><span class="p">)</span> <span class="nx">Fahrenheit</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">Fahrenheit</span><span class="p">(</span><span class="nx">c</span><span class="o">*</span><span class="mi">9</span><span class="o">/</span><span class="mi">5</span> <span class="o">+</span> <span class="mi">32</span><span class="p">)</span> <span class="p">}</span>

<span class="c1">// FToC converts a Fahrenheit temperature to Celsius.</span>
<span class="kd">func</span> <span class="nx">FToC</span><span class="p">(</span><span class="nx">f</span> <span class="nx">Fahrenheit</span><span class="p">)</span> <span class="nx">Celsius</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">Celsius</span><span class="p">((</span><span class="nx">f</span> <span class="o">-</span> <span class="mi">32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">/</span> <span class="mi">9</span><span class="p">)</span> <span class="p">}</span>
</pre></div>


<p>Each file starts with a package declaration that defines the package name. When the package is imported, its members are referred to as <code>tempconv.CToF</code> and so on. <u>Package-level names declared in one file of a package are visible to all the other files of the package, as if the source code were all in a single file.</u></p>
<p>[p42]</p>
<p>To convert a Celsius temperature to Fahrenheit in a package that imports <code>gopl.io/ch2/tempconv</code>, we can write the following code:</p>
<div class="codehilite"><pre><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">tempconv</span><span class="p">.</span><span class="nx">CToF</span><span class="p">(</span><span class="nx">tempconv</span><span class="p">.</span><span class="nx">BoilingC</span><span class="p">))</span> <span class="c1">// &quot;212°F&quot;</span>
</pre></div>


<h4 id="doc-comment-of-a-package">Doc comment of a package *<a class="headerlink" href="#doc-comment-of-a-package" title="Permanent link">&para;</a></h4>
<p>The <em>doc comment</em> (<a href="#ch10.md#documenting-packages">Section 10.7.4</a>) immediately preceding the package declaration documents the package as a whole.</p>
<ul>
<li>Conventionally, it should start with a summary sentence in the style illustrated.</li>
<li>Only one file in each package should have a package doc comment.</li>
<li>Extensive doc comments are often placed in a file of their own, conventionally called <code>doc.go</code>.</li>
</ul>
<h4 id="imports">Imports<a class="headerlink" href="#imports" title="Permanent link">&para;</a></h4>
<h5 id="import-path"><strong>Import path</strong> *<a class="headerlink" href="#import-path" title="Permanent link">&para;</a></h5>
<p>Every package within a Go program is identified by a unique string called its <strong>import path</strong>, which appears in an <code>import</code> declaration like <code>gopl.io/ch2/tempconv</code>. The language specification doesn't define where these strings come from or what they mean; it's up to the tools to interpret them. When using the <code>go</code> tool (<a href="../ch10/">Chapter 10</a>), <u>an import path denotes a directory containing Go source files that make up the package.</u></p>
<h5 id="package-name"><strong>Package name</strong> *<a class="headerlink" href="#package-name" title="Permanent link">&para;</a></h5>
<p>In addition to its import path, each package has a <strong>package name</strong>, which is the short buy not necessarily unique name that appears in its package declaration. By convention, a package's name matches the last segment of its import path. For example, the package name of <code>gopl.io/ch2/tempconv</code> is <code>tempconv</code>.</p>
<p>To use <code>gopl.io/ch2/tempconv</code>, we must import it:</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch2/cf/main.go">gopl.io/ch2/cf/main.go</a></small></p>
<div class="codehilite"><pre><span class="c1">// Cf converts its numeric argument to Celsius and Fahrenheit.</span>
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;os&quot;</span>
    <span class="s">&quot;strconv&quot;</span>

    <span class="s">&quot;gopl.io/ch2/tempconv&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">arg</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">ParseFloat</span><span class="p">(</span><span class="nx">arg</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&quot;cf: %v\n&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
            <span class="nx">os</span><span class="p">.</span><span class="nx">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">f</span> <span class="o">:=</span> <span class="nx">tempconv</span><span class="p">.</span><span class="nx">Fahrenheit</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">c</span> <span class="o">:=</span> <span class="nx">tempconv</span><span class="p">.</span><span class="nx">Celsius</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%s = %s, %s = %s\n&quot;</span><span class="p">,</span>
            <span class="nx">f</span><span class="p">,</span> <span class="nx">tempconv</span><span class="p">.</span><span class="nx">FToC</span><span class="p">(</span><span class="nx">f</span><span class="p">),</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">tempconv</span><span class="p">.</span><span class="nx">CToF</span><span class="p">(</span><span class="nx">c</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>The import declaration binds a short name to the imported package that may be used to refer to its contents throughout the file. The <code>import</code> the above code enables us refer to names within <code>gopl.io/ch2/tempconv</code> by using a qualified identifier like <code>tempconv.CToF</code>. By default, the short name is the package name (<code>tempconv</code> in this case), but an import declaration may specify an alternative name to avoid a conflict (<a href="../ch10/#the-package-declaration">Section 10.3</a>).</p>
<p>The <code>cf</code> program converts a single numeric command-line argument to its value in both Celsius and Fahrenheit:</p>
<div class="codehilite"><pre><span class="gp">$</span> go build gopl.io/ch2/cf
<span class="gp">$</span> ./cf 32
<span class="go">32°F = 0°C, 32°C = 89.6°F</span>
<span class="gp">$</span> ./cf 212
<span class="go">212°F = 100°C, 212°C = 413.6°F</span>
<span class="gp">$</span> ./cf -40
<span class="go">-40°F = -40°C, -40°C = -40°F</span>
</pre></div>


<p>It is an error to import a package and then not refer to it. This check helps eliminate dependencies that become unnecessary as the code evolves, although it can be a nuisance during debugging. [p44]</p>
<h5 id="goimports"><strong><code>goimports</code></strong> *<a class="headerlink" href="#goimports" title="Permanent link">&para;</a></h5>
<p>The <a href="https://godoc.org/golang.org/x/tools/cmd/goimports">golang.org/x/tools/cmd/goimports</a> tool automatically inserts and removes packages from the import declaration as necessary; most editors can be configured to run <code>goimports</code> each time you save a file. Like the <code>gofmt</code> tool, it also pretty-prints Go source files in the canonical format.</p>
<h4 id="package-initialization">Package Initialization<a class="headerlink" href="#package-initialization" title="Permanent link">&para;</a></h4>
<p>Package initialization begins by initializing package-level variables in the order in which they are declared, except that dependencies are resolved first:</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">a</span> <span class="p">=</span> <span class="nx">b</span> <span class="o">+</span> <span class="nx">c</span>  <span class="c1">// a initialized third, to 3</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="p">=</span> <span class="nx">f</span><span class="p">()</span>    <span class="c1">// b initialized second, to 2, by calling f</span>
<span class="kd">var</span> <span class="nx">c</span> <span class="p">=</span> <span class="mi">1</span>      <span class="c1">// c initialized first, to 1</span>

<span class="kd">func</span> <span class="nx">f</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">c</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">}</span>
</pre></div>


<p>If the package has multiple <code>.go</code> files, they are sorted by the <code>go</code> tool, given to the compiler and initialized in this order.</p>
<p>An variable declared at package level starts life with the value of its optional initializer expression. However, for some variables, like tables of data, it's not easy to set their initial values using initializer expressions, in which case the <code>init</code> function mechanism may be simpler. A file may contain any number of <code>init</code> functions like the following:</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">init</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</pre></div>


<p>Except that <code>init</code> functions can't be called or referenced, they are normal functions. Within each file, <code>init</code> functions are automatically executed when the program starts, in the order in which they are declared.</p>
<ul>
<li>One package is initialized at a time, in the order of imports in the program, dependencies first.<ul>
<li>For example, if package <code>p</code> imports <code>q</code>, then <code>q</code> is fully initialized before <code>p</code>'s initialization begins.</li>
</ul>
</li>
<li>Initialization proceeds from the bottom up; the <code>main</code> package is the last to be initialized. All packages are fully initialized before the application's <code>main</code> function begins.</li>
</ul>
<p>The package below defines a function <code>PopCount</code> that returns the number of set bits (bits whose value is 1) in a <code>uint64</code> value, which is called its <a href="https://en.wikipedia.org/wiki/Hamming_weight"><em>population count</em></a>. It uses an <code>init</code> function to precompute a table of results, <code>pc</code>, for each possible 8-bit value so that the <code>PopCount</code> function needn't take 64 steps but can just return the sum of eight table lookups. (This is definitely not the fastest algorithm for counting bits, but it's convenient for illustrating <code>init</code> functions, and for showing how to precompute a table of values, which is often a useful programming technique.)</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch2/popcount/main.go">gopl.io/ch2/popcount</a></small></p>
<div class="codehilite"><pre><span class="kn">package</span> <span class="nx">popcount</span>

<span class="c1">// pc[i] is the population count of i.</span>
<span class="kd">var</span> <span class="nx">pc</span> <span class="p">[</span><span class="mi">256</span><span class="p">]</span><span class="kt">byte</span>

<span class="kd">func</span> <span class="nx">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">pc</span> <span class="p">{</span>
        <span class="nx">pc</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">pc</span><span class="p">[</span><span class="nx">i</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="nb">byte</span><span class="p">(</span><span class="nx">i</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// PopCount returns the population count (number of set bits) of x.</span>
<span class="kd">func</span> <span class="nx">PopCount</span><span class="p">(</span><span class="nx">x</span> <span class="kt">uint64</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nx">pc</span><span class="p">[</span><span class="nb">byte</span><span class="p">(</span><span class="nx">x</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mi">0</span><span class="o">*</span><span class="mi">8</span><span class="p">))]</span> <span class="o">+</span>
        <span class="nx">pc</span><span class="p">[</span><span class="nb">byte</span><span class="p">(</span><span class="nx">x</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mi">1</span><span class="o">*</span><span class="mi">8</span><span class="p">))]</span> <span class="o">+</span>
        <span class="nx">pc</span><span class="p">[</span><span class="nb">byte</span><span class="p">(</span><span class="nx">x</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">8</span><span class="p">))]</span> <span class="o">+</span>
        <span class="nx">pc</span><span class="p">[</span><span class="nb">byte</span><span class="p">(</span><span class="nx">x</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="mi">8</span><span class="p">))]</span> <span class="o">+</span>
        <span class="nx">pc</span><span class="p">[</span><span class="nb">byte</span><span class="p">(</span><span class="nx">x</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="mi">8</span><span class="p">))]</span> <span class="o">+</span>
        <span class="nx">pc</span><span class="p">[</span><span class="nb">byte</span><span class="p">(</span><span class="nx">x</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="mi">8</span><span class="p">))]</span> <span class="o">+</span>
        <span class="nx">pc</span><span class="p">[</span><span class="nb">byte</span><span class="p">(</span><span class="nx">x</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mi">6</span><span class="o">*</span><span class="mi">8</span><span class="p">))]</span> <span class="o">+</span>
        <span class="nx">pc</span><span class="p">[</span><span class="nb">byte</span><span class="p">(</span><span class="nx">x</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mi">7</span><span class="o">*</span><span class="mi">8</span><span class="p">))])</span>
<span class="p">}</span>
</pre></div>


<p>Note that in the above code the <code>range</code> loop in <code>init</code> uses only the index, since the value is not need. The loop could also have been written as:</p>
<div class="codehilite"><pre><span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">pc</span> <span class="p">{</span>
</pre></div>


<h3 id="scope">Scope<a class="headerlink" href="#scope" title="Permanent link">&para;</a></h3>
<p>A declaration associates a name with a program entity, such as a function or a variable. The scope of a declaration is the part of the source code where a use of the declared name refers to that declaration.</p>
<h4 id="scope-vs-lifetime">Scope vs. Lifetime *<a class="headerlink" href="#scope-vs-lifetime" title="Permanent link">&para;</a></h4>
<p>Don't confuse scope with lifetime.</p>
<ul>
<li>The scope of a declaration is a region of the program text; it is a compile-time property.</li>
<li>The lifetime of a variable is the range of time during execution when the variable can be referred to by other parts of the program; it is a run-time property.</li>
</ul>
<h4 id="lexical-blocks">Lexical Blocks *<a class="headerlink" href="#lexical-blocks" title="Permanent link">&para;</a></h4>
<h5 id="syntactic-block-and-lexical-block"><strong>Syntactic Block and Lexical Block</strong> *<a class="headerlink" href="#syntactic-block-and-lexical-block" title="Permanent link">&para;</a></h5>
<ul>
<li>A <strong>syntactic block</strong> (or <a href="https://en.wikipedia.org/wiki/Block_(programming)">block</a>) is a sequence of statements enclosed in braces (e.g. function, loop). A name declared inside a syntactic block is not visible outside that block. The block encloses its declarations and determines their scope.</li>
<li>A <strong>lexical block</strong> does not surround declarations with braces. It is generalized from the notion of syntactic blocks. Each of the following elements has a lexical block:<ul>
<li>The entire source code, called <strong>universe block</strong></li>
<li>Each package</li>
<li>Each file</li>
<li>Each <code>for</code>, <code>if</code>, and <code>switch</code> statement</li>
<li>Each case in a <code>switch</code> or <code>select</code> statement</li>
<li>Each explicit syntactic block</li>
</ul>
</li>
</ul>
<h5 id="determining-scopes"><strong>Determining Scopes</strong> *<a class="headerlink" href="#determining-scopes" title="Permanent link">&para;</a></h5>
<p>The lexical block of a declaration determines its scope.</p>
<ul>
<li>Entire source code. The declarations of built-in types, functions, and constants (e.g. <code>int</code>, <code>len</code> and <code>true</code>) are in the universe block. They can be referred to throughout the entire program.</li>
<li>Package. Declarations outside any function (i.e. at package level) can be referred to from any file in the same package.</li>
<li>File. Imported packages (e.g. <code>fmt</code> in the <code>tempconv</code> example) are declared at the file level, so they can be referred to from the same file, but not from another file in the same package without another import.</li>
<li>Local. Many declarations (e.g. the variable <code>c</code> in the <code>tempconv.CToF function</code>) are local, so they can be referred to only from within the same function or a part of it.</li>
</ul>
<p>The scope of a control-flow label, as used by <code>break</code>, <code>continue</code>, and <code>goto</code> statements, is the entire enclosing function.</p>
<h5 id="multiple-declarations-of-the-same-name"><strong>Multiple declarations of the same name</strong> *<a class="headerlink" href="#multiple-declarations-of-the-same-name" title="Permanent link">&para;</a></h5>
<p>A program may contain multiple declarations of the same name as long as each declaration is in a different lexical block.</p>
<p>For example:</p>
<ul>
<li>You can declare a local variable with the same name as a package-level variable.</li>
<li>As shown in <a href="#the-new-function">Section 2.3.3</a>, you can declare a function parameter called <code>new</code>, even though a function of this name is predeclared in the universe block.</li>
</ul>
<p>However, this should not be overdone. The larger the scope of the redeclaration, the more likely you are to surprise the reader.</p>
<p>When the compiler encounters a reference to a name, it looks for a declaration, starting with the innermost enclosing lexical block, up to the universe block:</p>
<ul>
<li>If the compiler finds no declaration, it reports an "undeclared name" error.</li>
<li>If a name is declared in both an outer block and an inner block, the inner declaration will be found first. In that case, the inner declaration is said to <em>shadow</em> (or hide) the outer one, making it inaccessible.</li>
</ul>
<p>For example:</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{}</span>

<span class="kd">var</span> <span class="nx">g</span> <span class="p">=</span> <span class="s">&quot;g&quot;</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">f</span> <span class="o">:=</span> <span class="s">&quot;f&quot;</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="c1">// &quot;f&quot;; local var f shadows package-level func f</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">g</span><span class="p">)</span> <span class="c1">// &quot;g&quot;; package-level var</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">h</span><span class="p">)</span> <span class="c1">// compile error: undefined: h</span>
<span class="p">}</span>
</pre></div>


<p>Within a function, lexical blocks may be nested to arbitrary depth, so one local declaration can shadow another. Most blocks are created by control-flow constructs like <code>if</code> statements and <code>for</code> loops.</p>
<p>The program below has three different variables called <code>x</code> because each declaration appears in a different lexical block.</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">x</span> <span class="o">:=</span> <span class="s">&quot;hello!&quot;</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">x</span> <span class="o">:=</span> <span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="nx">x</span> <span class="o">!=</span> <span class="sc">&#39;!&#39;</span> <span class="p">{</span>
            <span class="nx">x</span> <span class="o">:=</span> <span class="nx">x</span> <span class="o">+</span> <span class="sc">&#39;A&#39;</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span>
            <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%c&quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="c1">// &quot;HELLO&quot; (one letter per iteration)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>The expressions <code>x[i]</code> and <code>x + 'A' - 'a'</code> each refer to a declaration of <code>x</code> from an outer block. (Note that the latter expression is not equivalent to <code>unicode.ToUpper</code>). This is explained in detail below.</p>
<h5 id="explicit-and-implicit-blocks"><strong>Explicit and Implicit Blocks</strong> *<a class="headerlink" href="#explicit-and-implicit-blocks" title="Permanent link">&para;</a></h5>
<p>Not all lexical blocks correspond to explicit brace-delimited sequences of statements; some of them also correspond to implicit blocks. In the previous example, the <code>for</code> loop above creates two lexical blocks:</p>
<ul>
<li>The explicit block for the loop body.</li>
<li>An implicit block that additionally encloses the variables (e.g. <code>i</code>) declared by the initialization clause. The scope of a variable declared in the implicit block is the condition, post-statement (<code>i++</code>), and body of the <code>for</code> statement.</li>
</ul>
<p>The example below also has three variables named <code>x</code>, each declared in a different block: one in the function body, one in the <code>for</code> statement's block, and one in the loop body; but only two of the blocks are explicit:</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">x</span> <span class="o">:=</span> <span class="s">&quot;hello&quot;</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">x</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">x</span> <span class="p">{</span>
        <span class="nx">x</span> <span class="o">:=</span> <span class="nx">x</span> <span class="o">+</span> <span class="sc">&#39;A&#39;</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%c&quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="c1">// &quot;HELLO&quot; (one letter per iteration)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>Like <code>for</code> loops, <code>if</code> statements and <code>switch</code> statements also create implicit blocks in addition to their body blocks. The code in the following <code>if-else</code> chain shows the scope of <code>x</code> and <code>y</code>:</p>
<div class="codehilite"><pre><span class="k">if</span> <span class="nx">x</span> <span class="o">:=</span> <span class="nx">f</span><span class="p">();</span> <span class="nx">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">y</span> <span class="o">:=</span> <span class="nx">g</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span> <span class="nx">x</span> <span class="o">==</span> <span class="nx">y</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="c1">// compile error: x and y are not visible here</span>
</pre></div>


<p><u>The second <code>if</code> statement is nested within the first, so variables declared within the first <code>if</code> statement's initializer are visible within the second.</u> Similar rules apply to each case of a <code>switch</code> statement: there is a block for the condition and a block for each case body.</p>
<p>At the package level, the order in which declarations appear has no effect on their scope, so a declaration may refer to itself or to another that follows it. This enables us to declare recursive or mutually recursive types and functions. However, the compiler will report an error if a constant or variable declaration refers to itself.</p>
<h5 id="examples-if-statement"><strong>Examples: <code>if</code> statement</strong> *<a class="headerlink" href="#examples-if-statement" title="Permanent link">&para;</a></h5>
<p>In the following program:</p>
<div class="codehilite"><pre><span class="k">if</span> <span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="nx">fname</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span> <span class="c1">// compile error: unused: f</span>
    <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
<span class="nx">f</span><span class="p">.</span><span class="nx">ReadByte</span><span class="p">()</span> <span class="c1">// compile error: undefined f</span>
<span class="nx">f</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>    <span class="c1">// compile error: undefined f</span>
</pre></div>


<p>The scope of <code>f</code> is just the <code>if</code> statement, so <code>f</code> is not accessible to the statements that follow, resulting in compiler errors: "undefined f". Depending on the compiler, you may get an additional error reporting that the local variable <code>f</code> was never used.</p>
<p>Thus it is often necessary to declare <code>f</code> before the condition so that it is accessible after:</p>
<div class="codehilite"><pre><span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="nx">fname</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
<span class="nx">f</span><span class="p">.</span><span class="nx">ReadByte</span><span class="p">()</span>
<span class="nx">f</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
</pre></div>


<p>You may be tempted to avoid declaring <code>f</code> and <code>err</code> in the outer block by moving the calls to <code>ReadByte</code> and <code>Close</code> inside an else block:</p>
<div class="codehilite"><pre><span class="k">if</span> <span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="nx">fname</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// f and err are visible here too</span>
    <span class="nx">f</span><span class="p">.</span><span class="nx">ReadByte</span><span class="p">()</span>
    <span class="nx">f</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>


<p>However, <u>the normal practice in Go is to deal with the error in the <code>if</code> block and then return, so that the successful execution path is not indented.</u></p>
<h5 id="short-variable-declarations-and-scope"><strong>Short variable declarations and scope</strong> *<a class="headerlink" href="#short-variable-declarations-and-scope" title="Permanent link">&para;</a></h5>
<p>Short variable declarations require awareness of scope. The following program starts by obtaining its current working directory and saving it in a package-level variable. This could be done by calling <code>os.Getwd</code> in function main, but it might be better to separate this concern from the primary logic, especially if failing to get the directory is a fatal error.  The function <a href="https://golang.org/pkg/log/#Fatalf"><code>log.Fatalf</code></a> prints a message and calls <a href="https://golang.org/pkg/os/#Exit"><code>os.Exit(1)</code></a>.</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">cwd</span> <span class="kt">string</span>
<span class="kd">func</span> <span class="nx">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">cwd</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Getwd</span><span class="p">()</span> <span class="c1">// compile error: unused: cwd</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&quot;os.Getwd failed: %v&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>The <code>:=</code> statement declares <code>cwd</code> and <code>err</code> as local variables. The inner declaration of <code>cwd</code> makes the outer one inaccessible, so the statement does not update the package-level <code>cwd</code> variable as intended. Current Go compilers detect that the local <code>cwd</code> variable is never used and report this as an error, but they are not strictly required to perform this check. A minor change (as shown below), such as the addition of a logging statement that refers to the local <code>cwd</code> as shown below, would defeat the check.</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">cwd</span> <span class="kt">string</span>

<span class="kd">func</span> <span class="nx">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">cwd</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Getwd</span><span class="p">()</span> <span class="c1">// NOTE: wrong!</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&quot;os.Getwd failed: %v&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;Working directory = %s&quot;</span><span class="p">,</span> <span class="nx">cwd</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>The global <code>cwd</code> variable remains uninitialized, and the apparently normal <code>log</code> output obfuscates the bug.</p>
<p>There are a number of ways to deal with this potential problem. The most direct is to avoid <code>:=</code> by declaring <code>err</code> in a separate <code>var</code> declaration:</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">cwd</span> <span class="kt">string</span>

<span class="kd">func</span> <span class="nx">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
    <span class="nx">cwd</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Getwd</span><span class="p">()</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&quot;os.Getwd failed: %v&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h3 id="doubts-and-solutions">Doubts and Solutions<a class="headerlink" href="#doubts-and-solutions" title="Permanent link">&para;</a></h3>
<h4 id="verbatim">Verbatim<a class="headerlink" href="#verbatim" title="Permanent link">&para;</a></h4>
<h5 id="p32-on-short-variable-declaration"><strong>p32 on short variable declaration</strong><a class="headerlink" href="#p32-on-short-variable-declaration" title="Permanent link">&para;</a></h5>
<blockquote>
<p>A short variable declaration acts like an assignment only to variables that were already declared in the same lexical block; declarations in an outer block are ignored.</p>
</blockquote>
<p><span class="text-danger">Question</span>: What does "declarations in an outer block are ignored" mean?</p>
<h5 id="p45-on-init-function"><strong>p45 on <code>init</code> function</strong><a class="headerlink" href="#p45-on-init-function" title="Permanent link">&para;</a></h5>
<p><span class="text-danger">Question</span>: What exact algorithm does <code>PopCount</code> use? It seems different from the Hamming weight algorithm on Wikipedia.</p>
            </div>
        </div>

        <footer class="col-md-12">
            
        </footer>

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script>
        <script src="../../js/base.js"></script>
        <script src="../../custom.js"></script>
    </body>
</html>