<!DOCTYPE html>
<html lang="en">
    <head>
        <!-- Global Site Tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-59055167-2"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments)};
          gtag('js', new Date());

          gtag('config', 'UA-59055167-2');
        </script>

        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://notes.shichao.io/gopl/ch6/">
        <link rel="shortcut icon" href="../../toki_32.png">
        

	<title>Chapter 6. Methods - Shichao's Notes</title>

        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../../css/base.css" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,400italic,500,600" rel="stylesheet">
        <link href="../../custom.css" rel="stylesheet">
        <link href="../../friendly.css" rel="stylesheet">
        <link href="../../theme.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        
<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../..">Shichao's Notes</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">APUE <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../apue/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch1/">Chapter 1. UNIX System Overview</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch2/">Chapter 2. UNIX Standardization and Implementations</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch3/">Chapter 3. File I/O</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch4/">Chapter 4. Files and Directories</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch5/">Chapter 5. Standard I/O Library</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch6/">Chapter 6. System Data Files and Information</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch7/">Chapter 7. Process Environment</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch8/">Chapter 8. Process Control</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch9/">Chapter 9. Process Relationships</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch10/">Chapter 10. Signals</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch11/">Chapter 11. Threads</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch12/">Chapter 12. Thread Control</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch13/">Chapter 13. Daemon Processes</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch14/">Chapter 14. Advanced I/O</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch15/">Chapter 15. Interprocess Communication</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch16/">Chapter 16. Network IPC: Sockets</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch17/">Chapter 17. Advanced IPC</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UNP <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../unp/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch2/">Chapter 2. The Transport Layer: TCP, UDP, and SCTP</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch3/">Chapter 3. Sockets Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch4/">Chapter 4. Elementary TCP Sockets</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch5/">Chapter 5. TCP Client/Server Example</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch6/">Chapter 6. I/O Multiplexing: The select and poll Functions</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch7/">Chapter 7. Socket Options</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch8/">Chapter 8. Elementary UDP Sockets</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">TCPv1 <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../tcpv1/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch2/">Chapter 2. The Internet Address Architecture</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch3/">Chapter 3. Link Layer</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch4/">Chapter 4. ARP: Address Resolution Protocol</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch5/">Chapter 5. The Internet Protocol (IP)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch6/">Chapter 6. System Configuration: DHCP and Autoconfiguration</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch7/">Chapter 7. Firewalls and Network Address Translation (NAT)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch8/">Chapter 8. ICMPv4 and ICMPv6: Internet Control Message Protocol</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch9/">Chapter 9. Broadcasting and Local Multicasting (IGMP and MLD)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch10/">Chapter 10. User Datagram Protocol (UDP) and IP Fragmentation</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch11/">Chapter 11. Name Resolution and the Domain Name System (DNS)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch12/">Chapter 12. TCP: The Transmission Control Protocol (Preliminaries)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch13/">Chapter 13. TCP Connection Management</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch14/">Chapter 14. TCP Timeout and Retransmission</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch15/">Chapter 15. TCP Data Flow and Window Management</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch16/">Chapter 16. TCP Congestion Control</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch17/">Chapter 17. TCP Keepalive</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch18/">Chapter 18. Security: EAP, IPsec, TLS, DNSSEC, and DKIM</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/headers/">Headers</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">GOPL <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../ch1/">Chapter 1. Tutorial</a>
                        </li>
                      
                        <li>
                            <a href="../ch2/">Chapter 2. Program Structure</a>
                        </li>
                      
                        <li>
                            <a href="../ch3/">Chapter 3. Basic Data Types</a>
                        </li>
                      
                        <li>
                            <a href="../ch4/">Chapter 4. Composite Types</a>
                        </li>
                      
                        <li>
                            <a href="../ch5/">Chapter 5. Functions</a>
                        </li>
                      
                        <li class="active">
                            <a href="./">Chapter 6. Methods</a>
                        </li>
                      
                        <li>
                            <a href="../ch7/">Chapter 7. Interfaces</a>
                        </li>
                      
                        <li>
                            <a href="../ch8/">Chapter 8. Goroutines and Channels</a>
                        </li>
                      
                        <li>
                            <a href="../ch9/">Chapter 9. Concurrency with Shared Variables</a>
                        </li>
                      
                        <li>
                            <a href="../ch10/">Chapter 10. Packages and the Go Tool</a>
                        </li>
                      
                        <li>
                            <a href="../ch11/">Chapter 11. Testing</a>
                        </li>
                      
                        <li>
                            <a href="../ch12/">Chapter 12. Reflection</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">CSN <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../csn/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../csn/part1/">Part 1: Language</a>
                        </li>
                      
                        <li>
                            <a href="../../csn/part2/">Part 2: Advanced</a>
                        </li>
                      
                    </ul>
                </li>
            <li>
                    <a href="../../toc/">TOC</a>
                </li>
            </ul>
            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    
                        <a href="https://github.com/shichao-an/notes/blob/master/docs/gopl/ch6.md">
                    
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#chapter-6-methods">Chapter 6. Methods</a></li>
        
    
        <li class="main "><a href="#method-declarations">Method Declarations</a></li>
        
    
        <li class="main "><a href="#methods-with-a-pointer-receiver">Methods with a Pointer Receiver</a></li>
        
            <li><a href="#summary-of-three-cases">Summary of three cases *</a></li>
        
            <li><a href="#nil-is-a-valid-receiver-value">Nil Is a Valid Receiver Value</a></li>
        
    
        <li class="main "><a href="#composing-types-by-struct-embedding">Composing Types by Struct Embedding</a></li>
        
    
        <li class="main "><a href="#method-values-and-expressions">Method Values and Expressions</a></li>
        
            <li><a href="#method-values">Method Values *</a></li>
        
            <li><a href="#method-expressions">Method Expressions *</a></li>
        
    
        <li class="main "><a href="#example-bit-vector-type">Example: Bit Vector Type</a></li>
        
    
        <li class="main "><a href="#encapsulation">Encapsulation</a></li>
        
            <li><a href="#benefits-of-encapsulation">Benefits of encapsulation *</a></li>
        
            <li><a href="#other-aspects-of-encapsulation">Other aspects of encapsulation *</a></li>
        
    
        <li class="main "><a href="#doubts-and-solution">Doubts and Solution</a></li>
        
            <li><a href="#verbatim">Verbatim</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">
              

<h3 id="chapter-6-methods"><strong>Chapter 6. Methods</strong><a class="headerlink" href="#chapter-6-methods" title="Permanent link">&para;</a></h3>
<p>An <em>object</em> is a value or variable that has methods, and a <em>method</em> is a function associated with a particular type. An object-oriented program uses methods to express the properties and operations of each data structure so that clients need not access the object's representation directly.</p>
<p>[p155]</p>
<p>This chapter discusses the following topics on methods:</p>
<ul>
<li>How to define and use methods effectively</li>
<li>Encapsulation</li>
<li>Composition</li>
</ul>
<h3 id="method-declarations">Method Declarations<a class="headerlink" href="#method-declarations" title="Permanent link">&para;</a></h3>
<p>A method is declared with a variant of the ordinary function declaration in which an extra parameter appears before the function name. The parameter attaches the function to the type of that parameter.</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch6/geometry/geometry.go">gopl.io/ch6/geometry/geometry.go</a></small></p>
<div class="codehilite"><pre><span class="kn">package</span> <span class="nx">geometry</span>

<span class="kn">import</span> <span class="s">&quot;math&quot;</span>

<span class="kd">type</span> <span class="nx">Point</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span> <span class="kt">float64</span> <span class="p">}</span>

<span class="c1">// traditional function</span>
<span class="kd">func</span> <span class="nx">Distance</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">q</span> <span class="nx">Point</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Hypot</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">X</span><span class="o">-</span><span class="nx">p</span><span class="p">.</span><span class="nx">X</span><span class="p">,</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Y</span><span class="o">-</span><span class="nx">p</span><span class="p">.</span><span class="nx">Y</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// same thing, but as a method of the Point type</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">Point</span><span class="p">)</span> <span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span> <span class="nx">Point</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Hypot</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">X</span><span class="o">-</span><span class="nx">p</span><span class="p">.</span><span class="nx">X</span><span class="p">,</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Y</span><span class="o">-</span><span class="nx">p</span><span class="p">.</span><span class="nx">Y</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>The extra parameter <code>p</code> is called the method's <em>receiver</em>, a legacy from early object-oriented languages that described calling a method as "sending a message to an object".</p>
<p>In Go, the receiver does not have a special name like <code>this</code> or <code>self</code>; it's naming is similar to any other parameter. Since the receiver name will be frequently used, it's a good idea to choose something short and to be consistent across methods. A common choice is the first letter of the type name, like <code>p</code> for <code>Point</code>.</p>
<p>In a method call, the receiver argument appears before the method name. This parallels the declaration, in which the receiver parameter appears before the method name.</p>
<div class="codehilite"><pre><span class="nx">p</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="nx">q</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">q</span><span class="p">))</span> <span class="c1">// &quot;5&quot;, function call</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span><span class="p">))</span>  <span class="c1">// &quot;5&quot;, method call</span>
</pre></div>


<p>There's no conflict between the two declarations of functions called <code>Distance</code> above:</p>
<ul>
<li>The first declares a package-level function called <code>geometry.Distance</code>.</li>
<li>The second declares a method of the type <code>Point</code> called <code>Point.Distance</code>.</li>
</ul>
<p>Since each type has its own name space for methods, we can use the name <code>Distance</code> for other methods as long as they belong to different types. The following example defines a type <code>Path</code> that represents a sequence of line segments and a <code>Distance</code> method:</p>
<div class="codehilite"><pre><span class="c1">// A Path is a journey connecting the points with straight lines.</span>
<span class="kd">type</span> <span class="nx">Path</span> <span class="p">[]</span><span class="nx">Point</span>

<span class="c1">// Distance returns the distance traveled along the path.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">path</span> <span class="nx">Path</span><span class="p">)</span> <span class="nx">Distance</span><span class="p">()</span> <span class="kt">float64</span> <span class="p">{</span>
    <span class="nx">sum</span> <span class="o">:=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">path</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">path</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">path</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">sum</span>
<span class="p">}</span>
</pre></div>


<p>Although <code>Path</code> is a named slice type, not a struct type like <code>Point</code>, we can still define methods for it.</p>
<p>Unlike many other object-oriented languages, <u>Go allows methods to be associated with any type, such as numbers, strings, slices, maps, and even functions.</u> Methods may be declared on any named type defined in the same package, so long as its underlying type is neither a pointer nor an interface.</p>
<p>The two <code>Distance</code> methods have different types. They're not related to each other at all, though <code>Path.Distance</code> uses <code>Point.Distance</code> internally to compute the length of each segment that connects adjacent points.</p>
<p>The following code calls the new method to compute the perimeter of a right triangle:</p>
<div class="codehilite"><pre><span class="nx">perim</span> <span class="o">:=</span> <span class="nx">Path</span><span class="p">{</span>
    <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>
    <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>
    <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span>
    <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>
<span class="p">}</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">perim</span><span class="p">.</span><span class="nx">Distance</span><span class="p">())</span> <span class="c1">// &quot;12&quot;</span>
</pre></div>


<p>In the two examples above, there are two calls to methods named <code>Distance</code>. <u>The compiler determines which function to call based on both the method name and the type of the receiver.</u></p>
<ul>
<li>In the first, <code>path[i-1]</code> has type <code>Point</code> so <code>Point.Distance</code> is called.</li>
<li>In the second, <code>perim</code> has type <code>Path</code>, so <code>Path.Distance</code> is called.</li>
</ul>
<p>All methods of a given type must have unique names, but different types can use the same name for a method, like the <code>Distance</code> methods for <code>Point</code> and <code>Path</code>; there's no need to qualify function names (for example, <code>PathDistance</code>) to disambiguate. The first benefit to using methods over ordinary functions is: method names can be shorter. This benefit is magnified for calls originating outside the package, since they can use the shorter name and omit the package name:</p>
<div class="codehilite"><pre><span class="kn">import</span> <span class="s">&quot;gopl.io/ch6/geometry&quot;</span>
<span class="nx">perim</span> <span class="o">:=</span> <span class="nx">geometry</span><span class="p">.</span><span class="nx">Path</span><span class="p">{{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">}}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">geometry</span><span class="p">.</span><span class="nx">PathDistance</span><span class="p">(</span><span class="nx">perim</span><span class="p">))</span> <span class="c1">// &quot;12&quot;, standalone function</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">perim</span><span class="p">.</span><span class="nx">Distance</span><span class="p">())</span>             <span class="c1">// &quot;12&quot;, method of geometry.Path</span>
</pre></div>


<h3 id="methods-with-a-pointer-receiver">Methods with a Pointer Receiver<a class="headerlink" href="#methods-with-a-pointer-receiver" title="Permanent link">&para;</a></h3>
<p>Calling a function makes a copy of each argument value. If either of the following occurs, we must pass the address of the variable using a pointer:</p>
<ul>
<li>The function needs to update a variable.</li>
<li>An argument is so large that we wish to avoid copying it.</li>
</ul>
<p>The same goes for methods that need to update the receiver variable: we attach them to the pointer type, such as <code>*Point</code>. For example:</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Point</span><span class="p">)</span> <span class="nx">ScaleBy</span><span class="p">(</span><span class="nx">factor</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">X</span> <span class="o">*=</span> <span class="nx">factor</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">Y</span> <span class="o">*=</span> <span class="nx">factor</span>
<span class="p">}</span>
</pre></div>


<p>The name of this method is <code>(*Point).ScaleBy</code>. The parentheses are necessary; without them, the expression would be parsed as <code>*(Point.ScaleBy)</code>.</p>
<p>Convention dictates that if any method of <code>Point</code> has a pointer receiver, then all methods of <code>Point</code> should have a pointer receiver, even ones that don't strictly need it.  We've broken this rule for <code>Point</code> so that we can show both kinds of method.</p>
<p>Named types (<code>Point</code>) and pointers to them (<code>*Point</code>) are the only types that may appear in a
receiver declaration. <u>To avoid ambiguities, method declarations are not permitted on named types that are themselves <code>pointer</code> types</u>:</p>
<div class="codehilite"><pre><span class="kd">type</span> <span class="nx">P</span> <span class="o">*</span><span class="kt">int</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">P</span><span class="p">)</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span> <span class="c1">// compile error: invalid receiver type</span>
</pre></div>


<p>The <code>(*Point).ScaleBy</code> method can be called by providing a <code>*Point</code> receiver. The following three cases are equivalent:</p>
<div class="codehilite"><pre><span class="nx">r</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="nx">r</span><span class="p">.</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">*</span><span class="nx">r</span><span class="p">)</span> <span class="c1">// &quot;{2, 4}&quot;</span>
</pre></div>


<div class="codehilite"><pre><span class="nx">p</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="nx">pptr</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">p</span>
<span class="nx">pptr</span><span class="p">.</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="c1">// &quot;{2, 4}&quot;</span>
</pre></div>


<div class="codehilite"><pre><span class="nx">p</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">).</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="c1">// &quot;{2, 4}&quot;</span>
</pre></div>


<p>The last two cases are verbose; <u>if the receiver <code>p</code> is a variable of type <code>Point</code> but the method requires a <code>*Point</code> receiver, the compiler will perform an implicit <code>&amp;p</code> on the variable.</u> So we can use the following shorthand:</p>
<div class="codehilite"><pre><span class="nx">p</span><span class="p">.</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>


<p>This works only for variables, including struct fields like <code>p.X</code> and array or slice elements like <code>perim[0]</code>. We cannot call a <code>*Point</code> method on a non-addressable <code>Point</code> receiver, because there's no way to obtain the address of a temporary value. For example:</p>
<div class="codehilite"><pre><span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}.</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// compile error: can&#39;t take address of Point literal</span>
</pre></div>


<p>However, we can call a <code>Point</code> method (e.g. <code>Point.Distance</code>) with a <code>*Point</code> receiver, because there is a way to obtain the value from the address by loading the value pointed to by the receiver. The compiler will perform an implicit <code>*</code> on the variable. These two function calls are equivalent:</p>
<div class="codehilite"><pre><span class="nx">pptr</span><span class="p">.</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span><span class="p">)</span>
<span class="p">(</span><span class="o">*</span><span class="nx">pptr</span><span class="p">).</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span><span class="p">)</span>
</pre></div>


<h4 id="summary-of-three-cases">Summary of three cases *<a class="headerlink" href="#summary-of-three-cases" title="Permanent link">&para;</a></h4>
<p>In every valid method call expression, exactly one of these three statements is true.</p>
<p><strong>Case 1: the receiver argument has the same type as the receiver parameter.</strong> For example, both have type <code>T</code> or both have type <code>*T</code>:</p>
<div class="codehilite"><pre><span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}.</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span><span class="p">)</span> <span class="c1">// Point</span>
<span class="nx">pptr</span><span class="p">.</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>         <span class="c1">// *Point</span>
</pre></div>


<p><strong>Case 2: the receiver argument is a variable of type <code>T</code> and the receiver parameter has type <code>*T</code>.</strong> The compiler implicitly takes the address of the variable. For example:</p>
<div class="codehilite"><pre><span class="nx">p</span><span class="p">.</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// implicit (&amp;p)</span>
</pre></div>


<p><strong>Case 3: the receiver argument has type <code>*T</code> and the receiver parameter has type <code>T</code>.</strong> The compiler implicitly dereferences the receiver, in other words, loads the value. For example:</p>
<div class="codehilite"><pre><span class="nx">pptr</span><span class="p">.</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span><span class="p">)</span> <span class="c1">// implicit (*pptr)</span>
</pre></div>


<p>If all the methods of a named type <code>T</code> have a receiver type of <code>T</code> itself (not <code>*T</code>), it is safe to copy instances of that type; calling any of its methods necessarily makes a copy. For example, <code>time.Duration</code> values are liberally copied, including as arguments to functions.</p>
<p>But if any method has a pointer receiver, you should avoid copying instances of <code>T</code> because doing so may violate internal invariants. For example, copying an instance of <code>bytes.Buffer</code> would cause the original and the copy to alias (<a href="../ch2/#pointers">Section 2.3.2</a>) the same underlying array of bytes. Subsequent method calls would have unpredictable effects.</p>
<h4 id="nil-is-a-valid-receiver-value">Nil Is a Valid Receiver Value<a class="headerlink" href="#nil-is-a-valid-receiver-value" title="Permanent link">&para;</a></h4>
<p>Some methods allow nil pointers as their receivers, especially if <code>nil</code> is a meaningful zero value of the type (e.g. maps and slices), just as some functions allow nil pointers as arguments. For example, <code>nil</code> represents the empty list:</p>
<div class="codehilite"><pre><span class="c1">// An IntList is a linked list of integers.</span>
<span class="c1">// A nil *IntList represents the empty list.</span>
<span class="kd">type</span> <span class="nx">IntList</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Value</span> <span class="kt">int</span>
    <span class="nx">Tail</span> <span class="o">*</span><span class="nx">IntList</span>
<span class="p">}</span>

<span class="c1">// Sum returns the sum of the list elements.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">list</span> <span class="o">*</span><span class="nx">IntList</span><span class="p">)</span> <span class="nx">Sum</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">list</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">list</span><span class="p">.</span><span class="nx">Value</span> <span class="o">+</span> <span class="nx">list</span><span class="p">.</span><span class="nx">Tail</span><span class="p">.</span><span class="nx">Sum</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>


<p>When you define a type whose methods allow nil as a receiver value, it's worth documenting this explicitly in the comment, as in the example above.</p>
<p>The following is part of the definition of the Values type from the <a href="https://golang.org/pkg/net/url/"><code>net/url</code></a> package:</p>
<div class="codehilite"><pre><span class="kn">package</span> <span class="nx">url</span>

<span class="c1">// Values maps a string key to a list of values.</span>
<span class="kd">type</span> <span class="nx">Values</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">string</span>

<span class="c1">// Get returns the first value associated with the given key,</span>
<span class="c1">// or &quot;&quot; if there are none.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">Values</span><span class="p">)</span> <span class="nx">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">vs</span> <span class="o">:=</span> <span class="nx">v</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span> <span class="nb">len</span><span class="p">(</span><span class="nx">vs</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">vs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="s">&quot;&quot;</span>
<span class="p">}</span>

<span class="c1">// Add adds the value to key.</span>
<span class="c1">// It appends to any existing values associated with key.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">Values</span><span class="p">)</span> <span class="nx">Add</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">v</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">v</span><span class="p">[</span><span class="nx">key</span><span class="p">],</span> <span class="nx">value</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>It exposes its representation as a map but also provides methods to simplify access to the map, whose values are slices of strings; it's a <a href="https://en.wikipedia.org/wiki/Multimap"><em>multimap</em></a>. Its clients can use its intrinsic operators (<code>make</code>, slice literals, <code>m[key]</code>, and so on), or its methods, or both:</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch6/urlvalues/main.go">gopl.io/ch6/urlvalues/main.go</a></small></p>
<div class="codehilite"><pre><span class="nx">m</span> <span class="o">:=</span> <span class="nx">url</span><span class="p">.</span><span class="nx">Values</span><span class="p">{</span><span class="s">&quot;lang&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s">&quot;en&quot;</span><span class="p">}}</span> <span class="c1">// direct construction</span>
<span class="nx">m</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="s">&quot;item&quot;</span><span class="p">,</span> <span class="s">&quot;1&quot;</span><span class="p">)</span>
<span class="nx">m</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="s">&quot;item&quot;</span><span class="p">,</span> <span class="s">&quot;2&quot;</span><span class="p">)</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="s">&quot;lang&quot;</span><span class="p">))</span> <span class="c1">// &quot;en&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="s">&quot;q&quot;</span><span class="p">))</span>    <span class="c1">// &quot;&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="s">&quot;item&quot;</span><span class="p">))</span> <span class="c1">// &quot;1&quot;      (first value)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">m</span><span class="p">[</span><span class="s">&quot;item&quot;</span><span class="p">])</span>     <span class="c1">// &quot;[1 2]&quot;  (direct map access)</span>

<span class="nx">m</span> <span class="p">=</span> <span class="kc">nil</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="s">&quot;item&quot;</span><span class="p">))</span> <span class="c1">// &quot;&quot;</span>
<span class="nx">m</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="s">&quot;item&quot;</span><span class="p">,</span> <span class="s">&quot;3&quot;</span><span class="p">)</span>         <span class="c1">// panic: assignment to entry in nil map</span>
</pre></div>


<p>In the final call to <code>Get</code>, the nil receiver behaves like an empty map. It is equivalent to being written as <code>Values(nil).Get("item"))</code>, not <code>nil.Get("item")</code>, which will not compile because the type of <code>nil</code> has not been determined (see <a href="https://play.golang.org/p/fW0q7pRRUp">modified version of the example above</a>). By contrast, the final call to <code>Add</code> panics as it tries to update a <code>nil</code> map.</p>
<p>Because <code>url.Values</code> is a map type and a map refers to its key/value pairs indirectly, any updates and deletions that <code>url.Values.Add</code> makes to the map elements are visible to the caller. However, as with ordinary functions, any changes a method makes to the reference itself, like setting it to <code>nil</code> or making it refer to a different map data structure, will not be reflected in the caller.</p>
<h3 id="composing-types-by-struct-embedding">Composing Types by Struct Embedding<a class="headerlink" href="#composing-types-by-struct-embedding" title="Permanent link">&para;</a></h3>
<p>The following example defines a <code>ColoredPoint</code> type:</p>
<div class="codehilite"><pre><span class="kn">import</span> <span class="s">&quot;image/color&quot;</span>

<span class="kd">type</span> <span class="nx">Point</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span> <span class="kt">float64</span> <span class="p">}</span>

<span class="kd">type</span> <span class="nx">ColoredPoint</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Point</span>
    <span class="nx">Color</span> <span class="nx">color</span><span class="p">.</span><span class="nx">RGBA</span>
<span class="p">}</span>
</pre></div>


<p>We could have defined <code>ColoredPoint</code> as a struct of three fields, but instead we embedded a <code>Point</code> to provide the <code>X</code> and <code>Y</code> fields. As discussed in <a href="../ch4/#struct-embedding-and-anonymous-fields">Section 4.4.3</a>, embedding enables us to take a syntactic shortcut to defining a <code>ColoredPoint</code> that contains all the fields of <code>Point</code>, plus some more. We can select the fields of <code>ColoredPoint</code> that were contributed by the embedded <code>Point</code> without mentioning <code>Point</code>:</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">cp</span> <span class="nx">ColoredPoint</span>
<span class="nx">cp</span><span class="p">.</span><span class="nx">X</span> <span class="p">=</span> <span class="mi">1</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">cp</span><span class="p">.</span><span class="nx">Point</span><span class="p">.</span><span class="nx">X</span><span class="p">)</span> <span class="c1">// &quot;1&quot;</span>
<span class="nx">cp</span><span class="p">.</span><span class="nx">Point</span><span class="p">.</span><span class="nx">Y</span> <span class="p">=</span> <span class="mi">2</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">cp</span><span class="p">.</span><span class="nx">Y</span><span class="p">)</span> <span class="c1">// &quot;2&quot;</span>
</pre></div>


<p>A similar mechanism applies to the methods of <code>Point</code>. We can call methods of the embedded <code>Point</code> field using a receiver of type <code>ColoredPoint</code>, even though <code>ColoredPoint</code> has no declared methods:</p>
<div class="codehilite"><pre><span class="nx">red</span> <span class="o">:=</span> <span class="nx">color</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">{</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">}</span>
<span class="nx">blue</span> <span class="o">:=</span> <span class="nx">color</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">}</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="p">=</span> <span class="nx">ColoredPoint</span><span class="p">{</span><span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="nx">red</span><span class="p">}</span>
<span class="kd">var</span> <span class="nx">q</span> <span class="p">=</span> <span class="nx">ColoredPoint</span><span class="p">{</span><span class="nx">Point</span><span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span> <span class="nx">blue</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">Point</span><span class="p">))</span> <span class="c1">// &quot;5&quot;</span>
<span class="nx">p</span><span class="p">.</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="nx">q</span><span class="p">.</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">Point</span><span class="p">))</span> <span class="c1">// &quot;10&quot;</span>
</pre></div>


<p>The methods of <code>Point</code> have been <em>promoted</em> to <code>ColoredPoint</code>. In this way, <u>embedding allows complex types with many methods to be built up by the <em>composition</em> of several fields, each providing a few methods.</u></p>
<p>Note that it is a mistake to view <code>Point</code> as a base class and <code>ColoredPoint</code> as a subclass or derived class, or to interpret the relationship between these types as if a <code>ColoredPoint</code> "is a" <code>Point</code>, from a object-oriented language perspective. Notice the calls to <code>Distance</code> above. <code>Distance</code> has a parameter of type <code>Point</code>, and <code>q</code> is not a <code>Point</code>, so although <code>q</code> does have an embedded field of that type, we must explicitly select it. Attempting to pass <code>q</code> would be an error:</p>
<div class="codehilite"><pre><span class="nx">p</span><span class="p">.</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span><span class="p">)</span> <span class="c1">// compile error: cannot use q (ColoredPoint) as Point</span>
</pre></div>


<p>A <code>ColoredPoint</code> is not a <code>Point</code>, but it "has a" <code>Point</code>, and it has two additional methods <code>Distance</code> and <code>ScaleBy</code> promoted from <code>Point</code>. In terms of implementation, the embedded field instructs the compiler to generate additional wrapper methods that delegate to the declared methods, equivalent to these:</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">ColoredPoint</span><span class="p">)</span> <span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span> <span class="nx">Point</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Point</span><span class="p">.</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">ColoredPoint</span><span class="p">)</span> <span class="nx">ScaleBy</span><span class="p">(</span><span class="nx">factor</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">Point</span><span class="p">.</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="nx">factor</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>When <code>Point.Distance</code> is called by the first of these wrapper methods, its receiver value is <code>p.Point</code>, not <code>p</code>. <u>There is no way for the <code>Point.Distance</code> method to access the <code>ColoredPoint</code> in which the <code>Point</code> is embedded.</u></p>
<p>The type of an anonymous field may be a pointer to a named type, in which case fields and methods are promoted indirectly from the pointed-to object. Adding another level of indirection enables us to share common structures and vary the relationships between objects dynamically. The declaration of <code>ColoredPoint</code> below embeds a <code>*Point</code>:</p>
<div class="codehilite"><pre><span class="kd">type</span> <span class="nx">ColoredPoint</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="o">*</span><span class="nx">Point</span>
    <span class="nx">Color</span> <span class="nx">color</span><span class="p">.</span><span class="nx">RGBA</span>
<span class="p">}</span>

<span class="nx">p</span> <span class="o">:=</span> <span class="nx">ColoredPoint</span><span class="p">{</span><span class="o">&amp;</span><span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="nx">red</span><span class="p">}</span>
<span class="nx">q</span> <span class="o">:=</span> <span class="nx">ColoredPoint</span><span class="p">{</span><span class="o">&amp;</span><span class="nx">Point</span><span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span> <span class="nx">blue</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">Distance</span><span class="p">(</span><span class="o">*</span><span class="nx">q</span><span class="p">.</span><span class="nx">Point</span><span class="p">))</span> <span class="c1">// &quot;5&quot;</span>
<span class="nx">q</span><span class="p">.</span><span class="nx">Point</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Point</span>                 <span class="c1">// p and q now share the same Point</span>
<span class="nx">p</span><span class="p">.</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">.</span><span class="nx">Point</span><span class="p">,</span> <span class="o">*</span><span class="nx">q</span><span class="p">.</span><span class="nx">Point</span><span class="p">)</span> <span class="c1">// &quot;{2 2} {2 2}&quot;</span>
</pre></div>


<p>A struct type may have more than one anonymous field. If the declaration of <code>ColoredPoint</code> is:</p>
<div class="codehilite"><pre><span class="kd">type</span> <span class="nx">ColoredPoint</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Point</span>
    <span class="nx">color</span><span class="p">.</span><span class="nx">RGBA</span>
<span class="p">}</span>
</pre></div>


<p>Then a value of this type would have the following:</p>
<ul>
<li>All the methods of <code>Point</code></li>
<li>All the methods of <code>RGBA</code></li>
<li>Any additional methods declared on <code>ColoredPoint</code> directly</li>
</ul>
<p>When the compiler resolves a selector such as <code>p.ScaleBy</code> to a method, it looks for that method in the following order:</p>
<ol>
<li>Directly declared method named <code>ScaleBy</code></li>
<li>Methods promoted once from <code>ColoredPoint</code>'s embedded fields</li>
<li>Methods promoted twice from embedded fields within <code>Point</code> and <code>RGBA</code>, and so on</li>
</ol>
<p>The compiler reports an error if the selector was ambiguous because two methods were promoted from the same rank.</p>
<p>Methods can be declared only on named types (e.g. <code>Point</code>) and pointers to them (e.g. <code>*Point</code>). With embedding, it's possible and sometimes useful for <em>unnamed</em> struct types to have methods.</p>
<p>The following example shows part of a simple cache implemented using two package-level variables, a mutex (<a href="../ch9/##mutual-exclusion-syncmutex">Section 9.2</a>) and the map that it guards:</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="p">(</span>
    <span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span> <span class="c1">// guards mapping</span>
    <span class="nx">mapping</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">Lookup</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
    <span class="nx">v</span> <span class="o">:=</span> <span class="nx">mapping</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
    <span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
    <span class="k">return</span> <span class="nx">v</span>
<span class="p">}</span>
</pre></div>


<p>The version below is functionally equivalent but groups together the two related variables in a single package-level variable, cache:</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">cache</span> <span class="p">=</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
    <span class="nx">mapping</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span>
<span class="p">}</span> <span class="p">{</span>
    <span class="nx">mapping</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">),</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">Lookup</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="nx">cache</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
    <span class="nx">v</span> <span class="o">:=</span> <span class="nx">cache</span><span class="p">.</span><span class="nx">mapping</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
    <span class="nx">cache</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
    <span class="k">return</span> <span class="nx">v</span>
<span class="p">}</span>
</pre></div>


<p>The new variable gives more expressive names to the variables related to the cache, and because the <code>sync.Mutex</code> field is embedded within it, its <code>Lock</code> and <code>Unlock</code> methods are promoted to the unnamed struct type, allowing us to lock the <code>cache</code> with a self-explanatory syntax.</p>
<h3 id="method-values-and-expressions">Method Values and Expressions<a class="headerlink" href="#method-values-and-expressions" title="Permanent link">&para;</a></h3>
<h4 id="method-values">Method Values *<a class="headerlink" href="#method-values" title="Permanent link">&para;</a></h4>
<p>Usually, we select and call a method in the same expression, as in <code>p.Distance()</code>, but it's possible to separate these two operations. The selector <code>p.Distance</code> yields a <strong>method value</strong>, a function that binds a method (<code>Point.Distance</code>) to a specific receiver value <code>p</code>. This function can then be invoked without a receiver value; it needs only the non-receiver arguments.</p>
<div class="codehilite"><pre><span class="nx">p</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="nx">q</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">}</span>
<span class="nx">distanceFromP</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Distance</span> <span class="c1">// method value</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">distanceFromP</span><span class="p">(</span><span class="nx">q</span><span class="p">))</span> <span class="c1">// &quot;5&quot;</span>
<span class="kd">var</span> <span class="nx">origin</span> <span class="nx">Point</span> <span class="c1">// {0, 0}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">distanceFromP</span><span class="p">(</span><span class="nx">origin</span><span class="p">))</span> <span class="c1">// &quot;2.23606797749979&quot;, √5</span>
<span class="nx">scaleP</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">ScaleBy</span> <span class="c1">// method value</span>
<span class="nx">scaleP</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// p becomes (2, 4)</span>
<span class="nx">scaleP</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1">// then (6, 12)</span>
<span class="nx">scaleP</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="c1">// then (60, 120)</span>
</pre></div>


<p>Method values are useful when a package's API requires a function value and the clients' desired behavior for that function is to call a method on a specific receiver.</p>
<p>For example, the function <a href="https://golang.org/pkg/time/#AfterFunc"><code>time.AfterFunc</code></a> calls a function value after a specified delay. The following program uses it to launch the rocket <code>r</code> after 10 seconds:</p>
<div class="codehilite"><pre><span class="kd">type</span> <span class="nx">Rocket</span> <span class="kd">struct</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Rocket</span><span class="p">)</span> <span class="nx">Launch</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="nx">r</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">Rocket</span><span class="p">)</span>
<span class="nx">time</span><span class="p">.</span><span class="nx">AfterFunc</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Launch</span><span class="p">()</span> <span class="p">})</span>
</pre></div>


<p>The last line above can be replaced with a shorter equivalent method value synatx:</p>
<div class="codehilite"><pre><span class="nx">time</span><span class="p">.</span><span class="nx">AfterFunc</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Launch</span><span class="p">)</span>
</pre></div>


<h4 id="method-expressions">Method Expressions *<a class="headerlink" href="#method-expressions" title="Permanent link">&para;</a></h4>
<p>Related to the method value is the <strong>method expression</strong>. When calling a method, as opposed to an ordinary function, we must supply the receiver in a special way using the selector syntax. A method expression, written <code>T.f</code> or <code>(*T).f</code> where <code>T</code> is a type, yields a function value with a regular first parameter taking the place of the receiver, so it can be called in the usual way.</p>
<div class="codehilite"><pre><span class="nx">p</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="nx">q</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">}</span>
<span class="nx">distance</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">.</span><span class="nx">Distance</span> <span class="c1">// method expression</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">distance</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">q</span><span class="p">))</span> <span class="c1">// &quot;5&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%T\n&quot;</span><span class="p">,</span> <span class="nx">distance</span><span class="p">)</span> <span class="c1">// &quot;func(Point, Point) float64&quot;</span>
<span class="nx">scale</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">Point</span><span class="p">).</span><span class="nx">ScaleBy</span>
<span class="nx">scale</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="c1">// &quot;{2 4}&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%T\n&quot;</span><span class="p">,</span> <span class="nx">scale</span><span class="p">)</span> <span class="c1">// &quot;func(*Point, float64)&quot;</span>
</pre></div>


<p>Method expressions can be helpful when you need a value to represent a choice among several methods belonging to the same type so that you can call the chosen method with many different receivers.</p>
<p>In the following example, the variable <code>op</code> represents either the addition or the subtraction method of type <code>Point</code>, and <code>Path.TranslateBy</code> calls it for each point in the <code>Path</code>:</p>
<div class="codehilite"><pre><span class="kd">type</span> <span class="nx">Point</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span> <span class="kt">float64</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">Point</span><span class="p">)</span> <span class="nx">Add</span><span class="p">(</span><span class="nx">q</span> <span class="nx">Point</span><span class="p">)</span> <span class="nx">Point</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">Point</span><span class="p">{</span><span class="nx">p</span><span class="p">.</span><span class="nx">X</span> <span class="o">+</span> <span class="nx">q</span><span class="p">.</span><span class="nx">X</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Y</span> <span class="o">+</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Y</span><span class="p">}</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">Point</span><span class="p">)</span> <span class="nx">Sub</span><span class="p">(</span><span class="nx">q</span> <span class="nx">Point</span><span class="p">)</span> <span class="nx">Point</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">Point</span><span class="p">{</span><span class="nx">p</span><span class="p">.</span><span class="nx">X</span> <span class="o">-</span> <span class="nx">q</span><span class="p">.</span><span class="nx">X</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Y</span> <span class="o">-</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Y</span><span class="p">}</span> <span class="p">}</span>

<span class="kd">type</span> <span class="nx">Path</span> <span class="p">[]</span><span class="nx">Point</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">path</span> <span class="nx">Path</span><span class="p">)</span> <span class="nx">TranslateBy</span><span class="p">(</span><span class="nx">offset</span> <span class="nx">Point</span><span class="p">,</span> <span class="nx">add</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">op</span> <span class="kd">func</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">q</span> <span class="nx">Point</span><span class="p">)</span> <span class="nx">Point</span>
    <span class="k">if</span> <span class="nx">add</span> <span class="p">{</span>
        <span class="nx">op</span> <span class="p">=</span> <span class="nx">Point</span><span class="p">.</span><span class="nx">Add</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">op</span> <span class="p">=</span> <span class="nx">Point</span><span class="p">.</span><span class="nx">Sub</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">path</span> <span class="p">{</span>
        <span class="c1">// Call either path[i].Add(offset) or path[i].Sub(offset).</span>
        <span class="nx">path</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">op</span><span class="p">(</span><span class="nx">path</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">offset</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h3 id="example-bit-vector-type">Example: Bit Vector Type<a class="headerlink" href="#example-bit-vector-type" title="Permanent link">&para;</a></h3>
<p>Sets in Go are usually implemented as a <code>map[T]bool</code>, where <code>T</code> is the element type. Although a set represented by a map is very flexible, a specialized representation may outperform it. A <a href="https://en.wikipedia.org/wiki/Bit_array"><strong>bit vector</strong></a> is ideal in the following example cases:</p>
<ul>
<li>Dataflow analysis where set elements are small non-negative integers.</li>
<li>Sets have many elements.</li>
<li>Set operations like union and intersection are common.</li>
</ul>
<p>A bit vector uses a slice of unsigned integer values or "words", each bit of which represents a possible element of the set. The set contains <code>i</code> if the <code>i</code>-th bit is set. The following program demonstrates a simple bit vector type with three methods:</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch6/intset/intset.go">gopl.io/ch6/intset/intset.go</a></small></p>
<div class="codehilite"><pre><span class="c1">// An IntSet is a set of small non-negative integers.</span>
<span class="c1">// Its zero value represents the empty set.</span>
<span class="kd">type</span> <span class="nx">IntSet</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">words</span> <span class="p">[]</span><span class="kt">uint64</span>
<span class="p">}</span>

<span class="c1">// Has reports whether the set contains the non-negative value x.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">IntSet</span><span class="p">)</span> <span class="nx">Has</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="nx">word</span><span class="p">,</span> <span class="nx">bit</span> <span class="o">:=</span> <span class="nx">x</span><span class="o">/</span><span class="mi">64</span><span class="p">,</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">x</span><span class="o">%</span><span class="mi">64</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">word</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">words</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">words</span><span class="p">[</span><span class="nx">word</span><span class="p">]</span><span class="o">&amp;</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">bit</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
<span class="p">}</span>

<span class="c1">// Add adds the non-negative value x to the set.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">IntSet</span><span class="p">)</span> <span class="nx">Add</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">word</span><span class="p">,</span> <span class="nx">bit</span> <span class="o">:=</span> <span class="nx">x</span><span class="o">/</span><span class="mi">64</span><span class="p">,</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">x</span><span class="o">%</span><span class="mi">64</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">word</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">words</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">s</span><span class="p">.</span><span class="nx">words</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">words</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">s</span><span class="p">.</span><span class="nx">words</span><span class="p">[</span><span class="nx">word</span><span class="p">]</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">bit</span>
<span class="p">}</span>

<span class="c1">// UnionWith sets s to the union of s and t.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">IntSet</span><span class="p">)</span> <span class="nx">UnionWith</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">IntSet</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">tword</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">t</span><span class="p">.</span><span class="nx">words</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">words</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">s</span><span class="p">.</span><span class="nx">words</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">|=</span> <span class="nx">tword</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">s</span><span class="p">.</span><span class="nx">words</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">words</span><span class="p">,</span> <span class="nx">tword</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>Since each word has 64 bits, to locate the bit for <code>x</code>, we use the quotient <code>x/64</code> as the word index and the remainder <code>x%64</code> as the bit index within that word. The <code>UnionWith</code> operation uses the bitwise OR operator <code>|</code> to compute the union 64 elements at a time.</p>
<p>The following code defines a method to print an <code>IntSet</code> as a string:</p>
<div class="codehilite"><pre><span class="c1">// String returns the set as a string of the form &quot;{1 2 3}&quot;.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">IntSet</span><span class="p">)</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">buf</span> <span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span>
    <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteByte</span><span class="p">(</span><span class="sc">&#39;{&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">word</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span><span class="p">.</span><span class="nx">words</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">word</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">continue</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="mi">64</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">word</span><span class="o">&amp;</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nb">uint</span><span class="p">(</span><span class="nx">j</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="k">if</span> <span class="nx">buf</span><span class="p">.</span><span class="nx">Len</span><span class="p">()</span> <span class="p">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="s">&quot;{&quot;</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteByte</span><span class="p">(</span><span class="sc">&#39; &#39;</span><span class="p">)</span>
                <span class="p">}</span>
                <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">buf</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="mi">64</span><span class="o">*</span><span class="nx">i</span><span class="o">+</span><span class="nx">j</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteByte</span><span class="p">(</span><span class="sc">&#39;}&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">buf</span><span class="p">.</span><span class="nx">String</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>


<p>Notice the similarity of the <code>String</code> method above with <a href="https://github.com/shichao-an/gopl.io/blob/master/ch3/printints/main.go"><code>intsToString</code></a> in <a href="../ch3/#strings-and-byte-slices">Section 3.5.4</a>:</p>
<ul>
<li><code>bytes.Buffer</code> is often used this way in <code>String</code> methods.</li>
<li>The <code>fmt</code> package treats types with a <code>String</code> method specially so that values of complicated types can display themselves in a user-friendly manner. Instead of printing the raw representation of the value (a struct in this case), <code>fmt</code> calls the <code>String</code> method.</li>
<li>The mechanism relies on interfaces and type assertions, which is explained in <a href="../ch7/">Chapter 7</a>.</li>
</ul>
<p>The following code demonstrates the use of <code>IntSet</code>:</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="nx">IntSet</span>
<span class="nx">x</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="nx">x</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">144</span><span class="p">)</span>
<span class="nx">x</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span> <span class="c1">// &quot;{1 9 144}&quot;</span>

<span class="nx">y</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="nx">y</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">y</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span> <span class="c1">// &quot;{9 42}&quot;</span>

<span class="nx">x</span><span class="p">.</span><span class="nx">UnionWith</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">y</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span> <span class="c1">// &quot;{1 9 42 144}&quot;</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">Has</span><span class="p">(</span><span class="mi">9</span><span class="p">),</span> <span class="nx">x</span><span class="p">.</span><span class="nx">Has</span><span class="p">(</span><span class="mi">123</span><span class="p">))</span> <span class="c1">// &quot;true false&quot;</span>
</pre></div>


<p>Note that we declared <code>String</code> and <code>Has</code> as methods of the pointer type <code>*IntSet</code> not out of necessity, but for consistency with the other two methods (<code>Add</code> and <code>UnionWith</code>), which need a pointer receiver because they assign to <code>s.words</code>. Consequently, an <code>IntSet</code> value does not have a <code>String</code> method:</p>
<div class="codehilite"><pre><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">x</span><span class="p">)</span>         <span class="c1">// &quot;{1 9 42 144}&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span> <span class="c1">// &quot;{1 9 42 144}&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>          <span class="c1">// &quot;{[4398046511618 0 65536]}&quot;</span>
</pre></div>


<ol>
<li>In the first case, we print an <code>*IntSet</code> pointer, which does have a <code>String</code> method.</li>
<li>In the second case, we call <code>String()</code> on an <code>IntSet</code> variable; the compiler inserts the implicit <code>&amp;</code> operation, giving us a pointer, which has the <code>String</code> method.</li>
<li>In the third case, because the <code>IntSet</code> value does not have a <code>String</code> method, <code>fmt.Println</code> prints the representation of the struct instead. It's important not to forget the <code>&amp;</code> operator. Making <code>String</code> a method of <code>IntSet</code>, not <code>*IntSet</code>, might be a good idea, but this is a case-by-case judgment.</li>
</ol>
<h3 id="encapsulation">Encapsulation<a class="headerlink" href="#encapsulation" title="Permanent link">&para;</a></h3>
<p>A variable or method of an object is said to be <em>encapsulated</em> if it is inaccessible to clients of the object. <a href="https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)">Encapsulation</a>, sometimes called <a href="https://en.wikipedia.org/wiki/Information_hiding"><em>information hiding</em></a>, is a key aspect of object-oriented programming.</p>
<p>Go has only one mechanism to control the visibility of names: capitalized identifiers are exported from the package in which they are defined, and uncapitalized names are not. This mechanism not only limits access to members of a package, but also limits access to the fields of a struct or the methods of a type. As a consequence, to encapsulate an object, it must be made into a struct.</p>
<p>That's the reason the <code>IntSet</code> type from the previous section was declared as a struct type, even though it has only a single field:</p>
<div class="codehilite"><pre><span class="kd">type</span> <span class="nx">IntSet</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">words</span> <span class="p">[]</span><span class="kt">uint64</span>
<span class="p">}</span>
</pre></div>


<p><code>IntSet</code> could be defined as a slice type as follows (we also have to replace each occurrence of <code>s.words</code> by <code>*s</code> in its methods):</p>
<div class="codehilite"><pre><span class="kd">type</span> <span class="nx">IntSet</span> <span class="p">[]</span><span class="kt">uint64</span>
</pre></div>


<p>Although this version of <code>IntSet</code> would be essentially equivalent, it would allow clients from other packages to read and modify the slice directly. In other words, whereas the expression <code>*s</code> could be used in any package, <code>s.words</code> may appear only in the package that defines <code>IntSet</code>.</p>
<p>Another consequence of this name-based mechanism is that the unit of encapsulation is the package, not the type as in many other languages. <u>The fields of a struct type are visible to all code within the same package.</u> Whether the code appears in a function or a method makes no difference.</p>
<h4 id="benefits-of-encapsulation">Benefits of encapsulation *<a class="headerlink" href="#benefits-of-encapsulation" title="Permanent link">&para;</a></h4>
<p>Encapsulation provides three benefits.</p>
<p>First, because clients cannot directly modify the object's variables, one need inspect fewer statements to understand the possible values of those variables.</p>
<p>Second, hiding implementation details prevents clients from depending on things that might change, which gives the designer greater freedom to evolve the implementation without breaking API compatibility.</p>
<p>For example, the <code>bytes.Buffer</code> type is frequently used to accumulate very short strings. For optimization, it reserves a little extra space in the object to avoid memory allocation in this common case. Since <code>Buffer</code> is a struct type, this space takes the form of an extra field of type <code>[64]byte</code> with an uncapitalized name. When this field was added, because it was not exported, clients of <code>Buffer</code> outside the bytes package were unaware of any change except improved performance. <code>Buffer</code> and its <code>Grow</code> method are shown below (simplified for clarity):</p>
<div class="codehilite"><pre><span class="kd">type</span> <span class="nx">Buffer</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">buf</span> <span class="p">[]</span><span class="kt">byte</span>
    <span class="nx">initial</span> <span class="p">[</span><span class="mi">64</span><span class="p">]</span><span class="kt">byte</span>
    <span class="cm">/* ... */</span>
<span class="p">}</span>

<span class="c1">// Grow expands the buffer&#39;s capacity, if necessary,</span>
<span class="c1">// to guarantee space for another n bytes. [...]</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Buffer</span><span class="p">)</span> <span class="nx">Grow</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">buf</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">b</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">initial</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span> <span class="c1">// use preallocated space initially</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">buf</span><span class="p">)</span><span class="o">+</span><span class="nx">n</span> <span class="p">&gt;</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">buf</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">buf</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">Len</span><span class="p">(),</span> <span class="mi">2</span><span class="o">*</span><span class="nb">cap</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">buf</span><span class="p">)</span> <span class="o">+</span> <span class="nx">n</span><span class="p">)</span>
        <span class="nb">copy</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">buf</span><span class="p">)</span>
        <span class="nx">b</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nx">buf</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>Third, encapsulation prevents clients from setting an object's variables arbitrarily. Because the object's variables can be set only by functions in the same package, the author of that package can ensure that all those functions maintain the object's <a href="https://en.wikipedia.org/wiki/Class_invariant">internal invariants</a>. For example, the <code>Counter</code> type below permits clients to increment the counter or to reset it to zero, but not to set it to some arbitrary value:</p>
<div class="codehilite"><pre><span class="kd">type</span> <span class="nx">Counter</span> <span class="kd">struct</span> <span class="p">{</span> <span class="nx">n</span> <span class="kt">int</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Counter</span><span class="p">)</span> <span class="nx">N</span><span class="p">()</span> <span class="kt">int</span>     <span class="p">{</span> <span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">n</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Counter</span><span class="p">)</span> <span class="nx">Increment</span><span class="p">()</span> <span class="p">{</span> <span class="nx">c</span><span class="p">.</span><span class="nx">n</span><span class="o">++</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Counter</span><span class="p">)</span> <span class="nx">Reset</span><span class="p">()</span>     <span class="p">{</span> <span class="nx">c</span><span class="p">.</span><span class="nx">n</span> <span class="p">=</span> <span class="mi">0</span> <span class="p">}</span>
</pre></div>


<p>Functions that only access or modify internal values of a type, such as the methods of the <a href="https://golang.org/pkg/log/#Logger"><code>Logger</code></a> type from <a href="https://golang.org/pkg/log/"><code>log</code></a> package as shown below, are called <a href="https://en.wikipedia.org/wiki/Mutator_method"><em>getters</em> and <em>setters</em></a>. <u>However, when naming a getter method, we usually omit the <code>Get</code> prefix. This convention applies to all methods and to other redundant prefixes as well, such as <code>Fetch</code>, <code>Find</code>, and <code>Lookup</code>.</u></p>
<div class="codehilite"><pre><span class="kn">package</span> <span class="nx">log</span>

<span class="kd">type</span> <span class="nx">Logger</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">flags</span> <span class="kt">int</span>
    <span class="nx">prefix</span> <span class="kt">string</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">Logger</span><span class="p">)</span> <span class="nx">Flags</span><span class="p">()</span> <span class="kt">int</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">Logger</span><span class="p">)</span> <span class="nx">SetFlags</span><span class="p">(</span><span class="nx">flag</span> <span class="kt">int</span><span class="p">)</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">Logger</span><span class="p">)</span> <span class="nx">Prefix</span><span class="p">()</span> <span class="kt">string</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">Logger</span><span class="p">)</span> <span class="nx">SetPrefix</span><span class="p">(</span><span class="nx">prefix</span> <span class="kt">string</span><span class="p">)</span>
</pre></div>


<p>Go does not forbid exported fields; once exported, a field cannot be unexported without an incompatible change to the API. Therefore, the initial choice should be deliberate and should consider:</p>
<ul>
<li>The complexity of the invariants that must be maintained</li>
<li>The likelihood of future changes</li>
<li>The quantity of client code that would be affected by a change</li>
</ul>
<h4 id="other-aspects-of-encapsulation">Other aspects of encapsulation *<a class="headerlink" href="#other-aspects-of-encapsulation" title="Permanent link">&para;</a></h4>
<p>Encapsulation is not always desirable. For example, <code>time.Duration</code> reveals its representation as an <code>int64</code> number of nanoseconds, which enables us to use all the arithmetic and comparison operations, and even to define constants of this type:</p>
<div class="codehilite"><pre><span class="kd">const</span> <span class="nx">day</span> <span class="p">=</span> <span class="mi">24</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Hour</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">day</span><span class="p">.</span><span class="nx">Seconds</span><span class="p">())</span> <span class="c1">// &quot;86400&quot;</span>
</pre></div>


<p>As another example, contrast the <a href="#example-bit-vector-type"><code>IntSet</code> example</a> with the <a href="#method-declarations"><code>geometry.Path</code> example</a>. <code>Path</code> was defined as a slice type, allowing its clients to construct instances using the
slice literal syntax, to iterate over its points using a range loop, and so on, whereas these operations are denied to clients of <code>IntSet</code>.</p>
<p>The crucial difference is:</p>
<ul>
<li><code>geometry.Path</code> is intrinsically a sequence of points. We don't foresee adding new fields to it, so it makes sense for the <code>geometry</code> package to reveal <code>Path</code> as a slice.</li>
<li>In contrast, an <code>IntSet</code> merely happens to be represented as a <code>[]uint64</code> slice. It could have been represented using <code>[]uint</code>, or something completely different for sets that are sparse or very small. It might perhaps benefit from additional features like an extra field to record the number of elements in the set. For these reasons, it makes sense for <code>IntSet</code> to be opaque.</li>
</ul>
<p>Methods are crucial to object-oriented programming, but they're only half the picture; the other half, <em>interfaces</em>, is discussed in the next chapter.</p>
<h3 id="doubts-and-solution">Doubts and Solution<a class="headerlink" href="#doubts-and-solution" title="Permanent link">&para;</a></h3>
<h4 id="verbatim">Verbatim<a class="headerlink" href="#verbatim" title="Permanent link">&para;</a></h4>
<h5 id="p161-on-pointer-receiver"><strong>p161 on pointer receiver</strong><a class="headerlink" href="#p161-on-pointer-receiver" title="Permanent link">&para;</a></h5>
<blockquote>
<p>Any changes a method makes to the reference itself, like setting it to <code>nil</code> or making it refer to a different map data structure, will not be reflected in the caller.</p>
</blockquote>
<p><span class="text-danger">Question</span>: What does it mean?</p>
<p><span class="text-info">Solution</span>:</p>
<p>The "will not be reflected in the caller" probably means "no effect" in the caller function. This is similar to setting an argument (within the callee function) to <code>nil</code> or making it refer to another object.</p>
<h5 id="p168-on-pointer-receiver"><strong>p168 on pointer receiver</strong><a class="headerlink" href="#p168-on-pointer-receiver" title="Permanent link">&para;</a></h5>
<blockquote>
<p>First, because clients cannot directly modify the object's variables, one need inspect fewer statements to understand the possible values of those variables.</p>
</blockquote>
<p><span class="text-danger">Question</span>: Not sure what it means.</p>
            </div>
        </div>

        <footer class="col-md-12">
            
        </footer>

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script>
        <script src="../../js/base.js"></script>
        <script src="../../custom.js"></script>
    </body>
</html>