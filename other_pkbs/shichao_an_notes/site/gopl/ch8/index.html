<!DOCTYPE html>
<html lang="en">
    <head>
        <!-- Global Site Tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-59055167-2"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments)};
          gtag('js', new Date());

          gtag('config', 'UA-59055167-2');
        </script>

        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://notes.shichao.io/gopl/ch8/">
        <link rel="shortcut icon" href="../../toki_32.png">
        

	<title>Chapter 8. Goroutines and Channels - Shichao's Notes</title>

        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../../css/base.css" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,400italic,500,600" rel="stylesheet">
        <link href="../../custom.css" rel="stylesheet">
        <link href="../../friendly.css" rel="stylesheet">
        <link href="../../theme.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        
<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../..">Shichao's Notes</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">APUE <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../apue/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch1/">Chapter 1. UNIX System Overview</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch2/">Chapter 2. UNIX Standardization and Implementations</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch3/">Chapter 3. File I/O</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch4/">Chapter 4. Files and Directories</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch5/">Chapter 5. Standard I/O Library</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch6/">Chapter 6. System Data Files and Information</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch7/">Chapter 7. Process Environment</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch8/">Chapter 8. Process Control</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch9/">Chapter 9. Process Relationships</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch10/">Chapter 10. Signals</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch11/">Chapter 11. Threads</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch12/">Chapter 12. Thread Control</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch13/">Chapter 13. Daemon Processes</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch14/">Chapter 14. Advanced I/O</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch15/">Chapter 15. Interprocess Communication</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch16/">Chapter 16. Network IPC: Sockets</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch17/">Chapter 17. Advanced IPC</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UNP <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../unp/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch2/">Chapter 2. The Transport Layer: TCP, UDP, and SCTP</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch3/">Chapter 3. Sockets Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch4/">Chapter 4. Elementary TCP Sockets</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch5/">Chapter 5. TCP Client/Server Example</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch6/">Chapter 6. I/O Multiplexing: The select and poll Functions</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch7/">Chapter 7. Socket Options</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch8/">Chapter 8. Elementary UDP Sockets</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">TCPv1 <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../tcpv1/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch2/">Chapter 2. The Internet Address Architecture</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch3/">Chapter 3. Link Layer</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch4/">Chapter 4. ARP: Address Resolution Protocol</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch5/">Chapter 5. The Internet Protocol (IP)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch6/">Chapter 6. System Configuration: DHCP and Autoconfiguration</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch7/">Chapter 7. Firewalls and Network Address Translation (NAT)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch8/">Chapter 8. ICMPv4 and ICMPv6: Internet Control Message Protocol</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch9/">Chapter 9. Broadcasting and Local Multicasting (IGMP and MLD)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch10/">Chapter 10. User Datagram Protocol (UDP) and IP Fragmentation</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch11/">Chapter 11. Name Resolution and the Domain Name System (DNS)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch12/">Chapter 12. TCP: The Transmission Control Protocol (Preliminaries)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch13/">Chapter 13. TCP Connection Management</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch14/">Chapter 14. TCP Timeout and Retransmission</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch15/">Chapter 15. TCP Data Flow and Window Management</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch16/">Chapter 16. TCP Congestion Control</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch17/">Chapter 17. TCP Keepalive</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch18/">Chapter 18. Security: EAP, IPsec, TLS, DNSSEC, and DKIM</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/headers/">Headers</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">GOPL <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../ch1/">Chapter 1. Tutorial</a>
                        </li>
                      
                        <li>
                            <a href="../ch2/">Chapter 2. Program Structure</a>
                        </li>
                      
                        <li>
                            <a href="../ch3/">Chapter 3. Basic Data Types</a>
                        </li>
                      
                        <li>
                            <a href="../ch4/">Chapter 4. Composite Types</a>
                        </li>
                      
                        <li>
                            <a href="../ch5/">Chapter 5. Functions</a>
                        </li>
                      
                        <li>
                            <a href="../ch6/">Chapter 6. Methods</a>
                        </li>
                      
                        <li>
                            <a href="../ch7/">Chapter 7. Interfaces</a>
                        </li>
                      
                        <li class="active">
                            <a href="./">Chapter 8. Goroutines and Channels</a>
                        </li>
                      
                        <li>
                            <a href="../ch9/">Chapter 9. Concurrency with Shared Variables</a>
                        </li>
                      
                        <li>
                            <a href="../ch10/">Chapter 10. Packages and the Go Tool</a>
                        </li>
                      
                        <li>
                            <a href="../ch11/">Chapter 11. Testing</a>
                        </li>
                      
                        <li>
                            <a href="../ch12/">Chapter 12. Reflection</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">CSN <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../csn/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../csn/part1/">Part 1: Language</a>
                        </li>
                      
                        <li>
                            <a href="../../csn/part2/">Part 2: Advanced</a>
                        </li>
                      
                    </ul>
                </li>
            <li>
                    <a href="../../toc/">TOC</a>
                </li>
            </ul>
            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    
                        <a href="https://github.com/shichao-an/notes/blob/master/docs/gopl/ch8.md">
                    
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#chapter-8-goroutines-and-channels">Chapter 8. Goroutines and Channels</a></li>
        
    
        <li class="main "><a href="#goroutines">Goroutines</a></li>
        
    
        <li class="main "><a href="#example-concurrent-clock-server">Example: Concurrent Clock Server</a></li>
        
    
        <li class="main "><a href="#example-concurrent-echo-server">Example: Concurrent Echo Server</a></li>
        
    
        <li class="main "><a href="#channels">Channels</a></li>
        
            <li><a href="#unbuffered-channels">Unbuffered Channels</a></li>
        
            <li><a href="#pipelines">Pipelines</a></li>
        
            <li><a href="#unidirectional-channel-types">Unidirectional Channel Types</a></li>
        
            <li><a href="#buffered-channels">Buffered Channels</a></li>
        
    
        <li class="main "><a href="#looping-in-parallel">Looping in Parallel</a></li>
        
    
        <li class="main "><a href="#example-concurrent-web-crawler">Example: Concurrent Web Crawler</a></li>
        
    
        <li class="main "><a href="#multiplexing-with-select">Multiplexing with select</a></li>
        
    
        <li class="main "><a href="#example-concurrent-directory-traversal">Example: Concurrent Directory Traversal</a></li>
        
    
        <li class="main "><a href="#cancellation">Cancellation</a></li>
        
    
        <li class="main "><a href="#example-chat-server">Example: Chat Server</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">
              

<h3 id="chapter-8-goroutines-and-channels"><strong>Chapter 8. Goroutines and Channels</strong><a class="headerlink" href="#chapter-8-goroutines-and-channels" title="Permanent link">&para;</a></h3>
<p>Concurrent programming, the expression of a program as a composition of several autonomous activities, has never been more important than it is today.</p>
<p>Go enables two styles of concurrent programming.</p>
<ul>
<li>This chapter presents goroutines and channels, which support <a href="https://en.wikipedia.org/wiki/Communicating_sequential_processes">communicating sequential processes</a> (CSP), a model of concurrency in which values are passed between independent activities (goroutines) but variables are for the most part confined to a single activity.</li>
<li><a href="../ch9/">Chapter 9</a> covers some aspects of the more traditional model of <strong>shared memory multithreading</strong>, which will be familiar to those who used threads in other mainstream languages.</li>
</ul>
<h3 id="goroutines">Goroutines<a class="headerlink" href="#goroutines" title="Permanent link">&para;</a></h3>
<p>In Go, each concurrently executing activity is called a <em>goroutine</em>. If you have used operating system threads or threads in other languages, then you can assume for now that a goroutine is similar to a thread.  The differences between threads and goroutines are essentially quantitative, not qualitative, and will be described in <a href="../ch9/#goroutines-and-threads">Section 9.8</a>.</p>
<p>When a program starts, its only goroutine is the one that calls the <code>main</code> function, so we call it the <em>main goroutine</em>. New goroutines are created by the <code>go</code> statement:</p>
<ul>
<li>Syntactically, a <code>go</code> statement is an ordinary function or method call prefixed by the keyword <code>go</code>.</li>
<li>A <code>go</code> statement causes the function to be called in a newly created goroutine. The go statement itself completes immediately.</li>
</ul>
<div class="codehilite"><pre><span class="nx">f</span><span class="p">()</span>    <span class="c1">// call f(); wait for it to return</span>
<span class="k">go</span> <span class="nx">f</span><span class="p">()</span> <span class="c1">// create a new goroutine that calls f(); don&#39;t wait</span>
</pre></div>


<p>In the example below, the main goroutine computes the 45th Fibonacci number using an inefficient recursive algorithm, which runs for an appreciable time, during which we provide the user with a visual indication that the program is still running, by displaying an animated textual "spinner".</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/spinner/main.go">gopl.io/ch8/spinner/main.go</a></small></p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">go</span> <span class="nx">spinner</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
    <span class="kd">const</span> <span class="nx">n</span> <span class="p">=</span> <span class="mi">45</span>
    <span class="nx">fibN</span> <span class="o">:=</span> <span class="nx">fib</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="c1">// slow</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;\rFibonacci(%d) = %d\n&quot;</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">fibN</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">spinner</span><span class="p">(</span><span class="nx">delay</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">r</span> <span class="o">:=</span> <span class="k">range</span> <span class="s">`-\|/`</span> <span class="p">{</span>
            <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;\r%c&quot;</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
            <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">delay</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">fib</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">x</span> <span class="p">&lt;</span> <span class="mi">2</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">x</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">fib</span><span class="p">(</span><span class="nx">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nx">fib</span><span class="p">(</span><span class="nx">x</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>After several seconds of animation, the <code>fib(45)</code> call returns and the main function prints its result:</p>
<div class="codehilite"><pre>Fibonacci(45) = 1134903170
</pre></div>


<p>The <code>main</code> function then returns. When this happens, all goroutines are abruptly terminated and the program exits. Other than by returning from <code>main</code> or exiting the program, there is no programmatic way for one goroutine to stop another, but as we will see later, there are ways to communicate with a goroutine to request that it stop itself.</p>
<p>Notice how the program is expressed as the composition of two autonomous activities, spinning and Fibonacci computation. Each is written as a separate function but both make progress concurrently.</p>
<h3 id="example-concurrent-clock-server">Example: Concurrent Clock Server<a class="headerlink" href="#example-concurrent-clock-server" title="Permanent link">&para;</a></h3>
<p>Networking is a natural domain to use concurrency since servers typically handle many connections from their clients at once, each client being essentially independent of the others. This section introduces the <a href="https://golang.org/pkg/net/"><code>net</code></a> package, which provides the components for building networked client and server programs that communicate over TCP, UDP, or Unix domain sockets. The <a href="https://golang.org/pkg/net/http/"><code>net/http</code></a> package introduced since <a href="../ch1/">Chapter 1</a> is built on top of functions from the <code>net</code> package.</p>
<p>The first example is a sequential clock server that writes the current time to the client once per second:</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/clock1/clock.go">gopl.io/ch8/clock1/clock.go</a></small></p>
<div class="codehilite"><pre><span class="c1">// Clock1 is a TCP server that periodically writes the time.</span>
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;io&quot;</span>
    <span class="s">&quot;log&quot;</span>
    <span class="s">&quot;net&quot;</span>
    <span class="s">&quot;time&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">listener</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Listen</span><span class="p">(</span><span class="s">&quot;tcp&quot;</span><span class="p">,</span> <span class="s">&quot;localhost:8000&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">listener</span><span class="p">.</span><span class="nx">Accept</span><span class="p">()</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">log</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="c1">// e.g., connection aborted</span>
            <span class="k">continue</span>
        <span class="p">}</span>
        <span class="nx">handleConn</span><span class="p">(</span><span class="nx">conn</span><span class="p">)</span> <span class="c1">// handle one connection at a time</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">handleConn</span><span class="p">(</span><span class="nx">c</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">io</span><span class="p">.</span><span class="nx">WriteString</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">().</span><span class="nx">Format</span><span class="p">(</span><span class="s">&quot;15:04:05\n&quot;</span><span class="p">))</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">return</span> <span class="c1">// e.g., client disconnected</span>
        <span class="p">}</span>
        <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<ul>
<li>The <code>Listen</code> function creates a <a href="https://golang.org/pkg/net/#Listener"><code>net.Listener</code></a>, an object that listens for incoming connections on a network port, in this case TCP port <code>localhost:8000</code>. The listener's <code>Accept</code> method blocks until an incoming connection request is made, then returns a <a href="https://golang.org/pkg/net/#Conn"><code>net.Conn</code></a> object representing the connection.</li>
<li>The <code>handleConn</code> function handles one complete client connection.<ul>
<li>In a loop, it writes the current time, <code>time.Now()</code>, to the client.</li>
<li>Since <code>net.Conn</code> satisfies the <code>io.Writer</code> interface, we can write directly to it.</li>
<li>The loop ends when the write fails, most likely because the client has disconnected, at which point <code>handleConn</code> closes its side of the connection using a deferred call to <code>Close</code> and goes back to waiting for another connection request.</li>
</ul>
</li>
<li>The <code>time.Time.Format</code> method provides a way to format date and time information by example. Its argument is a template indicating how to format a reference time, specifically <code>Mon Jan 2 03:04:05PM 2006 UTC-0700</code>.<ul>
<li>The reference time has eight components. Any collection of them can appear in the <code>Format</code> string in any order and in a number of formats; the selected components of the date and time will be displayed in the selected formats. This example uses the hour, minute, and second of the time.</li>
<li>The <code>time</code> package defines templates for many standard time formats, such as <a href="https://golang.org/pkg/time/#pkg-constants"><code>time.RFC1123</code></a>. The same mechanism is used in reverse when parsing a time using <code>time.Parse</code>.</li>
</ul>
</li>
</ul>
<p>To connect to the server, we need a client program such as <code>nc</code> ("netcat"), a standard utility program for manipulating network connections:</p>
<div class="codehilite"><pre><span class="gp">$</span> go build gopl.io/ch8/clock1
<span class="gp">$</span> ./clock1 <span class="p">&amp;</span>
<span class="gp">$</span> nc localhost 8000
<span class="go">13:58:54</span>
<span class="go">13:58:55</span>
<span class="go">13:58:56</span>
<span class="go">13:58:57</span>
<span class="go">^C</span>
</pre></div>


<p>The client displays the time sent by the server each second until we interrupt the client with Control-C, which on Unix systems is echoed as <code>^C</code> by the shell. We can also use <code>telnet</code>, or the following simple Go version of <code>netcat</code> that uses <code>net.Dial</code> to connect to a TCP server:</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/netcat2/netcat.go">gopl.io/ch8/netcat1/netcat.go</a></small></p>
<div class="codehilite"><pre><span class="c1">// Netcat1 is a read-only TCP client.</span>
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;io&quot;</span>
    <span class="s">&quot;log&quot;</span>
    <span class="s">&quot;net&quot;</span>
    <span class="s">&quot;os&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Dial</span><span class="p">(</span><span class="s">&quot;tcp&quot;</span><span class="p">,</span> <span class="s">&quot;localhost:8000&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
    <span class="nx">mustCopy</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="nx">conn</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">mustCopy</span><span class="p">(</span><span class="nx">dst</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">src</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Copy</span><span class="p">(</span><span class="nx">dst</span><span class="p">,</span> <span class="nx">src</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>This program reads data from the connection and writes it to the standard output until an end-of-file condition or an error occurs. The <code>mustCopy</code> function is a utility used in several examples in this section.</p>
<p>We run two clients at the same time on different terminals, one shown to the left and one to the right:</p>
<div class="codehilite"><pre>$ go build gopl.io/ch8/netcat1
$ ./netcat1
13:58:54                        $ ./netcat1
13:58:55
13:58:56
^C
                                13:58:57
                                13:58:58
                                13:58:59
                                ^C
$ killall clock1
</pre></div>


<p>The second client must wait until the first client is finished because the server is sequential; it deals with only one client at a time.  Only one small change is needed to make the server concurrent: adding the <code>go</code> keyword to the call to <code>handleConn</code> causes each call to run in its own goroutine.</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/clock2/clock.go">gopl.io/ch8/clock2/clock.go</a></small></p>
<div class="codehilite"><pre><span class="k">for</span> <span class="p">{</span>
    <span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">listener</span><span class="p">.</span><span class="nx">Accept</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="c1">// e.g., connection aborted</span>
        <span class="k">continue</span>
    <span class="p">}</span>
    <span class="k">go</span> <span class="nx">handleConn</span><span class="p">(</span><span class="nx">conn</span><span class="p">)</span> <span class="c1">// handle connections concurrently</span>
<span class="p">}</span>
</pre></div>


<p>Now, multiple clients can receive the time at once.</p>
<div class="codehilite"><pre>$ go build gopl.io/ch8/clock2
$ ./clock2 &amp;
$ go build gopl.io/ch8/netcat1
$ ./netcat1
14:02:54                     $ ./netcat1
14:02:55                     14:02:55
14:02:56                     14:02:56
14:02:57                     ^C
14:02:58
14:02:59                     $ ./netcat1
14:03:00                     14:03:00
14:03:01                     14:03:01
^C                           14:03:02
                             ^C
</pre></div>


<h3 id="example-concurrent-echo-server">Example: Concurrent Echo Server<a class="headerlink" href="#example-concurrent-echo-server" title="Permanent link">&para;</a></h3>
<p>The clock server used one goroutine per connection. In this section, we'll build an echo server that uses multiple goroutines per connection. Most echo servers merely write whatever they read, which can be done with this trivial version of <code>handleConn</code>:</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">handleConn</span><span class="p">(</span><span class="nx">c</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">io</span><span class="p">.</span><span class="nx">Copy</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="c1">// NOTE: ignoring errors</span>
    <span class="nx">c</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>


<p>This version of echo server simulates the reverberations of a real echo, with the response loud at first ("HELLO!"), then moderate ("Hello!") after a delay, then quiet ("hello!") before fading to nothing:</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/reverb1/reverb.go">gopl.io/ch8/reverb1/reverb.go</a></small></p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">echo</span><span class="p">(</span><span class="nx">c</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span> <span class="nx">shout</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">delay</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintln</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="s">&quot;\t&quot;</span><span class="p">,</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">ToUpper</span><span class="p">(</span><span class="nx">shout</span><span class="p">))</span>
    <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">delay</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintln</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="s">&quot;\t&quot;</span><span class="p">,</span> <span class="nx">shout</span><span class="p">)</span>
    <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">delay</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintln</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="s">&quot;\t&quot;</span><span class="p">,</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">ToLower</span><span class="p">(</span><span class="nx">shout</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">handleConn</span><span class="p">(</span><span class="nx">c</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">input</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nx">NewScanner</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">input</span><span class="p">.</span><span class="nx">Scan</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">echo</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">input</span><span class="p">.</span><span class="nx">Text</span><span class="p">(),</span> <span class="mi">1</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// NOTE: ignoring potential errors from input.Err()</span>
    <span class="nx">c</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>


<p>The following client program sends terminal input to the server while also copying the server response to the output:</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/netcat2/netcat.go">gopl.io/ch8/netcat2/netcat.go</a></small></p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Dial</span><span class="p">(</span><span class="s">&quot;tcp&quot;</span><span class="p">,</span> <span class="s">&quot;localhost:8000&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
    <span class="k">go</span> <span class="nx">mustCopy</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="nx">conn</span><span class="p">)</span>
    <span class="nx">mustCopy</span><span class="p">(</span><span class="nx">conn</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>While the main goroutine reads the standard input and sends it to the server, a second goroutine reads and prints the server's response. When the main goroutine encounters the end of the input (for example, after the user types Control-D (<code>^D</code>)) at the terminal, the program stops, even if the other goroutine still has work to do. (<a href="#unbuffered-channels">Section 8.4.1</a> discusses how to make the program wait for both sides to finish)</p>
<div class="codehilite"><pre>$ go build gopl.io/ch8/reverb1
$ ./reverb1 &amp;
$ go build gopl.io/ch8/netcat2
$ ./netcat2
Hello?
    HELLO?
    Hello?
    hello?
Is there anybody there?
    IS THERE ANYBODY THERE?
Yooo-hooo!
    Is there anybody there?
    is there anybody there?
    YOOO-HOOO!
    Yooo-hooo!
    yooo-hooo!
^D
$ killall reverb1
</pre></div>


<p>Notice that the third shout from the client is not dealt with until the second shout has petered out, which is not very realistic. A real echo would consist of the <em>composition</em> of the three independent shouts. To simulate it, more goroutines are needed; all we need to do is add the <code>go</code> keyword, this time to the call to <code>echo</code>:</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/reverb2/reverb.go">gopl.io/ch8/reverb2/reverb.go</a></small></p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">handleConn</span><span class="p">(</span><span class="nx">c</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">input</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nx">NewScanner</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">input</span><span class="p">.</span><span class="nx">Scan</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">go</span> <span class="nx">echo</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">input</span><span class="p">.</span><span class="nx">Text</span><span class="p">(),</span> <span class="mi">1</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// NOTE: ignoring potential errors from input.Err()</span>
    <span class="nx">c</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>


<p>The arguments to the function started by <code>go</code> are evaluated when the <code>go</code> statement itself is executed; thus <code>input.Text()</code> is evaluated in the main goroutine.</p>
<p>Now the echoes are concurrent and overlap in time:</p>
<div class="codehilite"><pre>$ go build gopl.io/ch8/reverb2
$ ./reverb2 &amp;
$ ./netcat2
Is there anybody there?
    IS THERE ANYBODY THERE?
Yooo-hooo!
    Is there anybody there?
    YOOO-HOOO!
    is there anybody there?
    Yooo-hooo!
    yooo-hooo!
^D
$ killall reverb2
</pre></div>


<p><u>All that was required to make the server use concurrency, not just to handle connections from multiple clients but even within a single connection, was the insertion of two <code>go</code> keywords.</u></p>
<p>However in adding these keywords, we had to consider carefully that it is safe to call methods of <code>net.Conn</code> concurrently, which is not true for most types. The next chapter discusses the crucial concept of concurrency safety in the.</p>
<h3 id="channels">Channels<a class="headerlink" href="#channels" title="Permanent link">&para;</a></h3>
<p>If goroutines are the activities of a concurrent Go program, channels are the connections between them.</p>
<ul>
<li>A channel is a communication mechanism that enables one goroutine to send values to another goroutine.</li>
<li>Each channel is a conduit for values of a particular type, called the channel's <em>element type</em>. The type of a channel whose elements have type int is written <code>chan int</code>.</li>
</ul>
<p>To create a channel, use the built-in <code>make</code> function:</p>
<div class="codehilite"><pre><span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="c1">// ch has type &#39;chan int&#39;</span>
</pre></div>


<p>A channel is a reference to the data structure created by <code>make</code>.</p>
<ul>
<li>When we copy a channel or pass one as an argument to a function, we are copying a reference, so caller and callee refer to the same data structure.</li>
<li>As with other reference types, the zero value of a channel is <code>nil</code>.</li>
<li>Two channels of the same type may be compared using <code>==</code>. The comparison is <code>true</code> if both are references to the same channel data structure. A channel may also be compared to <code>nil</code>.</li>
</ul>
<p>A channel has two principal operations, <em>send</em> and <em>receive</em>, collectively known as <em>communications</em>. A send statement transmits a value from one goroutine, through the channel, to another goroutine executing a corresponding receive expression.</p>
<p>Both operations are written using the <code>&lt;-</code> operator.</p>
<ul>
<li>In a send statement, the <code>&lt;-</code> separates the channel and value operands.</li>
<li>In a receive expression, <code>&lt;-</code> precedes the channel operand. A receive expression whose result is not used is a valid statement.</li>
</ul>
<div class="codehilite"><pre><span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">x</span> <span class="c1">// a send statement</span>

<span class="nx">x</span><span class="p">=</span><span class="o">&lt;-</span><span class="nx">ch</span>  <span class="c1">// a receive expression in an assignment statement</span>
<span class="o">&lt;-</span><span class="nx">ch</span>    <span class="c1">// a receive statement; result is discarded</span>
</pre></div>


<p>Channels support a third operation, <em>close</em>, which sets a flag indicating that no more values will ever be sent on this channel.</p>
<ul>
<li>Send operations on a closed channel will panic.</li>
<li>Receive operations on a closed channel yield the values that have been sent until no more values are left; any receive operations thereafter complete immediately and yield the zero value of the channel's element type.</li>
</ul>
<p>To close a channel, call the built-in <code>close</code> function:</p>
<div class="codehilite"><pre><span class="nb">close</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
</pre></div>


<p>A channel created with a simple call to <code>make</code> is called an <em>unbuffered</em> channel. <code>make</code> accepts an optional second argument, an integer called the channel's <em>capacity</em>. If the capacity is nonzero, <code>make</code> creates a <code>buffered</code> channel.</p>
<div class="codehilite"><pre><span class="nx">ch</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>    <span class="c1">// unbuffered channel</span>
<span class="nx">ch</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// unbuffered channel</span>
<span class="nx">ch</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">// buffered channel with capacity 3</span>
</pre></div>


<p>Unbuffered channels are discussed in <a href="#unbuffered-channels">Section 8.4.1</a> and buffered channels in <a href="#buffered-channels">Section 8.4.4</a>.</p>
<h4 id="unbuffered-channels">Unbuffered Channels<a class="headerlink" href="#unbuffered-channels" title="Permanent link">&para;</a></h4>
<ul>
<li>A send operation on an unbuffered channel blocks the sending goroutine until another goroutine executes a corresponding receive on the same channel, at which point the value is transmitted and both goroutines may continue.</li>
<li>Conversely, if the receive operation was attempted first, the receiving goroutine is blocked until another goroutine performs a send on the same channel.</li>
</ul>
<p>Communication over an unbuffered channel causes the sending and receiving goroutines to <em>synchronize</em>. Because of this, unbuffered channels are sometimes called <em>synchronous</em> channels. When a value is sent on an unbuffered channel, the receipt of the value happens <em>before</em> the reawakening of the sending goroutine.</p>
<p>In discussions of concurrency:</p>
<ul>
<li>When we say <em>x happens before y</em>, we don't mean merely that <em>x</em> occurs earlier in time than <em>y</em>. We mean that it is guaranteed to do so and that all its prior effects (e.g. updates to variables) are complete and that you may rely on them.</li>
<li>When we say <em>x is concurrent with y</em>, we mean <em>x</em> neither happens before <em>y</em> nor after <em>y</em>.<ul>
<li>This doesn't mean that <em>x</em> and <em>y</em> are necessarily simultaneous; it merely means that we cannot assume anything about their ordering.</li>
<li>As discussed in the next chapter, it's necessary to order certain events during the program's execution to avoid the problems that arise when two goroutines access the same variable concurrently.</li>
</ul>
</li>
</ul>
<p>The client program in <a href="#example-concurrent-echo-server">Section 8.3</a> copies input to the server in its main goroutine, so the client program terminates as soon as the input stream closes, even if the background goroutine is still working. To make the program wait for the background goroutine to complete before exiting, we use a channel to synchronize the two goroutines:</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/netcat3/netcat.go">gopl.io/ch8/netcat3/netcat.go</a></small></p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Dial</span><span class="p">(</span><span class="s">&quot;tcp&quot;</span><span class="p">,</span> <span class="s">&quot;localhost:8000&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">done</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">io</span><span class="p">.</span><span class="nx">Copy</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="nx">conn</span><span class="p">)</span> <span class="c1">// NOTE: ignoring errors</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;done&quot;</span><span class="p">)</span>
        <span class="nx">done</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span> <span class="c1">// signal the main goroutine</span>
    <span class="p">}()</span>
    <span class="nx">mustCopy</span><span class="p">(</span><span class="nx">conn</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">)</span>
    <span class="nx">conn</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
    <span class="o">&lt;-</span><span class="nx">done</span> <span class="c1">// wait for background goroutine to finish</span>
<span class="p">}</span>
</pre></div>


<p>When the user closes the standard input stream, <code>mustCopy</code> returns and the main goroutine calls <code>conn.Close()</code>, closing both halves of the network connection:</p>
<ul>
<li>Closing the write half of the connection causes the server to see an end-of-file condition.</li>
<li>Closing the read half causes the background goroutine's call to <code>io.Copy</code> to return a "read from closed connection" error, which is why we've removed the error logging. Notice that the go statement calls a literal function, a common construction.</li>
</ul>
<p>Before it returns, the background goroutine logs a message, then sends a value on the done channel. The main goroutine waits until it has received this value before returning. As a result, the program always logs the "<code>done</code>" message before exiting.</p>
<p>Messages sent over channels have two important aspects. Each message has a value, but sometimes the fact of communication and the moment at which it occurs are important. We call messages <em>events</em> when we wish to stress this aspect. When the event carries no additional information, that is, its sole purpose is synchronization, we'll emphasize this by using a channel whose element type is <code>struct{}</code>, though it's common to use a channel of <code>bool</code> or <code>int</code> for the same purpose since <code>done &lt;- 1</code> is shorter than <code>done &lt;- struct{}{}</code>.</p>
<h4 id="pipelines">Pipelines<a class="headerlink" href="#pipelines" title="Permanent link">&para;</a></h4>
<p>Channels can be used to connect goroutines together so that the output of one is the input to another. This is called a <em>pipeline</em>. The program below consists of three goroutines connected by two channels, as shown the following figure.</p>
<p><a href="../figure_8.1.png" title="Figure 8.1. A three-stage pipeline."><img alt="Figure 8.1. A three-stage pipeline." src="../figure_8.1_600.png" /></a></p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/pipeline1/main.go">gopl.io/ch8/pipeline1/main.go</a></small></p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">naturals</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
    <span class="nx">squares</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>

    <span class="c1">// Counter</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">x</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">;</span> <span class="nx">x</span><span class="o">++</span> <span class="p">{</span>
            <span class="nx">naturals</span> <span class="o">&lt;-</span> <span class="nx">x</span>
        <span class="p">}</span>
    <span class="p">}()</span>

    <span class="c1">// Squarer</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">{</span>
            <span class="nx">x</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">naturals</span>
            <span class="nx">squares</span> <span class="o">&lt;-</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span>
        <span class="p">}</span>
    <span class="p">}()</span>

    <span class="c1">// Printer (in main goroutine)</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="nx">squares</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>The first goroutine, <code>counter</code>, generates the integers 0, 1, 2, ..., and sends them over a channel to the second goroutine, <code>squarer</code>, which receives each value, squares it, and sends the result over another channel to the third goroutine, <code>printer</code>, which receives the squared values and prints them.</p>
<p>This program prints the infinite series of squares 0, 1, 4, 9, and so on. Pipelines like this may be found in long-running server programs where channels are used for lifelong communication between goroutines containing infinite loops.  If the sender knows that no further values will ever be sent on a channel, it is useful to communicate this fact to the receiver goroutines so that they can stop waiting. This is accomplished by closing the channel using the built-in <code>close</code> function:</p>
<div class="codehilite"><pre><span class="nb">close</span><span class="p">(</span><span class="nx">naturals</span><span class="p">)</span>
</pre></div>


<p>After a channel has been closed, any further send operations on it will panic. After the closed channel has been <em>drained</em> (that is, after the last sent element has been received), all subsequent receive operations will proceed without blocking but will yield a zero value. Closing the <code>naturals</code> channel above would cause the <code>squarer</code>'s loop to spin as it receives a never-ending stream of zero values, and to send these zeros to the <code>printer</code>.</p>
<p>There is no way to test directly whether a channel has been closed, but there is a variant of the receive operation that produces two results: the received channel element, plus a boolean value, conventionally called <code>ok</code>, which is <code>true</code> for a successful receive and <code>false</code> for a receive on a closed and drained channel. Using this feature, we can modify the <code>squarer</code>'s loop to stop when the <code>naturals</code> channel is drained and close the <code>squares</code> channel in turn.</p>
<div class="codehilite"><pre><span class="c1">// Squarer</span>
<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="nx">x</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">naturals</span>
        <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
            <span class="k">break</span> <span class="c1">// channel was closed and drained</span>
        <span class="p">}</span>
        <span class="nx">squares</span> <span class="o">&lt;-</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span>
    <span class="p">}</span>
    <span class="nb">close</span><span class="p">(</span><span class="nx">squares</span><span class="p">)</span>
<span class="p">}()</span>
</pre></div>


<p>Since this pattern is common, the language enables us to use a <code>range</code> loop to iterate over channels. This is a more convenient syntax for receiving all the values sent on a channel and terminating the loop after the last one. In the pipeline below, when the <code>counter</code> goroutine finishes its loop after 100 elements, it closes the <code>naturals</code> channel, causing the <code>squarer</code> to finish its loop and close the <code>squares</code> channel. Finally, the main goroutine finishes its loop and the program exits. In a more complex program, it might make sense for the <code>counter</code> and <code>squarer</code> functions to defer the calls to <code>close</code> at the outset.</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/pipeline2/main.go">gopl.io/ch8/pipeline2/main.go</a></small></p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">naturals</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
    <span class="nx">squares</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>

    <span class="c1">// Counter</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">x</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="p">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="nx">x</span><span class="o">++</span> <span class="p">{</span>
            <span class="nx">naturals</span> <span class="o">&lt;-</span> <span class="nx">x</span>
        <span class="p">}</span>
        <span class="nb">close</span><span class="p">(</span><span class="nx">naturals</span><span class="p">)</span>
    <span class="p">}()</span>

    <span class="c1">// Squarer</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">x</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">naturals</span> <span class="p">{</span>
            <span class="nx">squares</span> <span class="o">&lt;-</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span>
        <span class="p">}</span>
        <span class="nb">close</span><span class="p">(</span><span class="nx">squares</span><span class="p">)</span>
    <span class="p">}()</span>

    <span class="c1">// Printer (in main goroutine)</span>
    <span class="k">for</span> <span class="nx">x</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">squares</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>Not every channel needs closing. It's only necessary to close a channel when it is important to tell the receiving goroutines that all data have been sent. A channel that the garbage collector determines to be unreachable will have its resources reclaimed whether or not it is closed. (Don't confuse this with the <code>close</code> operation for open files. It is important to call the <code>Close</code> method on every file when you've finished with it.) Attempting to close an already-closed channel causes a panic, as does closing a <code>nil</code> channel. Closing channels has another use as a broadcast mechanism (<a href="#cancellation">Section 8.9</a>).</p>
<h4 id="unidirectional-channel-types">Unidirectional Channel Types<a class="headerlink" href="#unidirectional-channel-types" title="Permanent link">&para;</a></h4>
<p>As programs grow, it is natural to break up large functions into smaller pieces. The previous example program naturally divides into three functions:</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">counter</span><span class="p">(</span><span class="nx">out</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
<span class="kd">func</span> <span class="nx">squarer</span><span class="p">(</span><span class="nx">out</span><span class="p">,</span> <span class="nx">in</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
<span class="kd">func</span> <span class="nx">printer</span><span class="p">(</span><span class="nx">in</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
</pre></div>


<p>The <code>squarer</code> function takes two parameters, the input channel and the output channel: <code>in</code> is only to be received from, and <code>out</code> is only to be sent to. The names <code>in</code> and <code>out</code> convey this intention, but nothing prevents squarer from sending to in or receiving from out.</p>
<p>This arrangement is typical. When a channel is supplied as a function parameter, it is nearly always with the intent that it be used exclusively for sending or exclusively for receiving.</p>
<p>To document this intent and prevent misuse, the Go type system provides <em>unidirectional</em> channel types that expose only one of the send and receive operations:</p>
<ul>
<li>The type <code>chan&lt;- int</code>, a send-only channel of <code>int</code>, allows sends but not receives.</li>
<li>The type <code>&lt;-chan int</code>, a receive-only channel of <code>int</code>, allows receives but not sends.</li>
</ul>
<p>Violations of this discipline are detected at compile time.</p>
<p>Since the <code>close</code> operation asserts that no more sends will occur on a channel, only the sending goroutine is in a position to call it, and for this reason it is a compile-time error to attempt to close a receive-only channel.</p>
<p>The following program is the squaring pipeline with unidirectional channel types:</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/pipeline3/main.go">gopl.io/ch8/pipeline3/main.go</a></small></p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">counter</span><span class="p">(</span><span class="nx">out</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">x</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="p">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="nx">x</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">out</span> <span class="o">&lt;-</span> <span class="nx">x</span>
    <span class="p">}</span>
    <span class="nb">close</span><span class="p">(</span><span class="nx">out</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">squarer</span><span class="p">(</span><span class="nx">out</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">in</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">in</span> <span class="p">{</span>
        <span class="nx">out</span> <span class="o">&lt;-</span> <span class="nx">v</span> <span class="o">*</span> <span class="nx">v</span>
    <span class="p">}</span>
    <span class="nb">close</span><span class="p">(</span><span class="nx">out</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">printer</span><span class="p">(</span><span class="nx">in</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">in</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">naturals</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
    <span class="nx">squares</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>

    <span class="k">go</span> <span class="nx">counter</span><span class="p">(</span><span class="nx">naturals</span><span class="p">)</span>
    <span class="k">go</span> <span class="nx">squarer</span><span class="p">(</span><span class="nx">squares</span><span class="p">,</span> <span class="nx">naturals</span><span class="p">)</span>
    <span class="nx">printer</span><span class="p">(</span><span class="nx">squares</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<ul>
<li>The call <code>counter(naturals)</code> implicitly converts naturals, a value of type <code>chan int</code>, to the type of the parameter, <code>chan&lt;- int</code>.</li>
<li>The <code>printer(squares)</code> call does a similar implicit conversion to <code>&lt;-chan int</code>.</li>
</ul>
<p>Conversions from bidirectional to unidirectional channel types are permitted in any assignment, but not backward. Once you have a value of a unidirectional type such as <code>chan&lt;- int</code>, there is no way to obtain from it a value of type <code>chan int</code> that refers to the same channel data structure.</p>
<h4 id="buffered-channels">Buffered Channels<a class="headerlink" href="#buffered-channels" title="Permanent link">&para;</a></h4>
<p>A buffered channel has a queue of elements. The queue's maximum size is determined  by the capacity argument to <code>make</code> when it is created. The statement below creates a buffered channel capable of holding three string values.</p>
<div class="codehilite"><pre><span class="nx">ch</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>


<p>The following figure a graphical representation of <code>ch</code> and the channel to which it refers.</p>
<p><a href="../figure_8.2.png" title="Figure 8.2. An empty buffered channel."><img alt="Figure 8.2. An empty buffered channel." src="../figure_8.2.png" /></a></p>
<p>A send operation on a buffered channel inserts an element at the back of the queue, and a receive operation removes an element from the front.</p>
<ul>
<li>If the channel is full, the send operation blocks its goroutine until space is made available by another goroutine's receive.</li>
<li>If the channel is empty, a receive operation blocks until a value is sent by another goroutine.</li>
</ul>
<p>We can send up to three values on this channel without the goroutine blocking:</p>
<div class="codehilite"><pre><span class="nx">ch</span> <span class="o">&lt;-</span> <span class="s">&quot;A&quot;</span>
<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="s">&quot;B&quot;</span>
<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="s">&quot;C&quot;</span>
</pre></div>


<p>At this point, the channel is full, as shown below; a fourth send statement would block.</p>
<p><a href="../figure_8.3.png" title="Figure 8.3. A full buffered channel."><img alt="Figure 8.3. A full buffered channel." src="../figure_8.3.png" /></a></p>
<p>If we receive one value like this:</p>
<div class="codehilite"><pre><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="nx">ch</span><span class="p">)</span> <span class="c1">// &quot;A&quot;</span>
</pre></div>


<p>The channel is neither full nor empty (as shown in the figure below), so either a send operation or a receive operation could proceed without blocking. In this way, <u>the channel's buffer decouples the sending and receiving goroutines.</u></p>
<p><a href="../figure_8.4.png" title="Figure 8.4. A partially full buffered channel."><img alt="Figure 8.4. A partially full buffered channel." src="../figure_8.4.png" /></a></p>
<p>The built-in <code>cap</code> function obtains the channel's buffer capacity:</p>
<div class="codehilite"><pre><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="nx">ch</span><span class="p">))</span> <span class="c1">// &quot;3&quot;</span>
</pre></div>


<p>The built-in <code>len</code> function returns the number of elements currently buffered</p>
<div class="codehilite"><pre><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">ch</span><span class="p">))</span> <span class="c1">// &quot;2&quot;</span>
</pre></div>


<p>Since in a concurrent program this information is likely to be stale as soon as it is retrieved, its value is limited, but it could conceivably be useful during fault diagnosis or performance optimization.</p>
<p>After two more receive operations the channel is empty again, and a fourth would block:</p>
<div class="codehilite"><pre><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="nx">ch</span><span class="p">)</span> <span class="c1">// &quot;B&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="nx">ch</span><span class="p">)</span> <span class="c1">// &quot;C&quot;</span>
</pre></div>


<p>In real programs, the send and receive operations are usually performed by different goroutines. It is a mistake to use buffered channels within a single goroutine as a queue. Channels are deeply connected to goroutine scheduling, and without another goroutine receiving from the channel, a sender (and perhaps the whole program) risks becoming blocked forever.</p>
<p>The example below shows an application of a buffered channel. It makes parallel requests to three mirror sites. It sends their responses over a buffered channel, then receives and returns only the first response, which is the quickest one to arrive. Thus <code>mirroredQuery</code> returns a result even before the two slower servers have responded. (It's quite normal for several goroutines to send values to the same channel concurrently, as in this example, or to receive from the same channel.)</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">mirroredQuery</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="nx">responses</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">responses</span> <span class="o">&lt;-</span> <span class="nx">request</span><span class="p">(</span><span class="s">&quot;asia.gopl.io&quot;</span><span class="p">)</span> <span class="p">}()</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">responses</span> <span class="o">&lt;-</span> <span class="nx">request</span><span class="p">(</span><span class="s">&quot;europe.gopl.io&quot;</span><span class="p">)</span> <span class="p">}()</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">responses</span> <span class="o">&lt;-</span> <span class="nx">request</span><span class="p">(</span><span class="s">&quot;americas.gopl.io&quot;</span><span class="p">)</span> <span class="p">}()</span>
    <span class="k">return</span> <span class="o">&lt;-</span><span class="nx">responses</span> <span class="c1">// return the quickest response</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">request</span><span class="p">(</span><span class="nx">hostname</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">response</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</pre></div>


<p>If we had used an unbuffered channel in the above example, the two slower goroutines would have gotten stuck trying to send their responses on a channel from which no goroutine will ever receive. This situation, called a <em>goroutine leak</em>, would be a bug. <u>Unlike garbage variables, leaked goroutines are not automatically collected, so it is important to make sure that goroutines terminate themselves when no longer needed.</u></p>
<p>The choice between unbuffered and buffered channels, and the choice of a buffered channel's capacity, may both affect the correctness of a program.</p>
<ul>
<li>Unbuffered channels give stronger synchronization guarantees because every send operation is synchronized with its corresponding receive</li>
<li>With buffered channels, the send and receive operations are decoupled.</li>
</ul>
<p>When we know an upper bound on the number of values that will be sent on a channel, it's not unusual to create a buffered channel of that size and perform all the sends before the first value is received. Failure to allocate sufficient buffer capacity would cause the program to deadlock.</p>
<h5 id="packaging-cake-example"><strong>Packaging cake example</strong> *<a class="headerlink" href="#packaging-cake-example" title="Permanent link">&para;</a></h5>
<p>Channel buffering may also affect program performance. Imagine three cooks in a cake shop, one baking, one icing, and one inscribing each cake before passing it on to the next cook in the assembly line:</p>
<ul>
<li>In a kitchen with little space, each cook that has finished a cake must wait for the next cook to become ready to accept it. This is analogous to communication over an unbuffered channel.</li>
<li>If there is space for one cake between each cook, a cook may place a finished cake there and immediately start work on the next. This is analogous to a buffered channel with capacity 1.<ul>
<li>As long as the cooks work at about the same rate on average, most of these handovers proceed quickly, smoothing out transient differences in their respective rates.</li>
<li>More space between cooks (larger buffers) can smooth out bigger transient variations in their rates without stalling the assembly line, such as happens when one cook takes a short break, then later rushes to catch up.</li>
</ul>
</li>
</ul>
<p>On the other hand, a buffer provides no benefit in either of the following case:</p>
<ul>
<li>When an earlier stage of the assembly line is consistently faster than the following stage, the buffer between them will spend most of its time full.</li>
<li>When a later stage is faster, the buffer will usually be empty.</li>
</ul>
<p>If the second stage is more elaborate, a single cook may not be able to keep up with the supply from the first cook or meet the demand from the third. To solve the problem, we could hire another cook to help the second, performing the same task but working independently. This is analogous to creating another goroutine communicating over the same channels.</p>
<p>The <a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/cake/cake.go">gopl.io/ch8/cake</a> package simulates this cake shop, with several parameters.</p>
<h3 id="looping-in-parallel">Looping in Parallel<a class="headerlink" href="#looping-in-parallel" title="Permanent link">&para;</a></h3>
<p>This section explores some common concurrency patterns for executing all the iterations of a loop in parallel. The following examples consider the problem of producing thumbnail-size images from a set of full-size ones. The <a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/thumbnail/thumbnail.go">gopl.io/ch8/thumbnail</a> package provides an <code>ImageFile</code> function that can scale a single image.</p>
<p>The program below loops over a list of image file names and produces a thumbnail for each one:</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/thumbnail/thumbnail_test.go">gopl.io/ch8/thumbnail/thumbnail_test.go</a></small></p>
<div class="codehilite"><pre><span class="c1">// makeThumbnails makes thumbnails of the specified files.</span>
<span class="kd">func</span> <span class="nx">makeThumbnails</span><span class="p">(</span><span class="nx">filenames</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">filenames</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">thumbnail</span><span class="p">.</span><span class="nx">ImageFile</span><span class="p">(</span><span class="nx">f</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">log</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>The order in which we process the files doesn't matter, since each scaling operation is independent of all the others. Problems like this that consist entirely of subproblems that are completely independent of each other are described as <a href="https://en.wikipedia.org/wiki/Embarrassingly_parallel"><em>embarrassingly parallel</em></a>. Embarrassingly parallel problems are the easiest kind to implement concurrently and enjoy performance that scales linearly with the amount of parallelism.</p>
<p>The following first attempt at a concurrent version just adds a <code>go</code> keyword. Let's ignore errors for now and address them later.</p>
<div class="codehilite"><pre><span class="c1">// NOTE: incorrect!</span>
<span class="kd">func</span> <span class="nx">makeThumbnails2</span><span class="p">(</span><span class="nx">filenames</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">filenames</span> <span class="p">{</span>
        <span class="k">go</span> <span class="nx">thumbnail</span><span class="p">.</span><span class="nx">ImageFile</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="c1">// NOTE: ignoring errors</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>This version runs too fast, since it takes less time than the original, even when the slice of file names contains only a single element. This is because <code>makeThumbnails</code> returns before it has finished doing what it was supposed to do. It starts all the goroutines, one per file name, but doesn't wait for them to finish.</p>
<p>There is no direct way to wait until a goroutine has finished, but we can change the inner goroutine to report its completion to the outer goroutine by sending an event on a shared channel. Since we know that there are exactly <code>len(filenames)</code> inner goroutines, the outer goroutine need only count that many events before it returns:</p>
<div class="codehilite"><pre><span class="c1">// makeThumbnails3 makes thumbnails of the specified files in parallel.</span>
<span class="kd">func</span> <span class="nx">makeThumbnails3</span><span class="p">(</span><span class="nx">filenames</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">filenames</span> <span class="p">{</span>
        <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">f</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">thumbnail</span><span class="p">.</span><span class="nx">ImageFile</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="c1">// NOTE: ignoring errors</span>
            <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>
        <span class="p">}(</span><span class="nx">f</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// Wait for goroutines to complete.</span>
    <span class="k">for</span> <span class="k">range</span> <span class="nx">filenames</span> <span class="p">{</span>
        <span class="o">&lt;-</span><span class="nx">ch</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>Notice that we passed the value of <code>f</code> as an explicit argument to the literal function instead of using the declaration of <code>f</code> from the enclosing for loop (as shown below):</p>
<div class="codehilite"><pre><span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">filenames</span> <span class="p">{</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">thumbnail</span><span class="p">.</span><span class="nx">ImageFile</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="c1">// NOTE: incorrect!</span>
        <span class="c1">// ...</span>
    <span class="p">}()</span>
<span class="p">}</span>
</pre></div>


<p>Recall the problem of loop variable capture inside an anonymous function, described in <a href="../ch5/#caveat-capturing-iteration-variables">Section 5.6.1</a>. In the above code, the single variable <code>f</code> is shared by all the anonymous function values and updated by successive loop iterations. By the time the new goroutines start executing the literal function, the <code>for</code> loop may have updated <code>f</code> and started another iteration or finished entirely, so when these goroutines read the value of <code>f</code>, they all observe it to have the value of the final element of the slice. By adding an explicit parameter, we ensure that we use the value of <code>f</code> that is current when the go statement is executed.</p>
<p>In the next version of <code>makeThumbnails</code>, if an worker goroutine's call to <code>thumbnail.ImageFile</code> fails to create a file, it returns an error to the main goroutine. <code>makeThumbnails4</code> returns the first error it receives from any of the scaling operations:</p>
<div class="codehilite"><pre><span class="c1">// makeThumbnails4 makes thumbnails for the specified files in parallel.</span>
<span class="c1">// It returns an error if any step failed.</span>
<span class="kd">func</span> <span class="nx">makeThumbnails4</span><span class="p">(</span><span class="nx">filenames</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">errors</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">error</span><span class="p">)</span>

    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">filenames</span> <span class="p">{</span>
        <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">f</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">thumbnail</span><span class="p">.</span><span class="nx">ImageFile</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
            <span class="nx">errors</span> <span class="o">&lt;-</span> <span class="nx">err</span>
        <span class="p">}(</span><span class="nx">f</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="k">range</span> <span class="nx">filenames</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">errors</span><span class="p">;</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">err</span> <span class="c1">// NOTE: incorrect: goroutine leak!</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</pre></div>


<p>This function has a subtle bug. When it encounters the first non-nil error, it returns the error to the caller, leaving no goroutine draining the errors channel. Each remaining worker goroutine will block forever when it tries to send a value on that channel, and will never terminate. This results in a goroutine leak (<a href="#buffered-channels">Section 8.4.4</a>), which may cause the whole program to get stuck or to run out of memory.</p>
<p>The simplest solution is to use a buffered channel with sufficient capacity that no worker goroutine will block when it sends a message. An alternative solution is to create another goroutine to drain the channel while the main goroutine returns the first error without delay.</p>
<p>The next version of <code>makeThumbnails</code> uses a buffered channel to return the names of the generated image files along with any errors.</p>
<div class="codehilite"><pre><span class="c1">// makeThumbnails5 makes thumbnails for the specified files in parallel.</span>
<span class="c1">// It returns the generated file names in an arbitrary order,</span>
<span class="c1">// or an error if any step failed.</span>
<span class="kd">func</span> <span class="nx">makeThumbnails5</span><span class="p">(</span><span class="nx">filenames</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">thumbfiles</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">type</span> <span class="nx">item</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">thumbfile</span> <span class="kt">string</span>
        <span class="nx">err</span>       <span class="kt">error</span>
    <span class="p">}</span>

    <span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">item</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">filenames</span><span class="p">))</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">filenames</span> <span class="p">{</span>
        <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">f</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">it</span> <span class="nx">item</span>
            <span class="nx">it</span><span class="p">.</span><span class="nx">thumbfile</span><span class="p">,</span> <span class="nx">it</span><span class="p">.</span><span class="nx">err</span> <span class="p">=</span> <span class="nx">thumbnail</span><span class="p">.</span><span class="nx">ImageFile</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
            <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">it</span>
        <span class="p">}(</span><span class="nx">f</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="k">range</span> <span class="nx">filenames</span> <span class="p">{</span>
        <span class="nx">it</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span>
        <span class="k">if</span> <span class="nx">it</span><span class="p">.</span><span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">it</span><span class="p">.</span><span class="nx">err</span>
        <span class="p">}</span>
        <span class="nx">thumbfiles</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">thumbfiles</span><span class="p">,</span> <span class="nx">it</span><span class="p">.</span><span class="nx">thumbfile</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">thumbfiles</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</pre></div>


<p>The final version of <code>makeThumbnails</code> is shown below. It returns the total number of bytes occupied by the new files. Unlike the previous versions, however, it receives the file names not as a slice but over a channel of strings, so we cannot predict the number of loop iterations.</p>
<p>To know when the last goroutine has finished (which may not be the last one to start), we need to increment a counter before each goroutine starts and decrement it as each goroutine finishes. This demands a special kind of counter that can be safely manipulated from multiple goroutines and that provides a way to wait until it becomes zero. This counter type is known as <a href="https://golang.org/pkg/sync/#WaitGroup"><code>sync.WaitGroup</code></a> as shown in the code below:</p>
<div class="codehilite"><pre><span class="c1">// makeThumbnails6 makes thumbnails for each file received from the channel.</span>
<span class="c1">// It returns the number of bytes occupied by the files it creates.</span>
<span class="kd">func</span> <span class="nx">makeThumbnails6</span><span class="p">(</span><span class="nx">filenames</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int64</span> <span class="p">{</span>
    <span class="nx">sizes</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int64</span><span class="p">)</span>
    <span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span> <span class="c1">// number of working goroutines</span>
    <span class="k">for</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">filenames</span> <span class="p">{</span>
        <span class="nx">wg</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1">// worker</span>
        <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">f</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span>
            <span class="nx">thumb</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">thumbnail</span><span class="p">.</span><span class="nx">ImageFile</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
            <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="nx">log</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="p">}</span>
            <span class="nx">info</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stat</span><span class="p">(</span><span class="nx">thumb</span><span class="p">)</span> <span class="c1">// OK to ignore error</span>
            <span class="nx">sizes</span> <span class="o">&lt;-</span> <span class="nx">info</span><span class="p">.</span><span class="nx">Size</span><span class="p">()</span>
        <span class="p">}(</span><span class="nx">f</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// closer</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">wg</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span>
        <span class="nb">close</span><span class="p">(</span><span class="nx">sizes</span><span class="p">)</span>
    <span class="p">}()</span>

    <span class="kd">var</span> <span class="nx">total</span> <span class="kt">int64</span>
    <span class="k">for</span> <span class="nx">size</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">sizes</span> <span class="p">{</span>
        <span class="nx">total</span> <span class="o">+=</span> <span class="nx">size</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">total</span>
<span class="p">}</span>
</pre></div>


<p>The structure of the code above is a common and idiomatic pattern for looping in parallel when we don't know the number of iterations:</p>
<ul>
<li>Note the asymmetry in the <code>Add</code> and <code>Done</code> methods.<ul>
<li><code>Add</code> increments the counter and must be called before the worker goroutine starts, not within it; <u>otherwise we would not be sure that the <code>Add</code> happens before the "closer" goroutine calls <code>Wait</code>.</u></li>
<li><code>Add</code> takes a parameter, but <code>Done</code> does not; it's equivalent to <code>Add(-1)</code>. We use <code>defer</code> to ensure that the counter is decremented even in the error case.</li>
</ul>
</li>
<li>The <code>sizes</code> channel carries each file size back to the main goroutine, which receives them using a <code>range</code> loop and computes the sum.</li>
<li>Observe how we create a closer goroutine that waits for the workers to finish before closing the <code>sizes</code> channel. These two operations, <code>wait</code> and <code>close</code>, must be concurrent with the loop over <code>sizes</code>. Consider the alternatives:<ul>
<li>If the <code>wait</code> operation were placed in the main goroutine before the loop, it would never end.</li>
<li>If the <code>wait</code> operation were placed after the loop, it would be unreachable since with nothing closing the channel, the loop would never terminate.</li>
</ul>
</li>
</ul>
<p>The following figure illustrates the sequence of events in the <code>makeThumbnails6</code> function:</p>
<p><a href="../figure_8.5.png" title="Figure 8.5. The sequence of events in makeThumbnails6."><img alt="Figure 8.5. The sequence of events in makeThumbnails6." src="../figure_8.5_600.png" /></a></p>
<ul>
<li>The vertical lines represent goroutines.</li>
<li>The thin segments indicate sleep, the thick segments activity.</li>
<li>The diagonal arrows indicate events that synchronize one goroutine with another.</li>
</ul>
<p>Notice how the main goroutine spends most of its time in the <code>range</code> loop asleep, waiting for a worker to send a value or the closer to close the channel.</p>
<h3 id="example-concurrent-web-crawler">Example: Concurrent Web Crawler<a class="headerlink" href="#example-concurrent-web-crawler" title="Permanent link">&para;</a></h3>
<p><a href="../ch5/#anonymous-functions">Section 5.6</a> shows a simple web crawler that explored the link graph of the web in breadth-first order. In this section show is concurrent version so that independent calls to <code>crawl</code> can exploit the I/O parallelism available in the web. The <code>crawl</code> function remains exactly as it was in <a href="https://github.com/shichao-an/gopl.io/blob/master/ch5/findlinks3/findlinks.go">gopl.io/ch5/findlinks3</a>:</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/crawl1/findlinks.go">gopl.io/ch8/crawl1/findlinks.go</a></small></p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">crawl</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
    <span class="nx">list</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">links</span><span class="p">.</span><span class="nx">Extract</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">list</span>
<span class="p">}</span>
</pre></div>


<p>The main function resembles <code>breadthFirst</code> (<a href="../ch5/#anonymous-functions">Section 5.6</a>):</p>
<ul>
<li>As before, a <code>worklist</code> records the queue of items that need processing, each item being a list of URLs to crawl, but this time a channel is used instead of a slice.</li>
<li>Each call to <code>crawl</code> occurs in its own goroutine and sends the links it discovers back to the <code>worklist</code>.</li>
</ul>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">worklist</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span>

    <span class="c1">// Start with the command-line arguments.</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">worklist</span> <span class="o">&lt;-</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="p">}()</span>

    <span class="c1">// Crawl the web concurrently.</span>
    <span class="nx">seen</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">list</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">worklist</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">link</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">list</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">!</span><span class="nx">seen</span><span class="p">[</span><span class="nx">link</span><span class="p">]</span> <span class="p">{</span>
                <span class="nx">seen</span><span class="p">[</span><span class="nx">link</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
                <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">link</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nx">worklist</span> <span class="o">&lt;-</span> <span class="nx">crawl</span><span class="p">(</span><span class="nx">link</span><span class="p">)</span>
                <span class="p">}(</span><span class="nx">link</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>Notice that the <code>crawl</code> goroutine takes link as an explicit parameter to avoid the problem of loop variable capture  in <a href="../ch5/#caveat-capturing-iteration-variables">Section 5.6.1</a>. Also notice that the initial send of the command-line arguments to the <code>worklist</code> must run in its own goroutine to avoid deadlock, a stuck situation in which both the main goroutine and a crawler goroutine attempt to send to each other while neither is receiving. An alternative solution would be to use a buffered channel.</p>
<p>The crawler is now highly concurrent and prints a storm of URLs, but it has two problems.  The first problem manifests itself as error messages in the log after a few seconds of operation:</p>
<div class="codehilite"><pre>$ go build gopl.io/ch8/crawl1
$ ./crawl1 http://gopl.io/
http://gopl.io/
https://golang.org/help/
https://golang.org/doc/
https://golang.org/blog/
...
2015/07/15 18:22:12 Get ...: dial tcp: lookup blog.golang.org: no such host
2015/07/15 18:22:12 Get ...: dial tcp 23.21.222.120:443: socket:
too many open files
...
</pre></div>


<p>The program created so many network connections at once that it exceeded the per-process limit on the number of open files, causing operations such as DNS lookups and calls to <code>net.Dial</code> to start failing.</p>
<p>The program is too parallel. Unbounded parallelism is rarely a good idea since there is always a limiting factor in the system, such as:</p>
<ul>
<li>The number of CPU cores for compute-bound workloads</li>
<li>The number of spindles and heads for local disk I/O operations</li>
<li>The bandwidth of the network for streaming downloads or the serving capacity of a web service.</li>
</ul>
<p>The solution is to limit the number of parallel uses of the resource to match the level of parallelism that is available. A simple way to do that in our example is to ensure that no more than <em>n</em> calls to <code>links.Extract</code> are active at once, where <em>n</em> is comfortably less than the file descriptor limit.</p>
<p>We can limit parallelism using a buffered channel of capacity <em>n</em> to model a concurrency primitive called a <em>counting semaphore</em>. Conceptually, each of the <em>n</em> vacant slots in the channel buffer represents a token entitling the holder to proceed. Sending a value into the channel acquires a token, and receiving a value from the channel releases a token, creating a new vacant slot. This ensures that at most <em>n</em> sends can occur without an intervening receive.Since the channel element type is not important, we'll use <code>struct{}</code>, which has size zero.</p>
<p>In the following rewritten <code>crawl</code> function, the call to <code>links.Extract</code> is bracketed by operations to acquire and release a token, thus ensuring that at most 20 calls to it are active at one time. It's good practice to keep the semaphore operations as close as possible to the I/O operation they regulate.</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/crawl2/findlinks.go">gopl.io/ch8/crawl2/findlinks.go</a></small></p>
<div class="codehilite"><pre><span class="c1">// tokens is a counting semaphore used to</span>
<span class="c1">// enforce a limit of 20 concurrent requests.</span>
<span class="kd">var</span> <span class="nx">tokens</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{},</span> <span class="mi">20</span><span class="p">)</span>

<span class="kd">func</span> <span class="nx">crawl</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
    <span class="nx">tokens</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span> <span class="c1">// acquire a token</span>
    <span class="nx">list</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">links</span><span class="p">.</span><span class="nx">Extract</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
    <span class="o">&lt;-</span><span class="nx">tokens</span> <span class="c1">// release the token</span>

    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">list</span>
<span class="p">}</span>
</pre></div>


<p>The second problem is that the program never terminates, even when it has discovered all the links reachable from the initial URLs. For the program to terminate, we need to break out of the main loop when the <code>worklist</code> is empty and no crawl goroutines are active.</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">worklist</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span>
    <span class="kd">var</span> <span class="nx">n</span> <span class="kt">int</span> <span class="c1">// number of pending sends to worklist</span>

    <span class="c1">// Start with the command-line arguments.</span>
    <span class="nx">n</span><span class="o">++</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">worklist</span> <span class="o">&lt;-</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="p">}()</span>

    <span class="c1">// Crawl the web concurrently.</span>
    <span class="nx">seen</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">;</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span><span class="o">--</span> <span class="p">{</span>
        <span class="nx">list</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">worklist</span>
        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">link</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">list</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">!</span><span class="nx">seen</span><span class="p">[</span><span class="nx">link</span><span class="p">]</span> <span class="p">{</span>
                <span class="nx">seen</span><span class="p">[</span><span class="nx">link</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
                <span class="nx">n</span><span class="o">++</span>
                <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">link</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nx">worklist</span> <span class="o">&lt;-</span> <span class="nx">crawl</span><span class="p">(</span><span class="nx">link</span><span class="p">)</span>
                <span class="p">}(</span><span class="nx">link</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>In this version, the counter <code>n</code> keeps track of the number of sends to the <code>worklist</code> that are yet to occur. Each time we know that an item needs to be sent to the worklist, we increment <code>n</code>, once before we send the initial command-line arguments, and again each time we start a crawler goroutine. The main loop terminates when <code>n</code> falls to zero, since there is no more work to be done.</p>
<p>This concurrent crawler now runs about 20 times faster than the breadth-first crawler from <a href="../ch5/#anonymous-functions">Section 5.6</a>  and terminates correctly if it should complete its task.</p>
<p>The program below shows an alternative solution to the problem of excessive concurrency. It uses the original <code>crawl</code> function that has no counting semaphore, but calls it from one of 20 long-lived crawler goroutines, thus ensuring that at most 20 HTTP requests are active concurrently.</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/crawl3/findlinks.go">gopl.io/ch8/crawl3/findlinks.go</a></small></p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">worklist</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span>  <span class="c1">// lists of URLs, may have duplicates</span>
    <span class="nx">unseenLinks</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span> <span class="c1">// de-duplicated URLs</span>

    <span class="c1">// Add command-line arguments to worklist.</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">worklist</span> <span class="o">&lt;-</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="p">}()</span>

    <span class="c1">// Create 20 crawler goroutines to fetch each unseen link.</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">for</span> <span class="nx">link</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">unseenLinks</span> <span class="p">{</span>
                <span class="nx">foundLinks</span> <span class="o">:=</span> <span class="nx">crawl</span><span class="p">(</span><span class="nx">link</span><span class="p">)</span>
                <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">worklist</span> <span class="o">&lt;-</span> <span class="nx">foundLinks</span> <span class="p">}()</span>
            <span class="p">}</span>
        <span class="p">}()</span>
    <span class="p">}</span>

    <span class="c1">// The main goroutine de-duplicates worklist items</span>
    <span class="c1">// and sends the unseen ones to the crawlers.</span>
    <span class="nx">seen</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">list</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">worklist</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">link</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">list</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">!</span><span class="nx">seen</span><span class="p">[</span><span class="nx">link</span><span class="p">]</span> <span class="p">{</span>
                <span class="nx">seen</span><span class="p">[</span><span class="nx">link</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
                <span class="nx">unseenLinks</span> <span class="o">&lt;-</span> <span class="nx">link</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>In the above program:</p>
<ul>
<li>The crawler goroutines are all fed by the same channel, <code>unseenLinks</code>.</li>
<li>The main goroutine is responsible for de-duplicating items it receives from the worklist, and then sending each unseen one over the <code>unseenLinks</code> channel to a crawler goroutine.</li>
<li>
<p>The <code>seen</code> map is <em>confined</em> within the main goroutine; that is, it can be accessed only by that goroutine. Like other forms of information hiding, confinement helps us reason about the correctness of a program. For example:</p>
<ul>
<li>Local variables cannot be mentioned by name from outside the function in which they are declared.</li>
<li>Variables that do not escape (<a href="../ch2/#lifetime-of-variables">Section 2.3.4</a>) from a function cannot be accessed from outside that function.</li>
<li>Encapsulated fields of an object cannot be accessed except by the methods of that object.</li>
</ul>
<p>In all cases, information hiding helps to limit unintended interactions between parts of the program.</p>
</li>
<li>
<p>Links found by <code>crawl</code> are sent to the worklist from a dedicated goroutine to avoid deadlock.</p>
</li>
<li>To save space, this example does not address the problem of termination.</li>
</ul>
<h3 id="multiplexing-with-select">Multiplexing with <code>select</code><a class="headerlink" href="#multiplexing-with-select" title="Permanent link">&para;</a></h3>
<p>The program below does the countdown for a rocket launch. The <a href="https://golang.org/pkg/time/#Tick"><code>time.Tick</code></a> function returns a channel on which it sends events periodically, acting like a <a href="https://en.wikipedia.org/wiki/Metronome">metronome</a>. The value of each event is a timestamp, but it is rarely as interesting as the fact of its delivery.</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/countdown1/countdown.go">gopl.io/ch8/countdown1/countdown.go</a></small></p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Commencing countdown.&quot;</span><span class="p">)</span>
    <span class="nx">tick</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Tick</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">countdown</span> <span class="o">:=</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">countdown</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">countdown</span><span class="o">--</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">countdown</span><span class="p">)</span>
        <span class="o">&lt;-</span><span class="nx">tick</span>
    <span class="p">}</span>
    <span class="nx">launch</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>


<p>The following code adds the ability to abort the launch sequence by pressing the return key during the countdown. First, it starts a goroutine that tries to read a single byte from the standard input and, if it succeeds, sends a value on a channel called <code>abort</code>.</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/countdown2/countdown.go">gopl.io/ch8/countdown2/countdown.go</a></small></p>
<div class="codehilite"><pre><span class="nx">abort</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">.</span><span class="nx">Read</span><span class="p">(</span><span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="c1">// read a single byte</span>
    <span class="nx">abort</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>
<span class="p">}()</span>
</pre></div>


<p>Now each iteration of the countdown loop needs to wait for an event to arrive on one of the two channels:</p>
<ul>
<li>The ticker channel if everything is fine ("nominal" in NASA jargon)</li>
<li>An abort event if there was an "anomaly"</li>
</ul>
<p>We can't just receive from each channel because whichever operation we try first will block until completion. We need to multiplex these operations with a <em>select statement</em>.</p>
<p>The general form of a select statement is shown above.</p>
<div class="codehilite"><pre><span class="k">select</span> <span class="p">{</span>
<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ch1</span><span class="p">:</span>
    <span class="c1">// ...</span>
<span class="k">case</span> <span class="nx">x</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch2</span><span class="p">:</span>
    <span class="c1">// ...use x...</span>
<span class="k">case</span> <span class="nx">ch3</span> <span class="o">&lt;-</span> <span class="nx">y</span><span class="p">:</span>
    <span class="c1">// ...</span>
<span class="k">default</span><span class="p">:</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>


<p>Like a switch statement, it has a number of cases and an optional default. Each case specifies a <em>communication</em> (a send or receive operation on some channel) and an associated block of statements.</p>
<ul>
<li>In the first case, a receive expression appears on its own.</li>
<li>In the second case, a receive expression appears within a short variable declaration. This enables you to refer to the received value.</li>
</ul>
<p>A <code>select</code> waits until a communication for some case is ready to proceed. It then performs that communication and executes the case's associated statements; the other communications do not happen. A <code>select</code> with no cases, <code>select{}</code>, waits forever.</p>
<p>Let's return to our rocket launch program. The <code>time.After</code> function immediately returns a channel, and starts a new goroutine that sends a single value on that channel after the specified time. The select statement below waits until the first of two events arrives, either an abort event or the event indicating that 10 seconds have elapsed. If 10 seconds go by with no abort, the launch proceeds.</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...create abort channel...</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Commencing countdown.  Press return to abort.&quot;</span><span class="p">)</span>
    <span class="k">select</span> <span class="p">{</span>
    <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">time</span><span class="p">.</span><span class="nx">After</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">):</span>
        <span class="c1">// Do nothing.</span>
    <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">abort</span><span class="p">:</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Launch aborted!&quot;</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="nx">launch</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>


<p>The example below is more subtle. The channel <code>ch</code>, whose buffer size is 1, is alternately empty then full, so only one of the cases can proceed, either the send when <code>i</code> is even, or the receive when <code>i</code> is odd. It always prints <code>0 2 4 6 8</code>.</p>
<div class="codehilite"><pre><span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="k">select</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">x</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span><span class="p">:</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="c1">// &quot;0&quot; &quot;2&quot; &quot;4&quot; &quot;6&quot; &quot;8&quot;</span>
    <span class="k">case</span> <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">i</span><span class="p">:</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>If multiple cases are ready, <code>select</code> picks one at random, which ensures that every channel has an equal chance of being selected. Increasing the buffer size of the previous example makes its output nondeterministic, because when the buffer is neither full nor empty, the select statement figuratively tosses a coin.</p>
<p>The following launch program prints the countdown. The select statement below causes each iteration of the loop to wait up to 1 second for an abort, but no longer.</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/countdown3/countdown.go">gopl.io/ch8/countdown3/countdown.go</a></small></p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...create abort channel...</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Commencing countdown.  Press return to abort.&quot;</span><span class="p">)</span>
    <span class="nx">tick</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Tick</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">countdown</span> <span class="o">:=</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">countdown</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">countdown</span><span class="o">--</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">countdown</span><span class="p">)</span>
        <span class="k">select</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">tick</span><span class="p">:</span>
            <span class="c1">// Do nothing.</span>
        <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">abort</span><span class="p">:</span>
            <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Launch aborted!&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">launch</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>


<p>The <code>time.Tick</code> function behaves as if it creates a goroutine that calls <code>time.Sleep</code> in a loop, sending an event each time it wakes up. When the countdown function above returns, it stops receiving events from tick, but the ticker goroutine is still there, trying in vain to send on a channel from which no goroutine is receiving, which is a <strong>goroutine leak</strong> (<a href="#buffered-channels">Section 8.4.4</a>).</p>
<p>The <code>Tick</code> function is convenient, but it's appropriate only when the ticks will be needed throughout the lifetime of the application. Otherwise, we should use this pattern:</p>
<div class="codehilite"><pre><span class="nx">ticker</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">NewTicker</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="o">&lt;-</span><span class="nx">ticker</span><span class="p">.</span><span class="nx">C</span> <span class="c1">// receive from the ticker&#39;s channel</span>
<span class="nx">ticker</span><span class="p">.</span><span class="nx">Stop</span><span class="p">()</span> <span class="c1">// cause the ticker&#39;s goroutine to terminate</span>
</pre></div>


<p>Sometimes we want to try to send or receive on a channel but avoid blocking if the channel is not ready, which a non-blocking communication. A select statement can do that. A select may have a default, which specifies what to do when none of the other communications can proceed immediately.</p>
<p>The select statement below receives a value from the <code>abort</code> channel if there is one to receive; otherwise it does nothing. This is a <em>non-blocking</em> receive operation; doing it repeatedly is called <a href="https://en.wikipedia.org/wiki/Polling_(computer_science)">polling</a> a channel.</p>
<div class="codehilite"><pre><span class="k">select</span> <span class="p">{</span>
<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">abort</span><span class="p">:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;Launch aborted!\n&quot;</span><span class="p">)</span>
    <span class="k">return</span>
<span class="k">default</span><span class="p">:</span>
    <span class="c1">// do nothing</span>
<span class="p">}</span>
</pre></div>


<p>The zero value for a channel is <code>nil</code>, and nil channels are sometimes useful. Because send and receive operations on a nil channel block forever, a case in a select statement whose channel is nil is never selected. This enables us to use nil to enable or disable cases that correspond to features like:</p>
<ul>
<li>Handling timeouts or cancellation</li>
<li>Responding to other input events</li>
<li>Emitting output</li>
</ul>
<p>The next section gives us an example.</p>
<h3 id="example-concurrent-directory-traversal">Example: Concurrent Directory Traversal<a class="headerlink" href="#example-concurrent-directory-traversal" title="Permanent link">&para;</a></h3>
<p>This section builds a program that reports the disk usage of one or more directories specified on the command line, like the Unix <a href="https://en.wikipedia.org/wiki/Du_(Unix)"><code>du</code></a> command. Most of its work is done by the <code>walkDir</code> function below, which enumerates the entries of the directory <code>dir</code> using the <code>dirents</code> helper function.</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/du1/main.go">gopl.io/ch8/du1/main.go</a></small></p>
<div class="codehilite"><pre><span class="c1">// walkDir recursively walks the file tree rooted at dir</span>
<span class="c1">// and sends the size of each found file on fileSizes.</span>
<span class="kd">func</span> <span class="nx">walkDir</span><span class="p">(</span><span class="nx">dir</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">fileSizes</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">entry</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dirents</span><span class="p">(</span><span class="nx">dir</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">IsDir</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">subdir</span> <span class="o">:=</span> <span class="nx">filepath</span><span class="p">.</span><span class="nx">Join</span><span class="p">(</span><span class="nx">dir</span><span class="p">,</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">Name</span><span class="p">())</span>
            <span class="nx">walkDir</span><span class="p">(</span><span class="nx">subdir</span><span class="p">,</span> <span class="nx">fileSizes</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">fileSizes</span> <span class="o">&lt;-</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">Size</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// dirents returns the entries of directory dir.</span>
<span class="kd">func</span> <span class="nx">dirents</span><span class="p">(</span><span class="nx">dir</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="nx">os</span><span class="p">.</span><span class="nx">FileInfo</span> <span class="p">{</span>
    <span class="nx">entries</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nx">ReadDir</span><span class="p">(</span><span class="nx">dir</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&quot;du1: %v\n&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">entries</span>
<span class="p">}</span>
</pre></div>


<ul>
<li>The <a href="https://golang.org/pkg/io/ioutil/#ReadDir"><code>ioutil.ReadDir</code></a> function returns a slice of <a href="https://golang.org/pkg/os/#FileInfo"><code>os.FileInfo</code></a>, which is the same information that a call to <a href="https://golang.org/pkg/os/#Stat"><code>os.Stat</code></a> returns for a single file.</li>
<li>For each subdirectory, <code>walkDir</code> recursively calls itself, and for each file, <code>walkDir</code> sends a message (the size of the file in bytes) on the <code>fileSizes</code> channel.</li>
</ul>
<p>The main function below uses two goroutines:</p>
<ul>
<li>The background goroutine calls <code>walkDir</code> for each director <code>y</code> specified on the command line and finally closes the <code>fileSizes</code> channel.</li>
<li>The main goroutine computes the sum of the file sizes it receives from the channel and finally prints the total.</li>
</ul>
<div class="codehilite"><pre><span class="c1">// The du1 command computes the disk usage of the files in a directory.</span>
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;flag&quot;</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;io/ioutil&quot;</span>
    <span class="s">&quot;os&quot;</span>
    <span class="s">&quot;path/filepath&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Determine the initial directories.</span>
    <span class="nx">flag</span><span class="p">.</span><span class="nx">Parse</span><span class="p">()</span>
    <span class="nx">roots</span> <span class="o">:=</span> <span class="nx">flag</span><span class="p">.</span><span class="nx">Args</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">roots</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">roots</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&quot;.&quot;</span><span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Traverse the file tree.</span>
    <span class="nx">fileSizes</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int64</span><span class="p">)</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">root</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">roots</span> <span class="p">{</span>
            <span class="nx">walkDir</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">fileSizes</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nb">close</span><span class="p">(</span><span class="nx">fileSizes</span><span class="p">)</span>
    <span class="p">}()</span>

    <span class="c1">// Print the results.</span>
    <span class="kd">var</span> <span class="nx">nfiles</span><span class="p">,</span> <span class="nx">nbytes</span> <span class="kt">int64</span>
    <span class="k">for</span> <span class="nx">size</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">fileSizes</span> <span class="p">{</span>
        <span class="nx">nfiles</span><span class="o">++</span>
        <span class="nx">nbytes</span> <span class="o">+=</span> <span class="nx">size</span>
    <span class="p">}</span>
    <span class="nx">printDiskUsage</span><span class="p">(</span><span class="nx">nfiles</span><span class="p">,</span> <span class="nx">nbytes</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">printDiskUsage</span><span class="p">(</span><span class="nx">nfiles</span><span class="p">,</span> <span class="nx">nbytes</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%d files  %.1f GB\n&quot;</span><span class="p">,</span> <span class="nx">nfiles</span><span class="p">,</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">nbytes</span><span class="p">)</span><span class="o">/</span><span class="mf">1e9</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>This program pauses for a long while before printing its result:</p>
<div class="codehilite"><pre><span class="gp">$</span> go build gopl.io/ch8/du1
<span class="gp">$</span> ./du1 $HOME /usr /bin /etc
<span class="go">213201 files 62.7 GB</span>
</pre></div>


<p>The program would be nicer if it kept us informed of its progress. However, simply moving the <code>printDiskUsage</code> call into the loop would cause it to print thousands of lines of output. The variant of <code>du</code> below prints the totals periodically, but only if the <code>-v</code> flag is specified since not all users will want to see progress messages. The background goroutine that loops over <code>roots</code> remains unchanged.</p>
<p>In the following program:</p>
<ul>
<li>The main goroutine uses a ticker to generate events every 500ms.</li>
<li>The select statement waits for either a file size message, in which case it updates the totals, or a tick event, in which case it prints the current totals.</li>
<li>If the <code>-v</code> flag is not specified, the <code>tick</code> channel remains nil, and its case in the <code>select</code> is effectively disabled.</li>
</ul>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/du2/main.go">gopl.io/ch8/du2/main.go</a></small></p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">verbose</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nx">Bool</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="s">&quot;show verbose progress messages&quot;</span><span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...start background goroutine...</span>
    <span class="c1">// Print the results periodically.</span>
    <span class="kd">var</span> <span class="nx">tick</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
    <span class="k">if</span> <span class="o">*</span><span class="nx">verbose</span> <span class="p">{</span>
        <span class="nx">tick</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Tick</span><span class="p">(</span><span class="mi">500</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="kd">var</span> <span class="nx">nfiles</span><span class="p">,</span> <span class="nx">nbytes</span> <span class="kt">int64</span>
<span class="nx">loop</span><span class="p">:</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="k">select</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nx">size</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">fileSizes</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
                <span class="k">break</span> <span class="nx">loop</span> <span class="c1">// fileSizes was closed</span>
            <span class="p">}</span>
            <span class="nx">nfiles</span><span class="o">++</span>
            <span class="nx">nbytes</span> <span class="o">+=</span> <span class="nx">size</span>
        <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">tick</span><span class="p">:</span>
            <span class="nx">printDiskUsage</span><span class="p">(</span><span class="nx">nfiles</span><span class="p">,</span> <span class="nx">nbytes</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">printDiskUsage</span><span class="p">(</span><span class="nx">nfiles</span><span class="p">,</span> <span class="nx">nbytes</span><span class="p">)</span> <span class="c1">// final totals</span>
<span class="p">}</span>
</pre></div>


<p>Since the program no longer uses a <code>range</code> loop, the first <code>select</code> case must explicitly test whether the <code>fileSizes</code> channel has been closed, using the two-result form of receive operation. If the channel has been closed, the program breaks out of the loop. <u>The labeled <code>break</code> statement breaks out of both the <code>select</code> and the <code>for</code> loop; an unlabeled break would break out of only the <code>select</code>, causing the loop to begin the next iteration.</u></p>
<p>The program now gives us a stream of updates:</p>
<div class="codehilite"><pre><span class="err">$</span> <span class="k">go</span> <span class="nx">build</span> <span class="nx">gopl</span><span class="p">.</span><span class="nx">io</span><span class="o">/</span><span class="nx">ch8</span><span class="o">/</span><span class="nx">du2</span>
<span class="err">$</span> <span class="p">.</span><span class="o">/</span><span class="nx">du2</span> <span class="o">-</span><span class="nx">v</span> <span class="err">$</span><span class="nx">HOME</span> <span class="o">/</span><span class="nx">usr</span> <span class="o">/</span><span class="nx">bin</span> <span class="o">/</span><span class="nx">etc</span>
<span class="mi">28608</span> <span class="nx">files</span> <span class="mf">8.3</span> <span class="nx">GB</span>
<span class="mi">54147</span> <span class="nx">files</span> <span class="mf">10.3</span> <span class="nx">GB</span>
<span class="mi">93591</span> <span class="nx">files</span> <span class="mf">15.1</span> <span class="nx">GB</span>
<span class="mi">127169</span> <span class="nx">files</span> <span class="mf">52.9</span> <span class="nx">GB</span>
<span class="mi">175931</span> <span class="nx">files</span> <span class="mf">62.2</span> <span class="nx">GB</span>
<span class="mi">213201</span> <span class="nx">files</span> <span class="mf">62.7</span> <span class="nx">GB</span>
</pre></div>


<p>However, it still takes too long to finish. All the calls to <code>walkDir</code> can be done concurrently, thereby exploiting parallelism in the disk system. The third version of <code>du</code>, below, creates a new goroutine for each call to <code>walkDir</code>. It uses a <code>sync.WaitGroup</code> (<a href="#looping-in-parallel">Section 8.5</a>) to count the number of calls to <code>walkDir</code> that are still active, and a closer goroutine to close the <code>fileSizes</code> channel when the counter drops to zero.</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/du3/main.go">gopl.io/ch8/du3/main.go</a></small></p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...determine roots...</span>

    <span class="c1">// Traverse each root of the file tree in parallel.</span>
    <span class="nx">fileSizes</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int64</span><span class="p">)</span>
    <span class="kd">var</span> <span class="nx">n</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">root</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">roots</span> <span class="p">{</span>
        <span class="nx">n</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">go</span> <span class="nx">walkDir</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">n</span><span class="p">,</span> <span class="nx">fileSizes</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">n</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span>
        <span class="nb">close</span><span class="p">(</span><span class="nx">fileSizes</span><span class="p">)</span>
    <span class="p">}()</span>

    <span class="c1">// ...select loop...</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">walkDir</span><span class="p">(</span><span class="nx">dir</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">n</span> <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">,</span> <span class="nx">fileSizes</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">entry</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dirents</span><span class="p">(</span><span class="nx">dir</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">IsDir</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">n</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="nx">subdir</span> <span class="o">:=</span> <span class="nx">filepath</span><span class="p">.</span><span class="nx">Join</span><span class="p">(</span><span class="nx">dir</span><span class="p">,</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">Name</span><span class="p">())</span>
            <span class="k">go</span> <span class="nx">walkDir</span><span class="p">(</span><span class="nx">subdir</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">fileSizes</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">fileSizes</span> <span class="o">&lt;-</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">Size</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>Since this program creates many thousands of goroutines at its peak, we have to change <code>dirents</code> to use a counting semaphore to prevent it from opening too many files at once, similar to the web crawler in <a href="#example-concurrent-web-crawler">Section 8.6</a>:</p>
<div class="codehilite"><pre><span class="c1">// sema is a counting semaphore for limiting concurrency in dirents.</span>
<span class="kd">var</span> <span class="nx">sema</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{},</span> <span class="mi">20</span><span class="p">)</span>

<span class="c1">// dirents returns the entries of directory dir.</span>
<span class="kd">func</span> <span class="nx">dirents</span><span class="p">(</span><span class="nx">dir</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="nx">os</span><span class="p">.</span><span class="nx">FileInfo</span> <span class="p">{</span>
    <span class="nx">sema</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>        <span class="c1">// acquire token</span>
    <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="o">&lt;-</span><span class="nx">sema</span> <span class="p">}()</span> <span class="c1">// release token</span>
    <span class="c1">// ...</span>
</pre></div>


<p>This version runs several times faster than the previous one.</p>
<h3 id="cancellation">Cancellation<a class="headerlink" href="#cancellation" title="Permanent link">&para;</a></h3>
<p>Sometimes we need to instruct a goroutine to stop what it is doing, for example, in a web server performing a computation on behalf of a client that has disconnected.</p>
<p>There is no way for one goroutine to terminate another directly, since that would leave all its shared variables in undefined states.</p>
<p>In the rocket launch program (<a href="#multiplexing-with-select">Section 8.7</a>) we sent a single value on a channel named <code>abort</code>, which the countdown goroutine interpreted as a request to stop itself. But what if we need to cancel two goroutines, or an arbitrary number?</p>
<p>One possibility might be to send as many events on the <code>abort</code> channel as there are goroutines to cancel:</p>
<ul>
<li>If some of the goroutines have already terminated themselves, however, our count will be too large, and our sends will get stuck.</li>
<li>On the other hand, if those goroutines have spawned other goroutines, our count will be too small, and some goroutines will remain unaware of the cancellation.</li>
</ul>
<p>In general, it's hard to know how many goroutines are working on our behalf at any given moment. Moreover, when a goroutine receives a value from the <code>abort</code> channel, it consumes that value so that other goroutines won't see it. For cancellation, what we need is a reliable mechanism to <em>broadcast</em> an event over a channel so that many goroutines can see it as it occurs and can later see that it has occurred.</p>
<p>Recall that after a channel has been closed and drained of all sent values, subsequent receive operations proceed immediately, yielding zero values. <u>We can exploit this to create a broadcast mechanism: don't send a value on the channel, <em>close</em> it.</u></p>
<p>We can add cancellation to the <code>du</code> program from the previous section with a few simple changes.</p>
<p>First, create a cancellation channel on which no values are ever sent, but whose closure indicates that it is time for the program to stop what it is doing. We also define a utility function, <code>cancelled</code>, that checks or <em>polls</em> the cancellation state when it is called.</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/du4/main.go">gopl.io/ch8/du4/main.go</a></small></p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">done</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>

<span class="kd">func</span> <span class="nx">cancelled</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">select</span> <span class="p">{</span>
    <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">done</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">true</span>
    <span class="k">default</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>Next, create a goroutine that will read from the standard input, which is typically connected to the terminal. As soon as any input is read (for instance, the user presses the return key), this goroutine broadcasts the cancellation by closing the <code>done</code> channel.</p>
<div class="codehilite"><pre><span class="c1">// Cancel traversal when input is detected.</span>
<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">.</span><span class="nx">Read</span><span class="p">(</span><span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="c1">// read a single byte</span>
  <span class="nb">close</span><span class="p">(</span><span class="nx">done</span><span class="p">)</span>
<span class="p">}()</span>
</pre></div>


<p>To make our goroutines respond to the cancellation, in the main goroutine, add a third case to the select statement that tries to receive from the <code>done</code> channel. The function returns if this case is ever selected, but before it returns it must first drain the <code>fileSizes</code> channel, discarding all values until the channel is closed. It does this to ensure that any active calls to <code>walkDir</code> can run to completion without getting stuck sending to <code>fileSizes</code>.</p>
<div class="codehilite"><pre><span class="k">for</span> <span class="p">{</span>
  <span class="k">select</span> <span class="p">{</span>
  <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">done</span><span class="p">:</span>
    <span class="c1">// Drain fileSizes to allow existing goroutines to finish.</span>
    <span class="k">for</span> <span class="k">range</span> <span class="nx">fileSizes</span> <span class="p">{</span>
      <span class="c1">// Do nothing.</span>
    <span class="p">}</span>
    <span class="k">return</span>
  <span class="k">case</span> <span class="nx">size</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">fileSizes</span><span class="p">:</span>
    <span class="c1">// ...</span>
    <span class="c1">//!-3</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
      <span class="k">break</span> <span class="nx">loop</span> <span class="c1">// fileSizes was closed</span>
    <span class="p">}</span>
    <span class="nx">nfiles</span><span class="o">++</span>
    <span class="nx">nbytes</span> <span class="o">+=</span> <span class="nx">size</span>
  <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">tick</span><span class="p">:</span>
    <span class="nx">printDiskUsage</span><span class="p">(</span><span class="nx">nfiles</span><span class="p">,</span> <span class="nx">nbytes</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>The <code>walkDir</code> goroutine polls the cancellation status when it begins, and returns without doing anything if the status is set. This turns all goroutines created after cancellation into no-ops:</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">walkDir</span><span class="p">(</span><span class="nx">dir</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">n</span> <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">,</span> <span class="nx">fileSizes</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">cancelled</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">entry</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dirents</span><span class="p">(</span><span class="nx">dir</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>It might be profitable to poll the cancellation status again within <code>walkDir</code>'s loop, to avoid creating goroutines after the cancellation event. Ensuring that no expensive operations ever occur after the cancellation event may require updating many places in your code, but often most of the benefit can be obtained by checking for cancellation in a few important places. [p252]</p>
<p>A little profiling of this program revealed that the bottleneck was the acquisition of a semaphore token in <code>dirents</code>. The <code>select</code> below makes this operation cancellable and reduces the typical cancellation latency of the program from hundreds of milliseconds to tens:</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">dirents</span><span class="p">(</span><span class="nx">dir</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="nx">os</span><span class="p">.</span><span class="nx">FileInfo</span> <span class="p">{</span>
    <span class="k">select</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">sema</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}:</span> <span class="c1">// acquire token</span>
    <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">done</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">nil</span> <span class="c1">// cancelled</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="o">&lt;-</span><span class="nx">sema</span> <span class="p">}()</span> <span class="c1">// release token</span>

    <span class="c1">// ...read directory...</span>
<span class="p">}</span>
</pre></div>


<p>Now, when cancellation occurs, all the background goroutines quickly stop and the <code>main</code> function returns. When <code>main</code> returns, a program exits, so it can be hard to tell a main function that cleans up after itself from one that does not.</p>
<p>There's a handy trick we can use during testing: if instead of returning from <code>main</code> in the event of cancellation, we execute a call to <code>panic</code>, then the runtime will dump the stack of every goroutine in the program:</p>
<ul>
<li>If the main goroutine is the only one left, then it has cleaned up after itself.</li>
<li>If other goroutines remain, they may not have been properly cancelled, or perhaps they have been cancelled but the cancellation takes time.</li>
</ul>
<p>A little investigation may be worthwhile. The panic dump often contains sufficient information to distinguish these cases.</p>
<h3 id="example-chat-server">Example: Chat Server<a class="headerlink" href="#example-chat-server" title="Permanent link">&para;</a></h3>
<p>This chapter discusses a chat server that enables several users broadcast messages to each other. There are four kinds of goroutine in this program:</p>
<ul>
<li>There is one instance apiece of the <code>main</code> and <code>broadcaster</code> goroutines</li>
<li>For each client connection there is one <code>handleConn</code> and one <code>clientWriter</code> goroutine.</li>
</ul>
<p>The broadcaster is a good illustration of how <code>select</code> is used, since it has to respond to three different kinds of messages.</p>
<p>The main goroutine listens for and accept incoming network connections from clients. For each one, it creates a new <code>handleConn</code> goroutine, similar to the <a href="#example-concurrent-echo-server">concurrent echo server example</a> earlier this chapter.</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch8/chat/chat.go">gopl.io/ch8/chat/chat.go</a></small></p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">listener</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Listen</span><span class="p">(</span><span class="s">&quot;tcp&quot;</span><span class="p">,</span> <span class="s">&quot;localhost:8000&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">go</span> <span class="nx">broadcaster</span><span class="p">()</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">listener</span><span class="p">.</span><span class="nx">Accept</span><span class="p">()</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">log</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="p">}</span>
        <span class="k">go</span> <span class="nx">handleConn</span><span class="p">(</span><span class="nx">conn</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>The broadcaster's local variable <code>clients</code> records the current set of connected clients. The only information recorded about each client is the identity of its outgoing message channel.</p>
<div class="codehilite"><pre><span class="kd">type</span> <span class="nx">client</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">string</span> <span class="c1">// an outgoing message channel</span>

<span class="kd">var</span> <span class="p">(</span>
    <span class="nx">entering</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">client</span><span class="p">)</span>
    <span class="nx">leaving</span>  <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">client</span><span class="p">)</span>
    <span class="nx">messages</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span> <span class="c1">// all incoming client messages</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">broadcaster</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">clients</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">client</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span> <span class="c1">// all connected clients</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="k">select</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nx">msg</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">messages</span><span class="p">:</span>
            <span class="c1">// Broadcast incoming message to all</span>
            <span class="c1">// clients&#39; outgoing message channels.</span>
            <span class="k">for</span> <span class="nx">cli</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">clients</span> <span class="p">{</span>
                <span class="nx">cli</span> <span class="o">&lt;-</span> <span class="nx">msg</span>
            <span class="p">}</span>

        <span class="k">case</span> <span class="nx">cli</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">entering</span><span class="p">:</span>
            <span class="nx">clients</span><span class="p">[</span><span class="nx">cli</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>

        <span class="k">case</span> <span class="nx">cli</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">leaving</span><span class="p">:</span>
            <span class="nb">delete</span><span class="p">(</span><span class="nx">clients</span><span class="p">,</span> <span class="nx">cli</span><span class="p">)</span>
            <span class="nb">close</span><span class="p">(</span><span class="nx">cli</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>The broadcaster does the following:</p>
<ul>
<li>It listens on the global <code>entering</code> and <code>leaving</code> channels for announcements of arriving and departing clients. When it receives one of these events, it updates the <code>clients</code> set; if the event was a departure, it closes the client's outgoing message channel.</li>
<li>It also listens for events on the global <code>messages</code> channel, to which each client sends all its incoming messages. When the broadcaster receives one of these events, it broadcasts the message to every connected client.</li>
</ul>
<p>The <code>handleConn</code> goroutine does the following:</p>
<ul>
<li>It creates a new outgoing message channel for its client and announces the arrival of this client to the broadcaster over the <code>entering</code> channel.</li>
<li>Then it reads every line of text from the client, sending each line to the broadcaster over the global incoming message channel, prefixing each message with the identity of its sender.</li>
<li>Once there is nothing more to read from the client, <code>handleConn</code> announces the departure of the client over the <code>leaving</code> channel and closes the connection.</li>
</ul>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">handleConn</span><span class="p">(</span><span class="nx">conn</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span> <span class="c1">// outgoing client messages</span>
    <span class="k">go</span> <span class="nx">clientWriter</span><span class="p">(</span><span class="nx">conn</span><span class="p">,</span> <span class="nx">ch</span><span class="p">)</span>

    <span class="nx">who</span> <span class="o">:=</span> <span class="nx">conn</span><span class="p">.</span><span class="nx">RemoteAddr</span><span class="p">().</span><span class="nx">String</span><span class="p">()</span>
    <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="s">&quot;You are &quot;</span> <span class="o">+</span> <span class="nx">who</span>
    <span class="nx">messages</span> <span class="o">&lt;-</span> <span class="nx">who</span> <span class="o">+</span> <span class="s">&quot; has arrived&quot;</span>
    <span class="nx">entering</span> <span class="o">&lt;-</span> <span class="nx">ch</span>

    <span class="nx">input</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nx">NewScanner</span><span class="p">(</span><span class="nx">conn</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">input</span><span class="p">.</span><span class="nx">Scan</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">messages</span> <span class="o">&lt;-</span> <span class="nx">who</span> <span class="o">+</span> <span class="s">&quot;: &quot;</span> <span class="o">+</span> <span class="nx">input</span><span class="p">.</span><span class="nx">Text</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="c1">// NOTE: ignoring potential errors from input.Err()</span>

    <span class="nx">leaving</span> <span class="o">&lt;-</span> <span class="nx">ch</span>
    <span class="nx">messages</span> <span class="o">&lt;-</span> <span class="nx">who</span> <span class="o">+</span> <span class="s">&quot; has left&quot;</span>
    <span class="nx">conn</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">clientWriter</span><span class="p">(</span><span class="nx">conn</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span> <span class="nx">ch</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">msg</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ch</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintln</span><span class="p">(</span><span class="nx">conn</span><span class="p">,</span> <span class="nx">msg</span><span class="p">)</span> <span class="c1">// NOTE: ignoring network errors</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>In addition, <code>handleConn</code> creates a <code>clientWriter</code> goroutine for each client that receives messages broadcast to the client's outgoing message channel and writes them to the client's network connection. The client writer's loop terminates when the broadcaster closes the channel after receiving a leaving notification.</p>
<p>The output below shows the server in action with two clients in separate windows on the
same computer, using <code>netcat</code> to chat:</p>
<div class="codehilite"><pre>$ go build gopl.io/ch8/chat
$ go build gopl.io/ch8/netcat3
$ ./chat &amp;
$ ./netcat3
You are 127.0.0.1:64208           $ ./netcat3
127.0.0.1:64211 has arrived       You are 127.0.0.1:64211
Hi!
127.0.0.1:64208: Hi!              127.0.0.1:64208: Hi!
Hi yourself.
127.0.0.1:64211: Hi yourself.     127.0.0.1:64211: Hi yourself.
^C
                                  127.0.0.1:64208 has left
$ ./netcat3
You are 127.0.0.1:64216           127.0.0.1:64216 has arrived
                                  Welcome.
127.0.0.1:64211: Welcome.         127.0.0.1:64211: Welcome.
                                  ^C
127.0.0.1:64211 has left
</pre></div>


<p>While hosting a chat session for <em>n</em> clients, this program runs 2<em>n</em>+2 concurrently communicating goroutines, yet it needs no explicit locking operations (<a href="../ch9/#mutual-exclusion-syncmutex">Section 9.2</a>). The clients map is confined to a single goroutine, the broadcaster, so it cannot be accessed concurrently. The only variables that are shared by multiple goroutines are channels and instances of <code>net.Conn</code>, both of which are <em>concurrency safe</em>. The next chapter discusses confinement, concurrency safety, and the implications of sharing variables across goroutines in the next chapter.</p>
            </div>
        </div>

        <footer class="col-md-12">
            
        </footer>

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script>
        <script src="../../js/base.js"></script>
        <script src="../../custom.js"></script>
    </body>
</html>