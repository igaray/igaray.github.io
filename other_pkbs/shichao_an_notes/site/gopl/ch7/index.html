<!DOCTYPE html>
<html lang="en">
    <head>
        <!-- Global Site Tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-59055167-2"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments)};
          gtag('js', new Date());

          gtag('config', 'UA-59055167-2');
        </script>

        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://notes.shichao.io/gopl/ch7/">
        <link rel="shortcut icon" href="../../toki_32.png">
        

	<title>Chapter 7. Interfaces - Shichao's Notes</title>

        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../../css/base.css" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,400italic,500,600" rel="stylesheet">
        <link href="../../custom.css" rel="stylesheet">
        <link href="../../friendly.css" rel="stylesheet">
        <link href="../../theme.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        
<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../..">Shichao's Notes</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">APUE <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../apue/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch1/">Chapter 1. UNIX System Overview</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch2/">Chapter 2. UNIX Standardization and Implementations</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch3/">Chapter 3. File I/O</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch4/">Chapter 4. Files and Directories</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch5/">Chapter 5. Standard I/O Library</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch6/">Chapter 6. System Data Files and Information</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch7/">Chapter 7. Process Environment</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch8/">Chapter 8. Process Control</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch9/">Chapter 9. Process Relationships</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch10/">Chapter 10. Signals</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch11/">Chapter 11. Threads</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch12/">Chapter 12. Thread Control</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch13/">Chapter 13. Daemon Processes</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch14/">Chapter 14. Advanced I/O</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch15/">Chapter 15. Interprocess Communication</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch16/">Chapter 16. Network IPC: Sockets</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch17/">Chapter 17. Advanced IPC</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UNP <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../unp/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch2/">Chapter 2. The Transport Layer: TCP, UDP, and SCTP</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch3/">Chapter 3. Sockets Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch4/">Chapter 4. Elementary TCP Sockets</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch5/">Chapter 5. TCP Client/Server Example</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch6/">Chapter 6. I/O Multiplexing: The select and poll Functions</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch7/">Chapter 7. Socket Options</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch8/">Chapter 8. Elementary UDP Sockets</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">TCPv1 <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../tcpv1/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch2/">Chapter 2. The Internet Address Architecture</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch3/">Chapter 3. Link Layer</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch4/">Chapter 4. ARP: Address Resolution Protocol</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch5/">Chapter 5. The Internet Protocol (IP)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch6/">Chapter 6. System Configuration: DHCP and Autoconfiguration</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch7/">Chapter 7. Firewalls and Network Address Translation (NAT)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch8/">Chapter 8. ICMPv4 and ICMPv6: Internet Control Message Protocol</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch9/">Chapter 9. Broadcasting and Local Multicasting (IGMP and MLD)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch10/">Chapter 10. User Datagram Protocol (UDP) and IP Fragmentation</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch11/">Chapter 11. Name Resolution and the Domain Name System (DNS)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch12/">Chapter 12. TCP: The Transmission Control Protocol (Preliminaries)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch13/">Chapter 13. TCP Connection Management</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch14/">Chapter 14. TCP Timeout and Retransmission</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch15/">Chapter 15. TCP Data Flow and Window Management</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch16/">Chapter 16. TCP Congestion Control</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch17/">Chapter 17. TCP Keepalive</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch18/">Chapter 18. Security: EAP, IPsec, TLS, DNSSEC, and DKIM</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/headers/">Headers</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">GOPL <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../ch1/">Chapter 1. Tutorial</a>
                        </li>
                      
                        <li>
                            <a href="../ch2/">Chapter 2. Program Structure</a>
                        </li>
                      
                        <li>
                            <a href="../ch3/">Chapter 3. Basic Data Types</a>
                        </li>
                      
                        <li>
                            <a href="../ch4/">Chapter 4. Composite Types</a>
                        </li>
                      
                        <li>
                            <a href="../ch5/">Chapter 5. Functions</a>
                        </li>
                      
                        <li>
                            <a href="../ch6/">Chapter 6. Methods</a>
                        </li>
                      
                        <li class="active">
                            <a href="./">Chapter 7. Interfaces</a>
                        </li>
                      
                        <li>
                            <a href="../ch8/">Chapter 8. Goroutines and Channels</a>
                        </li>
                      
                        <li>
                            <a href="../ch9/">Chapter 9. Concurrency with Shared Variables</a>
                        </li>
                      
                        <li>
                            <a href="../ch10/">Chapter 10. Packages and the Go Tool</a>
                        </li>
                      
                        <li>
                            <a href="../ch11/">Chapter 11. Testing</a>
                        </li>
                      
                        <li>
                            <a href="../ch12/">Chapter 12. Reflection</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">CSN <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../csn/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../csn/part1/">Part 1: Language</a>
                        </li>
                      
                        <li>
                            <a href="../../csn/part2/">Part 2: Advanced</a>
                        </li>
                      
                    </ul>
                </li>
            <li>
                    <a href="../../toc/">TOC</a>
                </li>
            </ul>
            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    
                        <a href="https://github.com/shichao-an/notes/blob/master/docs/gopl/ch7.md">
                    
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#chapter-7-interfaces">Chapter 7. Interfaces</a></li>
        
    
        <li class="main "><a href="#interfaces-as-contracts">Interfaces as Contracts</a></li>
        
            <li><a href="#concrete-type-and-interface-type">Concrete type and interface type *</a></li>
        
            <li><a href="#the-iowriter-interface">The io.Writer interface *</a></li>
        
            <li><a href="#the-fmtstringer-interface">The fmt.Stringer interface *</a></li>
        
    
        <li class="main "><a href="#interface-types">Interface Types</a></li>
        
    
        <li class="main "><a href="#interface-satisfaction">Interface Satisfaction</a></li>
        
            <li><a href="#empty-interface-interface">Empty interface: interface{} *</a></li>
        
    
        <li class="main "><a href="#parsing-flags-with-flagvalue">Parsing Flags with flag.Value</a></li>
        
    
        <li class="main "><a href="#interface-values">Interface Values</a></li>
        
            <li><a href="#caveat-an-interface-containing-a-nil-pointer-is-non-nil">Caveat: An Interface Containing a Nil Pointer Is Non-Nil</a></li>
        
    
        <li class="main "><a href="#sorting-with-sortinterface">Sorting with sort.Interface</a></li>
        
            <li><a href="#example-sorting-a-playlist">Example: sorting a playlist *</a></li>
        
    
        <li class="main "><a href="#the-httphandler-interface">The http.Handler Interface</a></li>
        
    
        <li class="main "><a href="#the-error-interface">The error Interface</a></li>
        
    
        <li class="main "><a href="#example-expression-evaluator">Example: Expression Evaluator</a></li>
        
    
        <li class="main "><a href="#type-assertions">Type Assertions</a></li>
        
    
        <li class="main "><a href="#discriminating-errors-with-type-assertions">Discriminating Errors with Type Assertions</a></li>
        
    
        <li class="main "><a href="#querying-behaviors-with-interface-type-assertions">Querying Behaviors with Interface Type Assertions</a></li>
        
    
        <li class="main "><a href="#type-switches">Type Switches</a></li>
        
    
        <li class="main "><a href="#example-token-based-xml-decoding">Example: Token-Based XML Decoding</a></li>
        
    
        <li class="main "><a href="#a-few-words-of-advice">A Few Words of Advice</a></li>
        
    
        <li class="main "><a href="#doubts-and-solution">Doubts and Solution</a></li>
        
            <li><a href="#verbatim">Verbatim</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">
              

<h3 id="chapter-7-interfaces"><strong>Chapter 7. Interfaces</strong><a class="headerlink" href="#chapter-7-interfaces" title="Permanent link">&para;</a></h3>
<p>Interface types express generalizations or abstractions about the behaviors of other types. By generalizing, interfaces facilitate more flexible and adaptable functions because they are not tied to the details of one particular implementation.</p>
<p>Different from the notion of interfaces in other object-oriented languages, Go's interfaces is distinctive in that they are satisfied implicitly. In other words, there's no need to declare all the interfaces that a given concrete type satisfies; simply possessing the necessary methods is enough. With this design, you are able to create new interfaces that are satisfied by existing concrete types without changing the existing types, which is particularly useful for types defined in packages that you don't control.</p>
<p>This chapter discusses:</p>
<ul>
<li>Basic mechanics of interface types and their values</li>
<li>Several important interfaces from the standard library</li>
<li>Type assertions and type switches</li>
</ul>
<h3 id="interfaces-as-contracts">Interfaces as Contracts<a class="headerlink" href="#interfaces-as-contracts" title="Permanent link">&para;</a></h3>
<h4 id="concrete-type-and-interface-type">Concrete type and interface type *<a class="headerlink" href="#concrete-type-and-interface-type" title="Permanent link">&para;</a></h4>
<p>All the types discussed so far are <a href="https://en.wikipedia.org/wiki/Class_(computer_programming)#Abstract_and_Concrete"><strong>concrete types</strong></a>. A concrete type specifies the exact representation of its values and exposes the intrinsic operations of that representation, such as arithmetic for numbers, or indexing, <code>append</code>, and <code>range</code> for slices. A concrete type may also provide additional behaviors through its methods. When you have a value of a concrete type, you know exactly what it is and what you can do with it.</p>
<p>There is another kind of type in Go called an <strong>interface type</strong>. An interface is an <a href="https://en.wikipedia.org/wiki/Abstract_type"><strong>abstract type</strong></a>. It doesn't expose the representation or internal structure of its values, or the set of basic operations they support; it reveals only some of their methods. When you have a value of an interface type, you know nothing about what it is; you know only what it can do, or more precisely, what behaviors are provided by its methods.</p>
<h4 id="the-iowriter-interface">The <code>io.Writer</code> interface *<a class="headerlink" href="#the-iowriter-interface" title="Permanent link">&para;</a></h4>
<p>This book has used two similar functions for string formatting:</p>
<ul>
<li><code>fmt.Printf</code>, which writes the result to the standard output (a file)</li>
<li><code>fmt.Sprintf</code>, which returns the result as a string</li>
</ul>
<p>Thanks to interfaces, both of these functions are in effect wrappers around a third function, <code>fmt.Fprintf</code>, which is agnostic about what happens to the result it computes:</p>
<div class="codehilite"><pre><span class="kn">package</span> <span class="nx">fmt</span>

<span class="kd">func</span> <span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

<span class="kd">func</span> <span class="nx">Printf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="nx">format</span><span class="p">,</span> <span class="nx">args</span><span class="o">...</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">Sprintf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">buf</span> <span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span>
    <span class="nx">Fprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">format</span><span class="p">,</span> <span class="nx">args</span><span class="o">...</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">buf</span><span class="p">.</span><span class="nx">String</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>


<p>The <code>F</code> prefix of <code>Fprintf</code> stands for <em>file</em> and indicates that the formatted output should be written to the file provided as the first argument.</p>
<ul>
<li>In the <code>Printf</code> case, the argument, <code>os.Stdout</code>, is an <a href="https://golang.org/pkg/os/#File"><code>*os.File</code></a>.</li>
<li>In the <code>Sprintf</code> case, the argument is not a file but superficially resembles one: <code>&amp;buf</code> is a pointer to a memory buffer to which bytes can be written.</li>
</ul>
<p>The first parameter of <code>Fprintf</code> is not a file either. It's an <a href="https://golang.org/pkg/io/#Writer"><code>io.Writer</code></a>, which is an interface type with the following declaration:</p>
<p><small><a href="https://github.com/golang/go/blob/master/src/io/io.go">go/src/io/io.go</a></small></p>
<div class="codehilite"><pre><span class="kn">package</span> <span class="nx">io</span>

<span class="c1">// Writer is the interface that wraps the basic Write method.</span>
<span class="c1">//</span>
<span class="c1">// Write writes len(p) bytes from p to the underlying data stream.</span>
<span class="c1">// It returns the number of bytes written from p (0 &lt;= n &lt;= len(p))</span>
<span class="c1">// and any error encountered that caused the write to stop early.</span>
<span class="c1">// Write must return a non-nil error if it returns n &lt; len(p).</span>
<span class="c1">// Write must not modify the slice data, even temporarily.</span>
<span class="c1">//</span>
<span class="c1">// Implementations must not retain p.</span>
<span class="kd">type</span> <span class="nx">Writer</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Write</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>The <code>io.Writer</code> interface defines the contract between <code>Fprintf</code> and its callers.</p>
<ul>
<li>The contract requires that the caller provide a value of a concrete type like <code>*os.File</code> or <code>*bytes.Buffer</code> that has a method called <code>Write</code> with the appropriate signature and behavior.</li>
<li>The contract guarantees that <code>Fprintf</code> will do its job given any value that satisfies the <code>io.Writer</code> interface.</li>
<li><code>Fprintf</code> may not assume that it is writing to a file or to memory, only that it can call <code>Write</code>.</li>
</ul>
<p>Because <code>fmt.Fprintf</code> assumes nothing about the representation of the value and relies only on the behaviors guaranteed by the <code>io.Writer</code> contract, we can safely pass a value of any concrete type that satisfies <code>io.Writer</code> as the first argument to <code>fmt.Fprintf</code>. This freedom to substitute one type for another that satisfies the same interface is called <em>substitutability</em>, and is a hallmark of object-oriented programming.</p>
<p>The following example uses a new type. The <code>Write</code> method of the <code>*ByteCounter</code> type below merely counts the bytes written to it before discarding them. (The conversion is required to make the types of <code>len(p)</code> and <code>*c</code> match in the <code>+=</code> assignment statement.)</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch7/bytecounter/main.go">gopl.io/ch7/bytecounter/main.go</a></small></p>
<div class="codehilite"><pre><span class="kd">type</span> <span class="nx">ByteCounter</span> <span class="kt">int</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">ByteCounter</span><span class="p">)</span> <span class="nx">Write</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="nx">c</span> <span class="o">+=</span> <span class="nx">ByteCounter</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">))</span> <span class="c1">// convert int to ByteCounter</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">),</span> <span class="kc">nil</span>
<span class="p">}</span>
</pre></div>


<p>Since <code>*ByteCounter</code> satisfies the <code>io.Writer</code> contract, we can pass it to <code>Fprintf</code>; the <code>ByteCounter</code> correctly accumulates the length of the result.</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">c</span> <span class="nx">ByteCounter</span>
<span class="nx">c</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">))</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="c1">// &quot;5&quot;, = len(&quot;hello&quot;)</span>

<span class="nx">c</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// reset the counter</span>
<span class="kd">var</span> <span class="nx">name</span> <span class="p">=</span> <span class="s">&quot;Dolly&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">,</span> <span class="s">&quot;hello, %s&quot;</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="c1">// &quot;12&quot;, = len(&quot;hello, Dolly&quot;)</span>
</pre></div>


<h4 id="the-fmtstringer-interface">The <code>fmt.Stringer</code> interface *<a class="headerlink" href="#the-fmtstringer-interface" title="Permanent link">&para;</a></h4>
<p>Besides <code>io.Writer</code>, <code>fmt.Stringer</code> is another interface of great importance to the <code>fmt</code> package. <code>Fprintf</code> and <code>Fprintln</code> provide a way for types to control how their values are printed. For example:</p>
<ul>
<li>In <a href="../ch2/#type-declarations">Section 2.5</a>, we defined a <code>String</code> method for the <code>Celsius</code> type so that temperatures would print as "<code>100°C</code>.</li>
<li>In <a href="../ch6/#example-bit-vector-type">Section 6.5</a>, we equipped <code>*IntSet</code> with a <code>String</code> method so that sets would be rendered using traditional set notation like "<code>{1 2 3}</code>".</li>
</ul>
<p>Declaring a <code>String</code> method makes a type satisfy <code>fmt.Stringer</code>, which is one of the most widely used interfaces of all:</p>
<p><small><a href="https://github.com/golang/go/blob/master/src/fmt/print.go">go/src/fmt/print.go</a></small></p>
<div class="codehilite"><pre><span class="kn">package</span> <span class="nx">fmt</span>

<span class="c1">// The String method is used to print values passed</span>
<span class="c1">// as an operand to any format that accepts a string</span>
<span class="c1">// or to an unformatted printer such as Print.</span>
<span class="kd">type</span> <span class="nx">Stringer</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
</pre></div>


<p><a href="#type-assertions">Section 7.10</a> will explain how the <code>fmt</code> package discovers which values satisfy this interface.</p>
<h3 id="interface-types">Interface Types<a class="headerlink" href="#interface-types" title="Permanent link">&para;</a></h3>
<p>An interface type specifies a set of methods that a concrete type must possess to be considered an instance of that interface.</p>
<p>The <code>io.Writer</code> type is one of the most widely used interfaces because it provides an abstraction of all the types to which bytes can be written, such as files, memory buffers, network connections, HTTP clients, archivers and hashers. The <code>io</code> package defines many other useful interfaces. A <code>Reader</code> represents any type from which you can read bytes, and a <code>Closer</code> is any value that you can close, such as a file or a network connection. (Notice the naming convention for many of Go's single-method interfaces.)</p>
<div class="codehilite"><pre><span class="kn">package</span> <span class="nx">io</span>

<span class="kd">type</span> <span class="nx">Reader</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Closer</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Close</span><span class="p">()</span> <span class="kt">error</span>
<span class="p">}</span>
</pre></div>


<p>The following are examples of new interface types as combinations of existing ones:</p>
<div class="codehilite"><pre><span class="kd">type</span> <span class="nx">ReadWriter</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Reader</span>
    <span class="nx">Writer</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ReadWriteCloser</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Reader</span>
    <span class="nx">Writer</span>
    <span class="nx">Closer</span>
<span class="p">}</span>
</pre></div>


<p>The syntax used above, which resembles <a href="../ch4#struct-embedding-and-anonymous-fields">struct embedding</a>, enables us to name another interface as a shorthand for writing out all of its methods. This is called <em>embedding</em> an interface. We could have written <code>io.ReadWriter</code> without embedding like this:</p>
<div class="codehilite"><pre><span class="kd">type</span> <span class="nx">ReadWriter</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
    <span class="nx">Write</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>We can even use a mixture of the two styles:</p>
<div class="codehilite"><pre><span class="kd">type</span> <span class="nx">ReadWriter</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
    <span class="nx">Writer</span>
<span class="p">}</span>
</pre></div>


<p>All three declarations have the same effect. The order in which the methods appear is immaterial. All that matters is the set of methods.</p>
<h3 id="interface-satisfaction">Interface Satisfaction<a class="headerlink" href="#interface-satisfaction" title="Permanent link">&para;</a></h3>
<p>A type <em>satisfies</em> an interface if it possesses all the methods the interface requires. For example:</p>
<ul>
<li>An <code>*os.File</code> satisfies <code>io.Reader</code>, <code>Writer</code>, <code>Closer</code>, and <code>ReadWriter</code>.</li>
<li>A <code>*bytes.Buffer</code> satisfies <code>Reader</code>, <code>Writer</code>, and <code>ReadWriter</code>, but does not satisfy <code>Closer</code> because it does not have a <code>Close</code> method.</li>
</ul>
<p>As a shorthand, Go programmers often say that a concrete type "is a" particular interface type, meaning that it satisfies the interface. For example:</p>
<ul>
<li>A <code>*bytes.Buffer</code> is an <code>io.Writer</code>.</li>
<li>An <code>*os.File</code> is an <code>io.ReadWriter</code>.</li>
</ul>
<p>The assignability rule (<a href="../ch2/#assignability">Section 2.4.2</a>) for interfaces is very simple: an expression may be assigned to an interface only if its type satisfies the interface. For example:</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span>
<span class="nx">w</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span>           <span class="c1">// OK: *os.File has Write method</span>
<span class="nx">w</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span>   <span class="c1">// OK: *bytes.Buffer has Write method</span>
<span class="nx">w</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span>         <span class="c1">// compile error: time.Duration lacks Write method</span>

<span class="kd">var</span> <span class="nx">rwc</span> <span class="nx">io</span><span class="p">.</span><span class="nx">ReadWriteCloser</span>
<span class="nx">rwc</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span>         <span class="c1">// OK: *os.File has Read, Write, Close methods</span>
<span class="nx">rwc</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span> <span class="c1">// compile error: *bytes.Buffer lacks Close method</span>
</pre></div>


<p>This rule applies even when the right-hand side is itself an interface:</p>
<div class="codehilite"><pre><span class="nx">w</span> <span class="p">=</span> <span class="nx">rwc</span>     <span class="c1">// OK: io.ReadWriteCloser has Write method</span>
<span class="nx">rwc</span> <span class="p">=</span> <span class="nx">w</span>     <span class="c1">// compile error: io.Writer lacks Close method</span>
</pre></div>


<p>We should explain one subtlety in what it means for a type to have a method. Recall from <a href="../ch6/#methods-with-a-pointer-receiver">Section 6.2</a> that for each named concrete type <code>T</code>, some of its methods have a receiver of type <code>T</code> itself whereas others require a <code>*T</code> pointer. Recall also that it is legal to call a <code>*T</code> method on an argument of type <code>T</code> as long as the argument is a variable; the compiler implicitly takes its address. However, this is mere syntactic sugar: a value of type <code>T</code> does not possess all the methods that a <code>*T</code> pointer does; as a result, <code>T</code> might satisfy fewer interfaces.</p>
<p>For example, the <code>String</code> method of the <code>IntSet</code> type from <a href="../ch6/#example-bit-vector-type">Section 6.5</a> requires a pointer receiver, so we cannot call that method on a non-addressable <code>IntSet</code> value:</p>
<div class="codehilite"><pre><span class="kd">type</span> <span class="nx">IntSet</span> <span class="kd">struct</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">IntSet</span><span class="p">)</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="kd">var</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">IntSet</span><span class="p">{}.</span><span class="nx">String</span><span class="p">()</span> <span class="c1">// compile error: String requires *IntSet receiver</span>
</pre></div>


<p>But we can call it on an <code>IntSet</code> variable:</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">s</span> <span class="nx">IntSet</span>
<span class="kd">var</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">String</span><span class="p">()</span> <span class="c1">// OK: s is a variable and &amp;s has a String method</span>
</pre></div>


<p>However, since only <code>*IntSet</code> has a <code>String</code> method, only <code>*IntSet</code> satisfies the <code>fmt.Stringer</code> interface:</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">_</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Stringer</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">s</span> <span class="c1">// OK</span>
<span class="kd">var</span> <span class="nx">_</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Stringer</span> <span class="p">=</span> <span class="nx">s</span>  <span class="c1">// compile error: IntSet lacks String method</span>
</pre></div>


<p><a href="../ch12/#displaying-the-methods-of-a-type">Section 12.8</a> includes a program that prints the methods of an arbitrary value, and the <code>godoc -analysis=type</code> tool (<a href="../ch10/#documenting-packages">Section 10.7.4</a>) displays the methods of each type and the relationship between interfaces and concrete types.</p>
<p>An interface wraps and conceals the concrete type and value that it holds. <u>Only the methods revealed by the interface type may be called, even if the concrete type has others</u>:</p>
<div class="codehilite"><pre><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">))</span> <span class="c1">// OK: *os.File has Write method</span>
<span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>                <span class="c1">// OK: *os.File has Close method</span>

<span class="kd">var</span> <span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span>
<span class="nx">w</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span>
<span class="nx">w</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">))</span> <span class="c1">// OK: io.Writer has Write method</span>
<span class="nx">w</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>                <span class="c1">// compile error: io.Writer lacks Close method</span>
</pre></div>


<h4 id="empty-interface-interface">Empty interface: <code>interface{}</code> *<a class="headerlink" href="#empty-interface-interface" title="Permanent link">&para;</a></h4>
<p>An interface with more methods, such as <code>io.ReadWriter</code>, tells us more about the values it contains, and places greater demands on the types that implement it, than does an interface with fewer methods such as <code>io.Reader</code>. Similarly, the type <code>interface{}</code>, which has no methods at all, tell us about nothing about the concrete types that satisfy it. This may seem useless, but in fact the type <code>interface{}</code>, which is called the <strong>empty interface</strong> type, is indispensable. Because the empty interface type places no demands on the types that satisfy it, we can assign any value to the empty interface.</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">any</span> <span class="kd">interface</span><span class="p">{}</span>
<span class="nx">any</span> <span class="p">=</span> <span class="kc">true</span>
<span class="nx">any</span> <span class="p">=</span> <span class="mf">12.34</span>
<span class="nx">any</span> <span class="p">=</span> <span class="s">&quot;hello&quot;</span>
<span class="nx">any</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="s">&quot;one&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
<span class="nx">any</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span>
</pre></div>


<p>The empty interface type has been used in the very first example in this book, because it is what allows functions like <code>fmt.Println</code>, or <code>errorf</code> in <a href="../ch5/#anonymous-functions">Section 5.7</a>, to accept arguments of any type.</p>
<p>Having created an <code>interface{}</code> value containing a boolean, float, string, map, pointer, or any other type, we can do nothing directly to the value it holds since the interface has no methods. We need a way to get the value back out again, which can be done using a type assertion, discussed in <a href="#type-assertions">Section 7.10</a>.</p>
<p>Since interface satisfaction depends only on the methods of the two types involved, there is no need to declare the relationship between a concrete type and the interfaces it satisfies. However, it is occasionally useful to document and assert the relationship when it is intended but not otherwise enforced by the program. The declaration below asserts at compile time that a value of type <code>*bytes.Buffer</code> satisfies <code>io.Writer</code>:</p>
<div class="codehilite"><pre><span class="c1">// *bytes.Buffer must satisfy io.Writer</span>
<span class="kd">var</span> <span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span>
</pre></div>


<p>We needn't allocate a new variable since any value of type <code>*bytes.Buffer</code> will do, even <code>nil</code>, which we write as <code>(*bytes.Buffer)(nil)</code> using an explicit conversion. Since we never intend to refer to <code>w</code>, we can replace it with the blank identifier, which makes more frugal variant:</p>
<div class="codehilite"><pre><span class="c1">// *bytes.Buffer must satisfy io.Writer</span>
<span class="kd">var</span> <span class="nx">_</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)(</span><span class="kc">nil</span><span class="p">)</span>
</pre></div>


<p>Non-empty interface types such as <code>io.Writer</code> are most often satisfied by a pointer type, particularly when one or more of the interface methods implies some kind of mutation to the receiver, as the <code>Write</code> method does. A pointer to a struct is an especially common method-bearing type.</p>
<p>Pointer types are not the only types that satisfy interfaces, and even interfaces with mutator methods may be satisfied by other reference types. For example:</p>
<ul>
<li>Slice types with methods (<code>geometry.Path</code>, <a href="../ch6/#method-declarations">Section 6.1</a>)</li>
<li>Map types with methods (<code>url.Values</code>, <a href="../ch6/#nil-is-a-valid-receiver-value">Section 6.2.1</a>),</li>
<li>Function type with methods (<code>http.HandlerFunc</code>, <a href="#the-httphandler-interface">Section 7.7</a>).</li>
<li>Even basic types may satisfy interfaces: in <a href="#parsing-flags-with-flagvalue">Section 7.4</a>, <code>time.Duration</code> satisfies <code>fmt.Stringer</code>.</li>
</ul>
<p>A concrete type may satisfy many unrelated interfaces. For example, a program that organizes or sells digitized cultural artifacts might define the following set of concrete types:</p>
<div class="codehilite"><pre>Album
Book
Movie
Magazine
Podcast
TVEpisode
Track
</pre></div>


<p>Each abstraction of interest can be expressed as an interface. Some properties are common to all artifacts, such as a title, a creation date, and a list of creators (authors or artists).</p>
<div class="codehilite"><pre><span class="kd">type</span> <span class="nx">Artifact</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Title</span><span class="p">()</span> <span class="kt">string</span>
    <span class="nx">Creators</span><span class="p">()</span> <span class="p">[]</span><span class="kt">string</span>
    <span class="nx">Created</span><span class="p">()</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
<span class="p">}</span>
</pre></div>


<p>Other properties are restricted to certain types of artifacts. Properties of the printed word are relevant only to books and magazines, whereas only movies and TV episodes have a screen resolution.</p>
<div class="codehilite"><pre><span class="kd">type</span> <span class="nx">Text</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Pages</span><span class="p">()</span> <span class="kt">int</span>
    <span class="nx">Words</span><span class="p">()</span> <span class="kt">int</span>
    <span class="nx">PageSize</span><span class="p">()</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Audio</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Stream</span><span class="p">()</span> <span class="p">(</span><span class="nx">io</span><span class="p">.</span><span class="nx">ReadCloser</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
    <span class="nx">RunningTime</span><span class="p">()</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
    <span class="nx">Format</span><span class="p">()</span> <span class="kt">string</span> <span class="c1">// e.g., &quot;MP3&quot;, &quot;WAV&quot;</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Video</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Stream</span><span class="p">()</span> <span class="p">(</span><span class="nx">io</span><span class="p">.</span><span class="nx">ReadCloser</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
  <span class="nx">RunningTime</span><span class="p">()</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
  <span class="nx">Format</span><span class="p">()</span> <span class="kt">string</span> <span class="c1">// e.g., &quot;MP4&quot;, &quot;WMV&quot;</span>
  <span class="nx">Resolution</span><span class="p">()</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>These interfaces are not the only useful way to group related concrete types together and express the facets they share in common. We may discover other groupings later. For example, if we find we need to handle <code>Audio</code> and <code>Video</code> items in the same way, we can define a <code>Streamer</code> interface to represent their common aspects without changing any existing type declarations.</p>
<div class="codehilite"><pre><span class="kd">type</span> <span class="nx">Streamer</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Stream</span><span class="p">()</span> <span class="p">(</span><span class="nx">io</span><span class="p">.</span><span class="nx">ReadCloser</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
    <span class="nx">RunningTime</span><span class="p">()</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
    <span class="nx">Format</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
</pre></div>


<p>Each grouping of concrete types based on their shared behaviors can be expressed as an interface type. Unlike class-based languages, in which the set of interfaces satisfied by a class is explicit, in Go we can define new abstractions or groupings of interest when we need them, without modifying the declaration of the concrete type. This is particularly useful when the concrete type comes from a package written by a different author. Of course, there do need to be underlying commonalities in the concrete types.</p>
<h3 id="parsing-flags-with-flagvalue">Parsing Flags with <code>flag.Value</code><a class="headerlink" href="#parsing-flags-with-flagvalue" title="Permanent link">&para;</a></h3>
<p>This section discusses another standard interface, <code>flag.Value</code>, which enables us to define new notations for command-line flags. For example, the following program sleeps for a specified period of time:</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch7/sleep/sleep.go">gopl.io/ch7/sleep/sleep.go</a></small></p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">period</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nx">Duration</span><span class="p">(</span><span class="s">&quot;period&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span> <span class="s">&quot;sleep period&quot;</span><span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">flag</span><span class="p">.</span><span class="nx">Parse</span><span class="p">()</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;Sleeping for %v...&quot;</span><span class="p">,</span> <span class="o">*</span><span class="nx">period</span><span class="p">)</span>
    <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="o">*</span><span class="nx">period</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>


<p>Before it goes to sleep it prints the time period. The <code>fmt</code> package calls the <code>time.Duration</code>'s <code>String</code> method to print the period in a user-friendly notation instead of <a href="../ch6/#other-aspects-of-encapsulation">a number of nanoseconds</a>:</p>
<div class="codehilite"><pre><span class="gp">$</span> go build gopl.io/ch7/sleep
<span class="gp">$</span> ./sleep
<span class="go">Sleeping for 1s...</span>
</pre></div>


<ul>
<li>By default, the sleep period is one second, but it can be controlled through the <code>-period</code> command-line flag.</li>
<li>The <code>flag.Duratio</code> function creates a flag variable of type <code>time.Duration</code> and allows the user to specify the duration in a variety of user-friendly formats, including the same notation printed by the <code>String</code> method. This symmetry of design leads to a nice user interface.</li>
</ul>
<div class="codehilite"><pre><span class="gp">$</span> ./sleep -period 50ms
<span class="go">Sleeping for 50ms...</span>
<span class="gp">$</span> ./sleep -period 2m30s
<span class="go">Sleeping for 2m30s...</span>
<span class="gp">$</span> ./sleep -period 1.5h
<span class="go">Sleeping for 1h30m0s...</span>
<span class="gp">$</span> ./sleep -period <span class="s2">&quot;1 day&quot;</span>
<span class="go">invalid value &quot;1 day&quot; for flag -period: time: invalid duration 1 day</span>
</pre></div>


<p>It's easy to define new flag notations for our own data types. We need only define a type that satisfies the <code>flag.Value</code> interface, whose declaration is:</p>
<div class="codehilite"><pre><span class="kn">package</span> <span class="nx">flag</span>

<span class="c1">// Value is the interface to the value stored in a flag.</span>
<span class="kd">type</span> <span class="nx">Value</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span>
    <span class="nx">Set</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span> <span class="kt">error</span>
<span class="p">}</span>
</pre></div>


<ul>
<li>The <code>String</code> method formats the flags' value for use in command-line help messages; thus every <code>flag.Value</code> is also a <code>fmt.Stringer</code>.</li>
<li>The <code>Set</code> method parses its string argument and updates the flag value. In effect, the <code>Set</code> method is the inverse of the <code>String</code> method, and it is good practice for them to use the same notation.</li>
</ul>
<p>The following example defines a <code>celsiusFlag</code> type that allows a temperature to be specified in Celsius, or in Fahrenheit with an appropriate conversion. Notice that <code>celsiusFlag</code> embeds a <code>Celsius</code> (<a href="../ch2/#type-declarations">Section 2.5</a>), thereby getting a <code>String</code> method for free. To satisfy <code>flag.Value</code>, we need only declare the Set method:</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch7/tempconv/tempconv.go">gopl.io/ch7/tempconv/tempconv.go</a></small></p>
<div class="codehilite"><pre><span class="kd">type</span> <span class="nx">celsiusFlag</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">Celsius</span> <span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">celsiusFlag</span><span class="p">)</span> <span class="nx">Set</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">unit</span> <span class="kt">string</span>
    <span class="kd">var</span> <span class="nx">value</span> <span class="kt">float64</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sscanf</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&quot;%f%s&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">value</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">unit</span><span class="p">)</span> <span class="c1">// no error check needed</span>
    <span class="k">switch</span> <span class="nx">unit</span> <span class="p">{</span>
    <span class="k">case</span> <span class="s">&quot;C&quot;</span><span class="p">,</span> <span class="s">&quot;°C&quot;</span><span class="p">:</span>
        <span class="nx">f</span><span class="p">.</span><span class="nx">Celsius</span> <span class="p">=</span> <span class="nx">Celsius</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">nil</span>
    <span class="k">case</span> <span class="s">&quot;F&quot;</span><span class="p">,</span> <span class="s">&quot;°F&quot;</span><span class="p">:</span>
        <span class="nx">f</span><span class="p">.</span><span class="nx">Celsius</span> <span class="p">=</span> <span class="nx">FToC</span><span class="p">(</span><span class="nx">Fahrenheit</span><span class="p">(</span><span class="nx">value</span><span class="p">))</span>
        <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;invalid temperature %q&quot;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>The call to <a href="https://golang.org/pkg/fmt/#Sscanf"><code>fmt.Sscanf</code></a> parses a floating-point number (<code>value</code>) and a string (<code>unit</code>) from the input <code>s</code>. Although one must usually check <code>Sscanf</code>'s error result, in this case we don't need to because if there was a problem, no switch case will match.</p>
<p>The <code>CelsiusFlag</code> function below wraps it all up.</p>
<div class="codehilite"><pre><span class="c1">// CelsiusFlag defines a Celsius flag with the specified name,</span>
<span class="c1">// default value, and usage, and returns the address of the flag variable.</span>
<span class="c1">// The flag argument must have a quantity and a unit, e.g., &quot;100C&quot;.</span>
<span class="kd">func</span> <span class="nx">CelsiusFlag</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">value</span> <span class="nx">Celsius</span><span class="p">,</span> <span class="nx">usage</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">Celsius</span> <span class="p">{</span>
    <span class="nx">f</span> <span class="o">:=</span> <span class="nx">celsiusFlag</span><span class="p">{</span><span class="nx">value</span><span class="p">}</span>
    <span class="nx">flag</span><span class="p">.</span><span class="nx">CommandLine</span><span class="p">.</span><span class="nx">Var</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">f</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">usage</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">f</span><span class="p">.</span><span class="nx">Celsius</span>
<span class="p">}</span>
</pre></div>


<ul>
<li>To the caller, it returns a pointer to the <code>Celsius</code> field embedded within the <code>celsiusFlag</code> variable <code>f</code>. The <code>Celsius</code> field is the variable that will be updated by the <code>Set</code> method during flags processing.</li>
<li>The call to <code>Var</code> adds the flag to the application's set of command-line flags, the global variable <code>flag.CommandLine</code>. Programs with complex command-line interfaces may have several variables of this type.</li>
<li><u>The call to <code>Var</code> assigns a <code>*celsiusFlag</code> argument to a <code>flag.Value</code> parameter, causing the compiler to check that <code>*celsiusFlag</code> has the necessary methods.</u> (See <a href="#interface-satisfaction">Section 7.3</a>)</li>
</ul>
<p>The following program uses <code>CelsiusFlag</code>:</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch7/tempflag/tempflag.go">gopl.io/ch7/tempflag/tempflag.go</a></small></p>
<div class="codehilite"><pre>var temp = tempconv.CelsiusFlag(&quot;temp&quot;, 20.0, &quot;the temperature&quot;)

func main() {
    flag.Parse()
    fmt.Println(*temp)
}
</pre></div>


<p>Run this program:</p>
<div class="codehilite"><pre><span class="gp">$</span> go build gopl.io/ch7/tempflag
<span class="gp">$</span> ./tempflag
<span class="go">20°C</span>
<span class="gp">$</span> ./tempflag -temp -18C
<span class="go">-18°C</span>
<span class="gp">$</span> ./tempflag -temp 212°F
<span class="go">100°C</span>
<span class="gp">$</span> ./tempflag -temp 273.15K
<span class="go">invalid value &quot;273.15K&quot; for flag -temp: invalid temperature &quot;273.15K&quot;</span>
<span class="go">Usage of ./tempflag:</span>
<span class="go">-temp value</span>
<span class="go">the temperature (default 20°C)</span>
<span class="gp">$</span> ./tempflag -help
<span class="go">Usage of ./tempflag:</span>
<span class="go">-temp value</span>
<span class="go">the temperature (default 20°C)</span>
</pre></div>


<h3 id="interface-values">Interface Values<a class="headerlink" href="#interface-values" title="Permanent link">&para;</a></h3>
<p>Conceptually, an <strong>interface value</strong> (a value of an interface type) has two components:</p>
<ul>
<li>A concrete type, called the interface's <em>dynamic type</em></li>
<li>A value of that type, called the interface's <em>dynamic value</em></li>
</ul>
<p>For a statically typed language like Go, types are a compile-time concept, so a type is not a value. In our conceptual model, a set of values called <em>type descriptors</em> provide information about each type, such as its name and methods. In an interface value, the type component is represented by the appropriate type descriptor.</p>
<p>In the four statements below, the variable <code>w</code> takes on three different values. (The initial and final values are the same.)</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span>
<span class="nx">w</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span>
<span class="nx">w</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span>
<span class="nx">w</span> <span class="p">=</span> <span class="kc">nil</span>
</pre></div>


<p>The first statement declares <code>w</code>:</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span>
</pre></div>


<p>In Go, variables are always initialized to a well-defined value, and interfaces are no exception.  The zero value for an interface has both its type and value components set to <code>nil</code> (see the figure below).</p>
<p><a href="../figure_7.1.png" title="Figure 7.1. A nil interface value."><img alt="Figure 7.1. A nil interface value." src="../figure_7.1.png" /></a></p>
<p>An interface value is described as nil or non-nil based on its dynamic type, so this is a nil interface value. You can test whether an interface value is nil using <code>w == nil</code> or <code>w != nil</code>. Calling any method of a nil interface value causes a panic:</p>
<div class="codehilite"><pre><span class="nx">w</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">))</span> <span class="c1">// panic: nil pointer dereference</span>
</pre></div>


<p>The second statement assigns a value of type <code>*os.File</code> to <code>w</code>:</p>
<div class="codehilite"><pre><span class="nx">w</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span>
</pre></div>


<p>This assignment involves an implicit conversion from a concrete type to an interface type, and is equivalent to the explicit conversion <code>io.Writer(os.Stdout)</code>. Such conversion, whether explicit or implicit, captures the type and the value of its operand. The interface value's dynamic type is set to the type descriptor for the pointer type <code>*os.File</code>, and its dynamic value holds a copy of <code>os.Stdout</code>, which is a pointer to the <code>os.File</code> variable representing the standard output of the process (see the figure below).</p>
<p><a href="../figure_7.2.png" title="Figure 7.2. An interface value containing an *os.File pointer."><img alt="Figure 7.2. An interface value containing an *os.File pointer." src="../figure_7.2.png" /></a></p>
<p>Calling the <code>Write</code> method on an interface value containing an <code>*os.File</code> pointer causes the <code>(*os.File).Write</code> method to be called, which prints "hello".</p>
<div class="codehilite"><pre><span class="nx">w</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">))</span> <span class="c1">// &quot;hello&quot;</span>
</pre></div>


<p>In general, we cannot know at compile time what the dynamic type of an interface value will be, so a call through an interface must use <a href="https://en.wikipedia.org/wiki/Dynamic_dispatch"><em>dynamic dispatch</em></a>. Instead of a direct call, the compiler must generate code to obtain the address of the method named <code>Write</code> from the type descriptor, then make an indirect call to that address. The receiver argument for the call is a copy of the interface's dynamic value,<code>os.Stdout</code>. The effect is as if we had made this call directly:</p>
<div class="codehilite"><pre><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">))</span> <span class="c1">// &quot;hello&quot;</span>
</pre></div>


<p>The third statement assigns a value of type <code>*bytes.Buffer</code> to the interface value:</p>
<div class="codehilite"><pre><span class="nx">w</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span>
</pre></div>


<p>The dynamic type is now <code>*bytes.Buffer</code> and the dynamic value is a pointer to the newly allocated buffer (see figure below).</p>
<p><a href="../figure_7.3.png" title="Figure 7.3. An interface value containing a *bytes.Buffer pointer."><img alt="Figure 7.3. An interface value containing a *bytes.Buffer pointer." src="../figure_7.3.png" /></a></p>
<p>A call to the <code>Write</code> method uses the same mechanism as before:</p>
<div class="codehilite"><pre><span class="nx">w</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">))</span> <span class="c1">// writes &quot;hello&quot; to the bytes.Buffer</span>
</pre></div>


<p>This time, the type descriptor is <code>*bytes.Buffer</code>, so the <code>(*bytes.Buffer).Write</code> method is called, with the address of the buffer as the value of the receiver parameter. The call appends "<code>hello</code>" to the buffer.</p>
<p>Finally, the fourth statement assigns <code>nil</code> to the interface value:</p>
<div class="codehilite"><pre><span class="nx">w</span> <span class="p">=</span> <span class="kc">nil</span>
</pre></div>


<p>This resets both its components to <code>nil</code>, restoring <code>w</code> to the same state as when it was declared, as shown in <a href="../figure_7.1.png">Figure 7.1</a>.</p>
<p>An interface value can hold arbitrarily large dynamic values. For example, the <code>time.Time</code>
type is a struct type with several unexported fields.</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">x</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">()</span>
</pre></div>


<p>This interface value is like the following figure:</p>
<p><a href="../figure_7.4.png" title="Figure 7.4. An interface value holding a time.Time struct."><img alt="Figure 7.4. An interface value holding a time.Time struct." src="../figure_7.4.png" /></a></p>
<p>Conceptually, the dynamic value always fits inside the interface value, no matter how large its type. Note that this is only a conceptual model; a realistic implementation is quite different.</p>
<p>Interface values may be compared using <code>==</code> and <code>!=</code>. Two interface values are equal if either of the following occurs:</p>
<ul>
<li>Both of them are nil.</li>
<li>Their dynamic types are identical and their dynamic values are equal according to the usual behavior of <code>==</code> for that type.</li>
</ul>
<p>Because interface values are comparable, they may be used as the keys of a map or as the operand of a switch statement. However, if two interface values are compared and have the same dynamic type, but that type is not comparable (e.g. slice), then the comparison fails with a panic:</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">x</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span> <span class="o">==</span> <span class="nx">x</span><span class="p">)</span> <span class="c1">// panic: comparing uncomparable type []int</span>
</pre></div>


<p>Therefore, interface types are unusual: interface values are comparable, but may panic, while other types are either safely comparable or not comparable at all:</p>
<ul>
<li>Safely comparable, such as basic types and pointers</li>
<li>Not comparable, such as slices, maps, and functions</li>
</ul>
<p>When comparing interface values or aggregate types that contain interface values, we must be aware of the potential for a panic. A similar risk exists when using interfaces as map keys or switch operands. <u>Only compare interface values if you are certain that they contain dynamic values of comparable types.</u></p>
<p>When handling errors, or during debugging, it is often helpful to report the dynamic type of an interface value, using the <code>fmt</code> package's <code>%T</code> verb:</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%T\n&quot;</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="c1">// &quot;&lt;nil&gt;&quot;</span>

<span class="nx">w</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%T\n&quot;</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="c1">// &quot;*os.File&quot;</span>

<span class="nx">w</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%T\n&quot;</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="c1">// &quot;*bytes.Buffer&quot;</span>
</pre></div>


<p>Internally, <code>fmt</code> uses reflection (<a href="../ch12/">Chapter 12</a>) to obtain the name of the interface's dynamic type.</p>
<h4 id="caveat-an-interface-containing-a-nil-pointer-is-non-nil">Caveat: An Interface Containing a Nil Pointer Is Non-Nil<a class="headerlink" href="#caveat-an-interface-containing-a-nil-pointer-is-non-nil" title="Permanent link">&para;</a></h4>
<p>A nil interface value, which contains no value at all, is not the same as an interface value containing a pointer that happens to be nil.</p>
<p>In the program below, when <code>debug</code> is set to <code>true</code>, the function collects the output of the function <code>f</code> in a <code>bytes.Buffer</code>.</p>
<div class="codehilite"><pre><span class="kd">const</span> <span class="nx">debug</span> <span class="p">=</span> <span class="kc">true</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">buf</span> <span class="o">*</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span>
    <span class="k">if</span> <span class="nx">debug</span> <span class="p">{</span>
        <span class="nx">buf</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span> <span class="c1">// enable collection of output</span>
    <span class="p">}</span>
    <span class="nx">f</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span> <span class="c1">// NOTE: subtly incorrect!</span>
    <span class="k">if</span> <span class="nx">debug</span> <span class="p">{</span>
        <span class="c1">// ...use buf...</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// If out is non-nil, output will be written to it.</span>
<span class="kd">func</span> <span class="nx">f</span><span class="p">(</span><span class="nx">out</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...do something...</span>
    <span class="k">if</span> <span class="nx">out</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">out</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&quot;done!\n&quot;</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>We might expect that changing <code>debug</code> to <code>false</code> would disable the collection of the output, but in fact it causes the program to panic during the <code>out.Write</code> call:</p>
<div class="codehilite"><pre><span class="k">if</span> <span class="nx">out</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">out</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&quot;done!\n&quot;</span><span class="p">))</span> <span class="c1">// panic: nil pointer dereference</span>
<span class="p">}</span>
</pre></div>


<p>When <code>main</code> calls <code>f</code>, it assigns a nil pointer of type <code>*bytes.Buffer</code> to the <code>out</code> parameter, so the dynamic value of <code>out</code> is <code>nil</code>. However, its dynamic type is <code>*bytes.Buffer</code>, meaning that <code>out</code> is a non-nil interface containing a nil pointer value (see figure below), so the defensive check <code>out != nil</code> is still true.</p>
<p><a href="../figure_7.5.png" title="Figure 7.5. A non-nil interface containing a nil pointer."><img alt="Figure 7.5. A non-nil interface containing a nil pointer." src="../figure_7.5.png" /></a></p>
<p>The dynamic dispatch mechanism determines that <code>(*bytes.Buffer).Write</code> must be called but this time with a receiver value that is nil. For some types, such as <code>*os.File</code>, nil is a valid receiver (<a href="../ch6/#nil-is-a-valid-receiver-value">Section 6.2.1</a>), but <code>*bytes.Buffer</code> is not among them. The method is called, but it panics as it tries to access the buffer.</p>
<p>The problem is that although a nil <code>*bytes.Buffer</code> pointer has the methods needed to satisfy the interface, it doesn't satisfy the <em>behavioral</em> requirements of the interface. In particular, the call violates the implicit precondition of <code>(*bytes.Buffer).Write</code> that its receiver is not nil, so assigning the nil pointer to the interface was a mistake. The solution is to change the type of <code>buf</code> in <code>main</code> to <code>io.Writer</code>, thereby avoiding the assignment of the dysfunctional value to the interface in the first place:</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">buf</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span>
<span class="k">if</span> <span class="nx">debug</span> <span class="p">{</span>
    <span class="nx">buf</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span> <span class="c1">// enable collection of output</span>
<span class="p">}</span>
<span class="nx">f</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span> <span class="c1">// OK</span>
</pre></div>


<h3 id="sorting-with-sortinterface">Sorting with <code>sort.Interface</code><a class="headerlink" href="#sorting-with-sortinterface" title="Permanent link">&para;</a></h3>
<p>Sorting is a frequently used operation in many programs. [p186]</p>
<p>In many languages, the sorting algorithm is associated with the sequence data type, while the ordering function is associated with the type of the elements.</p>
<p>In Go, the <a href="https://golang.org/pkg/sort/"><code>sort</code></a> package provides in-place sorting of any sequence according to any ordering function. However, its design is rather unusual:</p>
<ul>
<li><code>sort.Sort</code> function assumes nothing about the representation of either the sequence or its elements. Instead, it uses an interface, <code>sort.Interface</code>, to specify the contract between the generic sort algorithm and each sequence type that may be sorted.</li>
<li>An implementation of this interface determines both the concrete representation of the sequence, which is often a slice, and the desired ordering of its elements.</li>
</ul>
<p>An in-place sort algorithm needs three things:</p>
<ul>
<li>The length of the sequence</li>
<li>A means of comparing two elements</li>
<li>A way to swap two elements</li>
</ul>
<p>They are the three methods of <code>sort.Interface</code>:</p>
<div class="codehilite"><pre><span class="kn">package</span> <span class="nx">sort</span>

<span class="kd">type</span> <span class="nx">Interface</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Len</span><span class="p">()</span> <span class="kt">int</span>
    <span class="nx">Less</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="c1">// i, j are indices of sequence elements</span>
    <span class="nx">Swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>To sort any sequence, we need to define a type that implements these three methods, then apply <code>sort.Sort</code> to an instance of that type. For example, consider sorting a slice of strings. The new type <code>StringSlice</code> and its <code>Len</code>, <code>Less</code>, and <code>Swap</code> methods are shown below:</p>
<div class="codehilite"><pre><span class="kd">type</span> <span class="nx">StringSlice</span> <span class="p">[]</span><span class="kt">string</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">StringSlice</span><span class="p">)</span> <span class="nx">Len</span><span class="p">()</span> <span class="kt">int</span>           <span class="p">{</span> <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">StringSlice</span><span class="p">)</span> <span class="nx">Less</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">p</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">p</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">StringSlice</span><span class="p">)</span> <span class="nx">Swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span>      <span class="p">{</span> <span class="nx">p</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">p</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">p</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">p</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">}</span>
</pre></div>


<p>Now we can sort a slice of strings, <code>names</code>, by converting the slice to a <code>StringSlice</code> like this:</p>
<div class="codehilite"><pre><span class="nx">sort</span><span class="p">.</span><span class="nx">Sort</span><span class="p">(</span><span class="nx">StringSlice</span><span class="p">(</span><span class="nx">names</span><span class="p">))</span>
</pre></div>


<p>The conversion yields a slice value with the same length, capacity, and underlying array as <code>names</code> but with a type that has the three methods required for sorting.</p>
<p>Sorting a slice of strings is so common that the sort package provides the <code>StringSlice</code> type and a function called <code>Strings</code>. The call above can be simplified as:</p>
<div class="codehilite"><pre><span class="nx">sort</span><span class="p">.</span><span class="nx">Strings</span><span class="p">(</span><span class="nx">names</span><span class="p">)</span>
</pre></div>


<p>This technique can be easily adapted to other sort orders, for instance, to ignore capitalization or special characters. For more complicated sorting, we use the same idea, but with more complicated data structures or more complicated implementations of the <code>sort.Interface</code> methods.</p>
<h4 id="example-sorting-a-playlist">Example: sorting a playlist *<a class="headerlink" href="#example-sorting-a-playlist" title="Permanent link">&para;</a></h4>
<p>The following example is a music playlist, displayed as a table. Each track is a single row, and each column is an attribute of that track. The playlist can be sorted by any attribute in the columns.</p>
<p>The variable <code>tracks</code> below contains a playlist. Each element is indirect, a pointer to a <code>Track</code>. Although the code below would work if we stored the <code>Track</code>s directly, the <code>sort</code> function will swap many pairs of elements, so it will run faster if each element is a pointer, which is a single machine word, instead of an entire <code>Track</code>.</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch7/sorting/main.go">gopl.io/ch7/sorting/main.go</a></small></p>
<div class="codehilite"><pre><span class="kd">type</span> <span class="nx">Track</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Title</span>  <span class="kt">string</span>
    <span class="nx">Artist</span> <span class="kt">string</span>
    <span class="nx">Album</span>  <span class="kt">string</span>
    <span class="nx">Year</span>   <span class="kt">int</span>
    <span class="nx">Length</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">tracks</span> <span class="p">=</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Track</span><span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;Go&quot;</span><span class="p">,</span> <span class="s">&quot;Delilah&quot;</span><span class="p">,</span> <span class="s">&quot;From the Roots Up&quot;</span><span class="p">,</span> <span class="mi">2012</span><span class="p">,</span> <span class="nx">length</span><span class="p">(</span><span class="s">&quot;3m38s&quot;</span><span class="p">)},</span>
    <span class="p">{</span><span class="s">&quot;Go&quot;</span><span class="p">,</span> <span class="s">&quot;Moby&quot;</span><span class="p">,</span> <span class="s">&quot;Moby&quot;</span><span class="p">,</span> <span class="mi">1992</span><span class="p">,</span> <span class="nx">length</span><span class="p">(</span><span class="s">&quot;3m37s&quot;</span><span class="p">)},</span>
    <span class="p">{</span><span class="s">&quot;Go Ahead&quot;</span><span class="p">,</span> <span class="s">&quot;Alicia Keys&quot;</span><span class="p">,</span> <span class="s">&quot;As I Am&quot;</span><span class="p">,</span> <span class="mi">2007</span><span class="p">,</span> <span class="nx">length</span><span class="p">(</span><span class="s">&quot;4m36s&quot;</span><span class="p">)},</span>
    <span class="p">{</span><span class="s">&quot;Ready 2 Go&quot;</span><span class="p">,</span> <span class="s">&quot;Martin Solveig&quot;</span><span class="p">,</span> <span class="s">&quot;Smash&quot;</span><span class="p">,</span> <span class="mi">2011</span><span class="p">,</span> <span class="nx">length</span><span class="p">(</span><span class="s">&quot;4m24s&quot;</span><span class="p">)},</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">length</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span> <span class="p">{</span>
    <span class="nx">d</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">ParseDuration</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">d</span>
<span class="p">}</span>
</pre></div>


<p>The <code>printTracks</code> function prints the playlist as a table. It uses the <a href="https://golang.org/pkg/text/tabwriter/"><code>text/tabwriter</code></a> package to produce a table whose columns are neatly aligned and padded.</p>
<ul>
<li><code>*tabwriter.Writer</code> satisfies <code>io.Writer</code>.</li>
<li>It collects each piece of data written to it.</li>
<li>Its <code>Flush</code> method formats the entire table and writes it to <code>os.Stdout</code>.</li>
</ul>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">printTracks</span><span class="p">(</span><span class="nx">tracks</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Track</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">format</span> <span class="p">=</span> <span class="s">&quot;%v\t%v\t%v\t%v\t%v\t\n&quot;</span>
    <span class="nx">tw</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">tabwriter</span><span class="p">.</span><span class="nx">Writer</span><span class="p">).</span><span class="nx">Init</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">tw</span><span class="p">,</span> <span class="nx">format</span><span class="p">,</span> <span class="s">&quot;Title&quot;</span><span class="p">,</span> <span class="s">&quot;Artist&quot;</span><span class="p">,</span> <span class="s">&quot;Album&quot;</span><span class="p">,</span> <span class="s">&quot;Year&quot;</span><span class="p">,</span> <span class="s">&quot;Length&quot;</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">tw</span><span class="p">,</span> <span class="nx">format</span><span class="p">,</span> <span class="s">&quot;-----&quot;</span><span class="p">,</span> <span class="s">&quot;------&quot;</span><span class="p">,</span> <span class="s">&quot;-----&quot;</span><span class="p">,</span> <span class="s">&quot;----&quot;</span><span class="p">,</span> <span class="s">&quot;------&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">t</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tracks</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">tw</span><span class="p">,</span> <span class="nx">format</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Title</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Artist</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Album</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Year</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Length</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">tw</span><span class="p">.</span><span class="nx">Flush</span><span class="p">()</span> <span class="c1">// calculate column widths and print table</span>
<span class="p">}</span>
</pre></div>


<p>To sort the playlist by the <code>Artist</code> field, we define a new slice type with the necessary <code>Len</code>, <code>Less</code>, and <code>Swap</code> methods, similar to the <code>StringSlice</code> example.</p>
<div class="codehilite"><pre><span class="kd">type</span> <span class="nx">byArtist</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Track</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="nx">byArtist</span><span class="p">)</span> <span class="nx">Len</span><span class="p">()</span> <span class="kt">int</span>           <span class="p">{</span> <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="nx">byArtist</span><span class="p">)</span> <span class="nx">Less</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Artist</span> <span class="p">&lt;</span> <span class="nx">x</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">Artist</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="nx">byArtist</span><span class="p">)</span> <span class="nx">Swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span>      <span class="p">{</span> <span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">x</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">x</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">}</span>
</pre></div>


<p>To call the generic <code>sort</code> routine, we must first convert tracks to the new type, <code>byArtist</code>, that defines the order:</p>
<div class="codehilite"><pre><span class="nx">sort</span><span class="p">.</span><span class="nx">Sort</span><span class="p">(</span><span class="nx">byArtist</span><span class="p">(</span><span class="nx">tracks</span><span class="p">))</span>
</pre></div>


<p>After sorting the slice by artist, the output from <code>printTracks</code> is:</p>
<div class="codehilite"><pre>Title       Artist          Album              Year  Length
-----       ------          -----              ----  ------
Go Ahead    Alicia Keys     As I Am            2007  4m36s
Go          Delilah         From the Roots Up  2012  3m38s
Ready 2 Go  Martin Solveig  Smash              2011  4m24s
Go          Moby            Moby               1992  3m37s
</pre></div>


<p>To sort by artist in reverse order, we needn't define a new type <code>byReverseArtist</code> with an inverted <code>Less</code> method. The <code>sort</code> package provides a <a href="https://golang.org/pkg/sort/#Reverse"><code>Reverse</code></a> function that transforms any sort order to its inverse.</p>
<div class="codehilite"><pre><span class="nx">sort</span><span class="p">.</span><span class="nx">Sort</span><span class="p">(</span><span class="nx">sort</span><span class="p">.</span><span class="nx">Reverse</span><span class="p">(</span><span class="nx">byArtist</span><span class="p">(</span><span class="nx">tracks</span><span class="p">)))</span>
</pre></div>


<p>The <code>sort.Reverse</code> function uses composition (<a href="../ch6/#composing-types-by-struct-embedding">Section 6.3</a>), which is an important idea. The <code>sort</code> package defines an unexported type <code>reverse</code>, which is a struct that embeds a <code>sort.Interface</code>. The <code>Less</code> method for <code>reverse</code> calls the <code>Less</code> method of the embedded <code>sort.Interface</code> value, but with the indices flipped, reversing the order of the sort results.</p>
<div class="codehilite"><pre><span class="kn">package</span> <span class="nx">sort</span>
<span class="kd">type</span> <span class="nx">reverse</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">Interface</span> <span class="p">}</span> <span class="c1">// that is, sort.Interface</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="nx">reverse</span><span class="p">)</span> <span class="nx">Less</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Interface</span><span class="p">.</span><span class="nx">Less</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">Reverse</span><span class="p">(</span><span class="nx">data</span> <span class="nx">Interface</span><span class="p">)</span> <span class="nx">Interface</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">reverse</span><span class="p">{</span><span class="nx">data</span><span class="p">}</span> <span class="p">}</span>
</pre></div>


<p><code>Len</code> and <code>Swap</code>, the other two methods of <code>reverse</code>, are implicitly provided by the original <code>sort.Interface</code> value because it is an embedded field. The exported function <code>Reverse</code> returns an instance of the reverse type that contains the original <code>sort.Interface</code> value.</p>
<p>To sort by a different column, we must define a new type, such as <code>byYear</code>:</p>
<div class="codehilite"><pre><span class="kd">type</span> <span class="nx">byYear</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Track</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="nx">byYear</span><span class="p">)</span> <span class="nx">Len</span><span class="p">()</span> <span class="kt">int</span>           <span class="p">{</span> <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="nx">byYear</span><span class="p">)</span> <span class="nx">Less</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Year</span> <span class="p">&lt;</span> <span class="nx">x</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">Year</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="nx">byYear</span><span class="p">)</span> <span class="nx">Swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span>      <span class="p">{</span> <span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">x</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">x</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">}</span>
</pre></div>


<p>Similarly, sort <code>tracks</code> by year using <code>sort.Sort(byYear(tracks))</code>.</p>
<p>For every slice element type and every ordering function we need, we declare a new implementation of <code>sort.Interface</code>; the <code>Len</code> and <code>Swap</code> methods have identical definitions for all slice types.</p>
<p>In the following example, the concrete type <code>customSort</code> combines a slice with a function, so we can define a new sort order by writing only the comparison function. Incidentally, the concrete types that implement <code>sort.Interface</code> are not always slices; <code>customSort</code> is a struct type.</p>
<div class="codehilite"><pre><span class="kd">type</span> <span class="nx">customSort</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">t</span>    <span class="p">[]</span><span class="o">*</span><span class="nx">Track</span>
    <span class="nx">less</span> <span class="kd">func</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">*</span><span class="nx">Track</span><span class="p">)</span> <span class="kt">bool</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="nx">customSort</span><span class="p">)</span> <span class="nx">Len</span><span class="p">()</span> <span class="kt">int</span>           <span class="p">{</span> <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">t</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="nx">customSort</span><span class="p">)</span> <span class="nx">Less</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span><span class="p">.</span><span class="nx">less</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">x</span><span class="p">.</span><span class="nx">t</span><span class="p">[</span><span class="nx">j</span><span class="p">])</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="nx">customSort</span><span class="p">)</span> <span class="nx">Swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span>      <span class="p">{</span> <span class="nx">x</span><span class="p">.</span><span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">x</span><span class="p">.</span><span class="nx">t</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">x</span><span class="p">.</span><span class="nx">t</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">x</span><span class="p">.</span><span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">}</span>
</pre></div>


<p>The following code defines a multi-tier ordering function whose primary sort key is the <code>Title</code>, secondary key is the <code>Year</code>, and tertiary key is the running time, <code>Length</code>. This is the call to <code>Sort</code> using an anonymous ordering function:</p>
<div class="codehilite"><pre><span class="nx">sort</span><span class="p">.</span><span class="nx">Sort</span><span class="p">(</span><span class="nx">customSort</span><span class="p">{</span><span class="nx">tracks</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">*</span><span class="nx">Track</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">x</span><span class="p">.</span><span class="nx">Title</span> <span class="o">!=</span> <span class="nx">y</span><span class="p">.</span><span class="nx">Title</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">x</span><span class="p">.</span><span class="nx">Title</span> <span class="p">&lt;</span> <span class="nx">y</span><span class="p">.</span><span class="nx">Title</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">x</span><span class="p">.</span><span class="nx">Year</span> <span class="o">!=</span> <span class="nx">y</span><span class="p">.</span><span class="nx">Year</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">x</span><span class="p">.</span><span class="nx">Year</span> <span class="p">&lt;</span> <span class="nx">y</span><span class="p">.</span><span class="nx">Year</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">x</span><span class="p">.</span><span class="nx">Length</span> <span class="o">!=</span> <span class="nx">y</span><span class="p">.</span><span class="nx">Length</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">x</span><span class="p">.</span><span class="nx">Length</span> <span class="p">&lt;</span> <span class="nx">y</span><span class="p">.</span><span class="nx">Length</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">false</span>
<span class="p">}})</span>
</pre></div>


<p>[p190]</p>
<p>Although sorting a sequence of length <em>n</em> requires O(<em>n</em> log <em>n</em>) comparison operations, testing whether a sequence is already sorted requires at most <em>n</em>−1 comparisons. The <a href="https://golang.org/pkg/sort/#IsSorted"><code>IsSorted</code></a> function from the <code>sort</code> package checks this for us. Like <code>sort.Sort</code>, it abstracts both the sequence and its ordering function using <code>sort.Interface</code>, but it never calls the <code>Swap</code> method.</p>
<p>The following code demonstrates the <a href="https://golang.org/pkg/sort/#IntsAreSorted"><code>IntsAreSorted</code></a> and <a href="https://golang.org/pkg/sort/#Ints"><code>Ints</code></a> functions and the <a href="https://golang.org/pkg/sort/#IntSlice"><code>IntSlice</code></a> type from the <code>sort</code> package:</p>
<div class="codehilite"><pre><span class="nx">values</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">sort</span><span class="p">.</span><span class="nx">IntsAreSorted</span><span class="p">(</span><span class="nx">values</span><span class="p">))</span> <span class="c1">// &quot;false&quot;</span>
<span class="nx">sort</span><span class="p">.</span><span class="nx">Ints</span><span class="p">(</span><span class="nx">values</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">values</span><span class="p">)</span>                     <span class="c1">// &quot;[1 1 3 4]&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">sort</span><span class="p">.</span><span class="nx">IntsAreSorted</span><span class="p">(</span><span class="nx">values</span><span class="p">))</span> <span class="c1">// &quot;true&quot;</span>
<span class="nx">sort</span><span class="p">.</span><span class="nx">Sort</span><span class="p">(</span><span class="nx">sort</span><span class="p">.</span><span class="nx">Reverse</span><span class="p">(</span><span class="nx">sort</span><span class="p">.</span><span class="nx">IntSlice</span><span class="p">(</span><span class="nx">values</span><span class="p">)))</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">values</span><span class="p">)</span>                     <span class="c1">// &quot;[4 3 1 1]&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">sort</span><span class="p">.</span><span class="nx">IntsAreSorted</span><span class="p">(</span><span class="nx">values</span><span class="p">))</span> <span class="c1">// &quot;false&quot;</span>
</pre></div>


<p>For convenience, the <code>sort</code> package provides versions of its functions and types specialized for <code>[]int</code>, <code>[]string</code>, and <code>[]float64</code> using their natural orderings. For other types, such as <code>[]int64</code> or <code>[]uint</code>, we need to write types on our own, though the path is short.</p>
<h3 id="the-httphandler-interface">The <code>http.Handler</code> Interface<a class="headerlink" href="#the-httphandler-interface" title="Permanent link">&para;</a></h3>
<p>Chapter 1 discusses how to use the <a href="https://golang.org/pkg/net/http/"><code>net/http</code></a> package to implement web clients (<a href="../ch1/#fetching-a-url">Section 1.5</a>) and servers (<a href="../ch1/#a-web-server">Section 1.7</a>). This section focuses on server API, whose foundation is the <code>http.Handler</code> interface:</p>
<div class="codehilite"><pre><span class="kn">package</span> <span class="nx">http</span>

<span class="kd">type</span> <span class="nx">Handler</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">ServeHTTP</span><span class="p">(</span><span class="nx">w</span> <span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">ListenAndServe</span><span class="p">(</span><span class="nx">address</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">h</span> <span class="nx">Handler</span><span class="p">)</span> <span class="kt">error</span>
</pre></div>


<p>The <code>ListenAndServe</code> function requires two arguments:</p>
<ul>
<li>A server address, such as "localhost:8000"</li>
<li>An instance of the <code>Handler</code> interface, to which all requests should be dispatched.</li>
</ul>
<p>This function runs forever, or until the server fails or fails to start; when it fails, it always returns an non-nil error.</p>
<p>The program of the following example shows the simplest implementation of an e-commerce site with a database mapping the items for sale to their prices in dollars. It models the inventory as a map type, <code>database</code>, to which we've attached a <code>ServeHTTP</code> method so that it satisfies the <code>http.Handler</code> interface. The handler ranges over the map and prints the items.</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch7/http1/main.go">gopl.io/ch7/http1/main.go</a></small></p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">db</span> <span class="o">:=</span> <span class="nx">database</span><span class="p">{</span><span class="s">&quot;shoes&quot;</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span> <span class="s">&quot;socks&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">}</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">ListenAndServe</span><span class="p">(</span><span class="s">&quot;localhost:8000&quot;</span><span class="p">,</span> <span class="nx">db</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">dollars</span> <span class="kt">float32</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="nx">dollars</span><span class="p">)</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;$%.2f&quot;</span><span class="p">,</span> <span class="nx">d</span><span class="p">)</span> <span class="p">}</span>

<span class="kd">type</span> <span class="nx">database</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">dollars</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="nx">database</span><span class="p">)</span> <span class="nx">ServeHTTP</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">price</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">db</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&quot;%s: %s\n&quot;</span><span class="p">,</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">price</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>If we start the server:</p>
<div class="codehilite"><pre><span class="gp">$</span> go build gopl.io/ch7/http1
<span class="gp">$</span> ./http1 <span class="p">&amp;</span>
</pre></div>


<p>Then connect to it with the <code>fetch</code> program from <a href="../ch1/#fetching-a-url">Section 1.5</a> (or a web browser if you prefer), we get the following output:</p>
<div class="codehilite"><pre>$ go build gopl.io/ch1/fetch
$ ./fetch http://localhost:8000
shoes: $50.00
socks: $5.00
</pre></div>


<p>The following program shows a more realistic server that defines multiple different URLs, each triggering a different behavior. It names the existing one <code>/list</code> and adds another one called <code>/price</code> that reports the price of a single item, specified as a request parameter like <code>/price?item=socks</code>.</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch7/http2/main.go">gopl.io/ch7/http2/main.go</a></small></p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="nx">database</span><span class="p">)</span> <span class="nx">ServeHTTP</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="nx">req</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nx">Path</span> <span class="p">{</span>
    <span class="k">case</span> <span class="s">&quot;/list&quot;</span><span class="p">:</span>
        <span class="k">for</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">price</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">db</span> <span class="p">{</span>
            <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&quot;%s: %s\n&quot;</span><span class="p">,</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">price</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="k">case</span> <span class="s">&quot;/price&quot;</span><span class="p">:</span>
        <span class="nx">item</span> <span class="o">:=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nx">Query</span><span class="p">().</span><span class="nx">Get</span><span class="p">(</span><span class="s">&quot;item&quot;</span><span class="p">)</span>
        <span class="nx">price</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">[</span><span class="nx">item</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
            <span class="nx">w</span><span class="p">.</span><span class="nx">WriteHeader</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusNotFound</span><span class="p">)</span> <span class="c1">// 404</span>
            <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&quot;no such item: %q\n&quot;</span><span class="p">,</span> <span class="nx">item</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="p">}</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&quot;%s\n&quot;</span><span class="p">,</span> <span class="nx">price</span><span class="p">)</span>
    <span class="k">default</span><span class="p">:</span>
        <span class="nx">w</span><span class="p">.</span><span class="nx">WriteHeader</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusNotFound</span><span class="p">)</span> <span class="c1">// 404</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&quot;no such page: %s\n&quot;</span><span class="p">,</span> <span class="nx">req</span><span class="p">.</span><span class="nx">URL</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>The handler above decides what logic to execute based on the path component of the URL, <code>req.URL.Path</code>. If the handler doesn't recognize the path, it reports an HTTP error to the client by calling <code>w.WriteHeader(http.StatusNotFound)</code>; this must be done before writing any text to <code>w</code>. <code>http.ResponseWriter</code> is another interface, which augments <code>io.Writer</code> with methods for sending HTTP response headers. Equivalently, we could use the <code>http.Error</code> utility function:</p>
<div class="codehilite"><pre><span class="nx">msg</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;no such page: %s\n&quot;</span><span class="p">,</span> <span class="nx">req</span><span class="p">.</span><span class="nx">URL</span><span class="p">)</span>
<span class="nx">http</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">msg</span><span class="p">,</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusNotFound</span><span class="p">)</span> <span class="c1">// 404</span>
</pre></div>


<p>The case for <code>/price</code> calls the URL's <code>Query</code> method to parse the HTTP request parameters as a map, or more precisely, a multimap of type <code>url.Values</code> (<a href="../ch6/#nil-is-a-valid-receiver-value">Section 6.2.1</a>) from the <code>net/url</code> package. It then finds the first item parameter and looks up its price. If the item wasn't found, it reports an error.</p>
<p>The following is an example session with the new server:</p>
<div class="codehilite"><pre>$ go build gopl.io/ch7/http2
$ go build gopl.io/ch1/fetch
$ ./http2 &amp;
$ ./fetch http://localhost:8000/list
shoes: $50.00
socks: $5.00
$ ./fetch http://localhost:8000/price?item=socks
$5.00
$ ./fetch http://localhost:8000/price?item=shoes
$50.00
$ ./fetch http://localhost:8000/price?item=hat
no such item: &quot;hat&quot;
$ ./fetch http://localhost:8000/help
no such page: /help
</pre></div>


<p>In a realistic application:</p>
<ol>
<li>It's convenient to define the logic for each case in a separate function or method.</li>
<li>Related URLs may need similar logic. For instance, several image files may have URLs of the form <code>/images/*.png</code>.</li>
</ol>
<p>For these reasons, <code>net/http</code> provides <a href="https://golang.org/pkg/net/http/#ServeMux"><code>ServeMux</code></a>, a <em>request multiplexer</em>, to simplify the association between URLs and handlers. A <code>ServeMux</code> aggregates a collection of <code>http.Handler</code>s into a single <code>http.Handler</code>. We see that different types satisfying the same interface are <em>substitutable</em>: the web server can dispatch requests to any <code>http.Handler</code>, regardless of which concrete type is behind it.</p>
<p>For a more complex application, several <code>ServeMux</code>es may be composed to handle more intricate dispatching requirements. [p193]</p>
<p>The program below does the following:</p>
<ol>
<li>It creates a <code>ServeMux</code> and use it to associate the URLs with the corresponding handlers for the <code>/list</code> and <code>/price</code> operations, which have been split into separate methods.</li>
<li>It then uses the <code>ServeMux</code> as the main handler in the call to <code>ListenAndServe</code>.</li>
</ol>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch7/http3/main.go">gopl.io/ch7/http3/main.go</a></small></p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">db</span> <span class="o">:=</span> <span class="nx">database</span><span class="p">{</span><span class="s">&quot;shoes&quot;</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span> <span class="s">&quot;socks&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">}</span>
    <span class="nx">mux</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">NewServeMux</span><span class="p">()</span>
    <span class="nx">mux</span><span class="p">.</span><span class="nx">Handle</span><span class="p">(</span><span class="s">&quot;/list&quot;</span><span class="p">,</span> <span class="nx">http</span><span class="p">.</span><span class="nx">HandlerFunc</span><span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">list</span><span class="p">))</span>
    <span class="nx">mux</span><span class="p">.</span><span class="nx">Handle</span><span class="p">(</span><span class="s">&quot;/price&quot;</span><span class="p">,</span> <span class="nx">http</span><span class="p">.</span><span class="nx">HandlerFunc</span><span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">price</span><span class="p">))</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">ListenAndServe</span><span class="p">(</span><span class="s">&quot;localhost:8000&quot;</span><span class="p">,</span> <span class="nx">mux</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">database</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">dollars</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="nx">database</span><span class="p">)</span> <span class="nx">list</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">price</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">db</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&quot;%s: %s\n&quot;</span><span class="p">,</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">price</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="nx">database</span><span class="p">)</span> <span class="nx">price</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">item</span> <span class="o">:=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nx">Query</span><span class="p">().</span><span class="nx">Get</span><span class="p">(</span><span class="s">&quot;item&quot;</span><span class="p">)</span>
    <span class="nx">price</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">[</span><span class="nx">item</span><span class="p">]</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
        <span class="nx">w</span><span class="p">.</span><span class="nx">WriteHeader</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusNotFound</span><span class="p">)</span> <span class="c1">// 404</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&quot;no such item: %q\n&quot;</span><span class="p">,</span> <span class="nx">item</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&quot;%s\n&quot;</span><span class="p">,</span> <span class="nx">price</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>The two calls to <code>mux.Handle</code> register the handlers. In the first one, <code>db.list</code> is a method value (<a href="../ch6/#method-values-and-expressions">Section 6.4</a>), which is a value of the following type:</p>
<div class="codehilite"><pre><span class="kd">func</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span>
</pre></div>


<p>When <code>db.list</code> is called, it invokes the <code>database.list</code> method with the receiver value <code>db</code>. So <code>db.list</code> is a function that implements handler-like behavior, but since it has no methods, it doesn't satisfy the <code>http.Handler</code> interface and can't be passed directly to <code>mux.Handle</code>. The expression <code>http.HandlerFunc(db.list)</code> is a conversion, not a function call, since <a href="https://golang.org/pkg/net/http/#HandlerFunc"><code>http.HandlerFunc</code></a> is a type. It has the following definition:</p>
<div class="codehilite"><pre><span class="kn">package</span> <span class="nx">http</span>

<span class="kd">type</span> <span class="nx">HandlerFunc</span> <span class="kd">func</span><span class="p">(</span><span class="nx">w</span> <span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">HandlerFunc</span><span class="p">)</span> <span class="nx">ServeHTTP</span><span class="p">(</span><span class="nx">w</span> <span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">f</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>As a demonstration of some unusual features of Go's interface mechanism, <u><code>HandlerFunc</code> is a function type that has methods and satisfies an interface, <code>http.Handler</code>. The behavior of its <code>ServeHTTP</code> method is to call the underlying function. <code>HandlerFunc</code> is thus an adapter that lets a function value satisfy an interface, where the function and the interface's sole method have the same signature.</u> In effect, this trick enables a single type such as <code>database</code> to satisfy the <code>http.Handler</code> interface in several different ways: once through its <code>list</code> method, once through its <code>price</code> method, and so on.</p>
<p>Because registering a handler this way is so common, <code>ServeMux</code> has a convenience method <code>HandleFunc</code> simplify the handler registration code:</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch7/http3a/main.go">gopl.io/ch7/http3a/main.go</a></small></p>
<div class="codehilite"><pre>mux.HandleFunc(&quot;/list&quot;, db.list)
mux.HandleFunc(&quot;/price&quot;, db.price)
</pre></div>


<p>We could also construct a program in which there are two different web servers, listening on different ports, defining different URLs, and dispatching to different handlers. This can be done by constructing another <code>ServeMux</code> and make another call to <code>ListenAndServe</code> perhaps concurrently. [p195]</p>
<p>For convenience, <code>net/http</code> provides a global <code>ServeMux</code> instance called <code>DefaultServeMux</code> and package-level functions called <code>http.Handle</code> and <code>http.HandleFunc</code>. To use <code>DefaultServeMux</code> as the server's main handler, we needn't pass it to <code>ListenAndServe</code>; <code>nil</code> will do.</p>
<p>The server's main function can then be simplified to:</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch7/http4/main.go">gopl.io/ch7/http4/main.go</a></small></p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">db</span> <span class="o">:=</span> <span class="nx">database</span><span class="p">{</span><span class="s">&quot;shoes&quot;</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span> <span class="s">&quot;socks&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">}</span>
    <span class="nx">http</span><span class="p">.</span><span class="nx">HandleFunc</span><span class="p">(</span><span class="s">&quot;/list&quot;</span><span class="p">,</span> <span class="nx">db</span><span class="p">.</span><span class="nx">list</span><span class="p">)</span>
    <span class="nx">http</span><span class="p">.</span><span class="nx">HandleFunc</span><span class="p">(</span><span class="s">&quot;/price&quot;</span><span class="p">,</span> <span class="nx">db</span><span class="p">.</span><span class="nx">price</span><span class="p">)</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">ListenAndServe</span><span class="p">(</span><span class="s">&quot;localhost:8000&quot;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>


<p>As we mentioned in <a href="../ch1/#a-web-server">Section 1.7</a>, the web server invokes each handler in a new goroutine, so handlers must take precautions such as <em>locking</em> when accessing variables that other goroutines, including other requests to the same handler, may be accessing. Concurrency is discussed in the next two chapters.</p>
<h3 id="the-error-interface">The <code>error</code> Interface<a class="headerlink" href="#the-error-interface" title="Permanent link">&para;</a></h3>
<p>The predeclared <code>error</code> type is just an interface type with a single method that returns an error message:</p>
<div class="codehilite"><pre><span class="kd">type</span> <span class="kt">error</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Error</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
</pre></div>


<p>The simplest way to create an <code>error</code> is by calling <code>errors.New</code>, which returns a new <code>error</code> for a given error message. The entire <code>errors</code> package is only four lines long:</p>
<div class="codehilite"><pre><span class="kn">package</span> <span class="nx">errors</span>

<span class="kd">func</span> <span class="nx">New</span><span class="p">(</span><span class="nx">text</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="nx">errorString</span><span class="p">{</span><span class="nx">text</span><span class="p">}</span> <span class="p">}</span>

<span class="kd">type</span> <span class="nx">errorString</span> <span class="kd">struct</span> <span class="p">{</span> <span class="nx">text</span> <span class="kt">string</span> <span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">errorString</span><span class="p">)</span> <span class="nx">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">e</span><span class="p">.</span><span class="nx">text</span> <span class="p">}</span>
</pre></div>


<p>The underlying type of <code>errorString</code> is a struct, not a string, to protect its representation from inadvertent (or premeditated) updates. The pointer type <code>*errorString</code> is used to satisfy the <code>error</code> interface rather than <code>errorString</code> alone so that every call to <code>New</code> allocates a distinct error instance that is not equal to each other. We would not want a distinguished error such as <code>io.EOF</code> to compare equal to one that may happen to have the same message.</p>
<div class="codehilite"><pre><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&quot;EOF&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&quot;EOF&quot;</span><span class="p">))</span> <span class="c1">// &quot;false&quot;</span>
</pre></div>


<p>Calls to <code>errors.New</code> are infrequent because there's a convenient wrapper function, <a href="https://golang.org/pkg/fmt/#Errorf"><code>fmt.Errorf</code></a> that does string formatting. It is used in <a href="../ch5/">Chapter 5</a>.</p>
<div class="codehilite"><pre><span class="kn">package</span> <span class="nx">fmt</span>

<span class="kn">import</span> <span class="s">&quot;errors&quot;</span>

<span class="kd">func</span> <span class="nx">Errorf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">Sprintf</span><span class="p">(</span><span class="nx">format</span><span class="p">,</span> <span class="nx">args</span><span class="o">...</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>


<p>Although <code>*errorString</code> may be the simplest type of <code>error</code> but not the only one. For example, the <code>syscall</code> package provides Go's low-level system call API. On many platforms, it defines a numeric type <code>Errno</code> that satisfies <code>error</code>, and on Unix platforms, <code>Errno</code>'s <code>Error</code> method does a lookup in a table of strings, as shown below:</p>
<div class="codehilite"><pre><span class="kn">package</span> <span class="nx">syscall</span>

<span class="kd">type</span> <span class="nx">Errno</span> <span class="kt">uintptr</span> <span class="c1">// operating system error code</span>

<span class="kd">var</span> <span class="nx">errors</span> <span class="p">=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span>
    <span class="mi">1</span><span class="p">:</span> <span class="s">&quot;operation not permitted&quot;</span><span class="p">,</span> <span class="c1">// EPERM</span>
    <span class="mi">2</span><span class="p">:</span> <span class="s">&quot;no such file or directory&quot;</span><span class="p">,</span> <span class="c1">// ENOENT</span>
    <span class="mi">3</span><span class="p">:</span> <span class="s">&quot;no such process&quot;</span><span class="p">,</span> <span class="c1">// ESRCH</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="nx">Errno</span><span class="p">)</span> <span class="nx">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nb">int</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">errors</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">errors</span><span class="p">[</span><span class="nx">e</span><span class="p">]</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;errno %d&quot;</span><span class="p">,</span> <span class="nx">e</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>The following statement creates an interface value holding the <code>Errno</code> value 2, signifying the POSIX <code>ENOENT</code> condition:</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span> <span class="p">=</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">Errno</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nx">Error</span><span class="p">())</span> <span class="c1">// &quot;no such file or directory&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>         <span class="c1">// &quot;no such file or directory&quot;</span>
</pre></div>


<p>The value of <code>err</code> is shown graphically the following figure:</p>
<p><a href="../figure_7.6.png" title="Figure 7.6. An interface value holding a syscall.Errno integer."><img alt="Figure 7.6. An interface value holding a syscall.Errno integer." src="../figure_7.6.png" /></a></p>
<p><code>Errno</code> is an efficient representation of system call errors drawn from a finite set, and it satisfies the standard <code>error</code> interface. Other types that satisfy this interface will be discussed in <a href="#discriminating-errors-with-type-assertions">Section 7.11</a>.</p>
<h3 id="example-expression-evaluator">Example: Expression Evaluator<a class="headerlink" href="#example-expression-evaluator" title="Permanent link">&para;</a></h3>
<p>[skipped]</p>
<h3 id="type-assertions">Type Assertions<a class="headerlink" href="#type-assertions" title="Permanent link">&para;</a></h3>
<p>A <a href="https://golang.org/ref/spec#Type_assertions"><strong>type assertion</strong></a> is an operation applied to an interface value. Syntactically, it looks like <code>x.(T)</code>, where <code>x</code> is an expression of an interface type and <code>T</code> is a type, called the "asserted" type. A type assertion checks that the dynamic type of its operand matches the asserted type, which has two possibilities as discussed below.</p>
<p>If the asserted type <code>T</code> is a concrete type, then the type assertion checks whether <code>x</code>'s dynamic type is identical to <code>T</code>. If this check succeeds, the result of the type assertion is <code>x</code>'s dynamic value, whose type is of course <code>T</code>. <u>In other words, a type assertion to a concrete type extracts the concrete value from its operand.</u> If the check fails, then the operation panics. For example:</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span>
<span class="nx">w</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span>
<span class="nx">f</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.(</span><span class="o">*</span><span class="nx">os</span><span class="p">.</span><span class="nx">File</span><span class="p">)</span>      <span class="c1">// success: f == os.Stdout</span>
<span class="nx">c</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.(</span><span class="o">*</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span> <span class="c1">// panic: interface holds *os.File, not *bytes.Buffer</span>
</pre></div>


<p>If the asserted type <code>T</code> is an interface type, then the type assertion checks whether <code>x</code>'s dynamic type <em>satisfies</em> <code>T</code>. If this check succeeds, the dynamic value is not extracted; the result is still an interface value with the same type and value components, but the result has the interface type <code>T</code>. In other words, a type assertion to an interface type changes the type of the expression, making a different (and usually larger) set of methods accessible, but it preserves the dynamic type and value components inside the interface value.</p>
<p>After the first type assertion below, both <code>w</code> and <code>rw</code> hold <code>os.Stdout</code> so each has a dynamic type of <code>*os.File</code>, but <code>w</code>, an <code>io.Writer</code>, exposes only the file's <code>Write</code> method, whereas <code>rw</code> also exposes its <code>Read</code> method.</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span>
<span class="nx">w</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span>
<span class="nx">rw</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.(</span><span class="nx">io</span><span class="p">.</span><span class="nx">ReadWriter</span><span class="p">)</span> <span class="c1">// success: *os.File has both Read and Write</span>

<span class="nx">w</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">ByteCounter</span><span class="p">)</span>
<span class="nx">rw</span> <span class="p">=</span> <span class="nx">w</span><span class="p">.(</span><span class="nx">io</span><span class="p">.</span><span class="nx">ReadWriter</span><span class="p">)</span>  <span class="c1">// panic: *ByteCounter has no Read method</span>
</pre></div>


<p>If the operand is a nil interface value, the type assertion always fails. A type assertion to a less restrictive interface type (one with fewer methods) is rarely needed, as it behaves just like an assignment, except in the nil case.</p>
<div class="codehilite"><pre><span class="nx">w</span> <span class="p">=</span> <span class="nx">rw</span> <span class="c1">// io.ReadWriter is assignable to io.Writer</span>
<span class="nx">w</span> <span class="p">=</span> <span class="nx">rw</span><span class="p">.(</span><span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">)</span> <span class="c1">// fails only if rw == nil</span>
</pre></div>


<p>When we're not sure of the dynamic type of an interface value, we can test whether it is some particular type. If the type assertion appears in an assignment in which two results are expected, such as the following declarations, the operation does not panic on failure but instead returns an additional second result, a boolean indicating success:</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span>
<span class="nx">f</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.(</span><span class="o">*</span><span class="nx">os</span><span class="p">.</span><span class="nx">File</span><span class="p">)</span>      <span class="c1">// success: ok, f == os.Stdout</span>
<span class="nx">b</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.(</span><span class="o">*</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span> <span class="c1">// failure: !ok, b == nil</span>
</pre></div>


<p>The second result is conventionally assigned to a variable named <code>ok</code>. If the operation failed, <code>ok</code> is false, and the first result is equal to the zero value of the asserted type, which in this example is a nil <code>*bytes.Buffer</code>.</p>
<p>The <code>ok</code> result is often immediately used to decide what to do next, as written in an <code>if</code> statement of the following form:</p>
<div class="codehilite"><pre><span class="k">if</span> <span class="nx">f</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.(</span><span class="o">*</span><span class="nx">os</span><span class="p">.</span><span class="nx">File</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
    <span class="c1">// ...use f...</span>
<span class="p">}</span>
</pre></div>


<p>When the operand of a type assertion is a variable, rather than invent another name for the new local variable, you'll sometimes see the original name reused, shadowing the original, like this:</p>
<div class="codehilite"><pre><span class="k">if</span> <span class="nx">w</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.(</span><span class="o">*</span><span class="nx">os</span><span class="p">.</span><span class="nx">File</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
    <span class="c1">// ...use w...</span>
<span class="p">}</span>
</pre></div>


<h3 id="discriminating-errors-with-type-assertions">Discriminating Errors with Type Assertions<a class="headerlink" href="#discriminating-errors-with-type-assertions" title="Permanent link">&para;</a></h3>
<p>Consider the set of errors returned by file operations in the <code>os</code> package. I/O can fail for any number of reasons, but three kinds of failure often must be handled differently:</p>
<ul>
<li>file already exists (for create operations)</li>
<li>file not found (for read operations)</li>
<li>permission denied</li>
</ul>
<p>The <code>os</code> package provides three helper functions to classify the failure indicated by a given <code>error</code> value:</p>
<div class="codehilite"><pre><span class="kn">package</span> <span class="nx">os</span>

<span class="kd">func</span> <span class="nx">IsExist</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">bool</span>
<span class="kd">func</span> <span class="nx">IsNotExist</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">bool</span>
<span class="kd">func</span> <span class="nx">IsPermission</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">bool</span>
</pre></div>


<p>A naïve implementation might check that the error message contains a certain substring:</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">IsNotExist</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="c1">// NOTE: not robust!</span>
    <span class="k">return</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Contains</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nx">Error</span><span class="p">(),</span> <span class="s">&quot;file does not exist&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>Because the logic for handling I/O errors can vary from one platform to another, this approach is not robust and the same failure may be reported with a variety of different error messages.</p>
<p>A more reliable approach is to represent structured error values using a dedicated type. The <code>os</code> package defines these types:</p>
<ul>
<li><code>PathError</code>, which describes failures involving an operation on a file path, like <code>Open</code> or <code>Delete</code></li>
<li>A variant <code>LinkError</code>, which describes failures of operations involving two file paths, like <code>Symlink</code> and <code>Rename</code></li>
</ul>
<p>The following is <code>os.PathError</code>:</p>
<div class="codehilite"><pre><span class="kn">package</span> <span class="nx">os</span>

<span class="c1">// PathError records an error and the operation and file path that caused it.</span>
<span class="kd">type</span> <span class="nx">PathError</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Op</span> <span class="kt">string</span>
    <span class="nx">Path</span> <span class="kt">string</span>
    <span class="nx">Err</span> <span class="kt">error</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">PathError</span><span class="p">)</span> <span class="nx">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Op</span> <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Path</span> <span class="o">+</span> <span class="s">&quot;: &quot;</span> <span class="o">+</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Err</span><span class="p">.</span><span class="nx">Error</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>


<p>Although <code>PathError</code>'s <code>Error</code> method forms a message by simply concatenating the fields, <code>PathError</code>'s structure preserves the underlying components of the error. Clients can use a <a href="#type-assertions">type assertion</a> to detect the specific type of the error; the specific type provides more detail than a simple string.</p>
<div class="codehilite"><pre><span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="s">&quot;/no/such/file&quot;</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="c1">// &quot;open /no/such/file: No such file or directory&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%#v\n&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="c1">// Output:</span>
<span class="c1">// &amp;os.PathError{Op:&quot;open&quot;, Path:&quot;/no/such/file&quot;, Err:0x2}</span>
</pre></div>


<p>That is how the three helper functions work. For example, <code>IsNotExist</code>, shown below, reports whether an error is equal to <code>syscall.ENOENT</code> (<a href="#the-error-interface">Section 7.8</a>) or to the distinguished error <code>os.ErrNotExist</code> (see <code>io.EOF</code> in <a href="../ch5/#end-of-file-eof">Section 5.4.2</a>), or is a <code>*PathError</code> whose underlying error is one of those two.</p>
<div class="codehilite"><pre><span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;errors&quot;</span>
    <span class="s">&quot;syscall&quot;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">ErrNotExist</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&quot;file does not exist&quot;</span><span class="p">)</span>

<span class="c1">// IsNotExist returns a boolean indicating whether the error is known to</span>
<span class="c1">// report that a file or directory does not exist. It is satisfied by</span>
<span class="c1">// ErrNotExist as well as some syscall errors.</span>
<span class="kd">func</span> <span class="nx">IsNotExist</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">pe</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="o">*</span><span class="nx">PathError</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
        <span class="nx">err</span> <span class="p">=</span> <span class="nx">pe</span><span class="p">.</span><span class="nx">Err</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">ENOENT</span> <span class="o">||</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">ErrNotExist</span>
<span class="p">}</span>
</pre></div>


<p>This is how it is used:</p>
<div class="codehilite"><pre><span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="s">&quot;/no/such/file&quot;</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">IsNotExist</span><span class="p">(</span><span class="nx">err</span><span class="p">))</span> <span class="c1">// &quot;true&quot;</span>
</pre></div>


<p><code>PathError</code>'s structure is lost if the error message is combined into a larger string, for instance by a call to <code>fmt.Errorf</code>. Error discrimination must usually be done immediately after the failing operation, before an error is propagated to the caller.</p>
<h3 id="querying-behaviors-with-interface-type-assertions">Querying Behaviors with Interface Type Assertions<a class="headerlink" href="#querying-behaviors-with-interface-type-assertions" title="Permanent link">&para;</a></h3>
<p>The code below is similar to the part of the <a href="https://golang.org/pkg/net/http/"><code>net/http</code></a> web server responsible for writing HTTP header fields. The <code>io.Writer w</code> represents the HTTP response; the bytes written to it are sent to the web browser.</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">writeHeader</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">contentType</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&quot;Content-Type: &quot;</span><span class="p">));</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">contentType</span><span class="p">));</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>


<p>Because the <code>Write</code> method requires a byte slice, a <code>[]byte(...)</code> conversion from a string is required. This conversion allocates memory and makes a copy, but the copy is discarded almost immediately after. Can we avoid allocating memory here?</p>
<p>The <a href="https://golang.org/pkg/io/#Writer"><code>io.Writer</code></a> interface tells us only one fact about the concrete type that <code>w</code> holds: that bytes may be written to it. If we look behind the curtains of the <code>net/http</code> package, we see that the dynamic type that <code>w</code> holds in this program also has a <code>WriteString</code> method that allows strings to be efficiently written to it, avoiding the need to allocate a temporary copy. A number of important types that satisfy <code>io.Writer</code> also have a <code>WriteString</code> method, including <code>*bytes.Buffer</code>, <code>*os.File</code> and <code>*bufio.Writer</code>.</p>
<p>We cannot assume that an arbitrary <code>io.Writer w</code> also has the <code>WriteString</code> method. But we can define a new interface that has just this method and use a type assertion to test whether the dynamic type of <code>w</code> satisfies this new interface.</p>
<div class="codehilite"><pre><span class="c1">// writeString writes s to w.</span>
<span class="c1">// If w has a WriteString method, it is invoked instead of w.Write.</span>
<span class="kd">func</span> <span class="nx">writeString</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">type</span> <span class="nx">stringWriter</span> <span class="kd">interface</span> <span class="p">{</span>
        <span class="nx">WriteString</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">sw</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.(</span><span class="nx">stringWriter</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">sw</span><span class="p">.</span><span class="nx">WriteString</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="c1">// avoid a copy</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">w</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span> <span class="c1">// allocate temporary copy</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">writeHeader</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">contentType</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">writeString</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&quot;Content-Type: &quot;</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">writeString</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">contentType</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>


<p>The standard library provides it as <a href="https://golang.org/pkg/io/#WriteString"><code>io.WriteString</code></a>; it is the recommended way to write a string to an <code>io.Writer</code>.</p>
<p>From this example, we realize that:</p>
<ul>
<li>There is no standard interface that defines the <code>WriteString</code> method and specifies its required behavior.</li>
<li>Whether or not a concrete type satisfies the <code>stringWriter</code> interface is determined only by its methods, not by any declared relationship between it and the interface type.</li>
</ul>
<p>What this means is that the technique above relies on the assumption that if a type satisfies the interface below, then <code>WriteString(s)</code> must have the same effect as <code>Write([]byte(s))</code>.</p>
<div class="codehilite"><pre><span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span>
    <span class="nx">WriteString</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>Although <code>io.WriteString</code> documents its assumption, few functions that call it are likely to document that they make the same assumption. Defining a method of a particular type is taken as an implicit assent for a certain behavioral contract. This lack of explicit intention seems unsettling, but it is rarely a problem in practice. With the exception of the empty interface <code>interface{}</code>, interface types are seldom satisfied by unintended coincidence.</p>
<p>The <code>writeString</code> function above uses a type assertion to see whether a value of a general interface type also satisfies a more specific interface type, and if so, it uses the behaviors of the specific interface. This technique can be put to good use whether or not the queried interface is standard like <code>io.ReadWriter</code> or user-defined like <code>stringWriter</code>.</p>
<p>It's also how <code>fmt.Fprintf</code> distinguishes values that satisfy <code>error</code> or <code>fmt.Stringer</code> from all other values. Within <code>fmt.Fprintf</code>, there is a step that converts a single operand to a string, something like this:</p>
<div class="codehilite"><pre><span class="kn">package</span> <span class="nx">fmt</span>

<span class="kd">func</span> <span class="nx">formatOneValue</span><span class="p">(</span><span class="nx">x</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">err</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">x</span><span class="p">.(</span><span class="kt">error</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">err</span><span class="p">.</span><span class="nx">Error</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">str</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">x</span><span class="p">.(</span><span class="nx">Stringer</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">str</span><span class="p">.</span><span class="nx">String</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="c1">// ...all other types...</span>
<span class="p">}</span>
</pre></div>


<p>If <code>x</code> satisfies either of the two interfaces, that determines the formatting of the value. If not, the default case handles all other types more or less uniformly using <a href="https://blog.golang.org/laws-of-reflection">reflection</a>, which is discussed in <a href="../ch12/">Chapter 12</a>.</p>
<p>Again, this makes the assumption that any type with a <code>String</code> method satisfies the behavioral contract of <code>fmt.Stringer</code>, which is to return a string suitable for printing.</p>
<h3 id="type-switches">Type Switches<a class="headerlink" href="#type-switches" title="Permanent link">&para;</a></h3>
<p>Interfaces are used in two distinct styles.</p>
<ol>
<li>The first style is exemplified by interfaces such as <code>io.Reader</code>, <code>io.Writer</code>, <code>fmt.Stringer</code>, <code>sort.Interface</code>, <code>http.Handler</code>, and <code>error</code>.<ul>
<li>In this style, an interface's methods express the similarities of the concrete types that satisfy the interface but hide the representation details and intrinsic operations of those concrete types.</li>
<li>The emphasis is on the methods, not on the concrete types.</li>
</ul>
</li>
<li>The second style exploits the ability of an interface value to hold values of a variety of concrete types and considers the interface to be the <em>union</em> of those types.<ul>
<li>Type assertions are used to discriminate among these types dynamically and treat each case differently.</li>
<li>The emphasis is on the concrete types that satisfy the interface, not on the interface's methods, and there is no hiding of information.</li>
<li>The interfaces used this way are described as <a href="https://en.wikipedia.org/wiki/Tagged_union">discriminated unions</a>.</li>
</ul>
</li>
</ol>
<p>In object-oriented programming, these two styles may be recognized as <a href="https://en.wikipedia.org/wiki/Subtyping">subtype polymorphism</a> and <a href="https://en.wikipedia.org/wiki/Ad_hoc_polymorphism">ad hoc polymorphism</a>.</p>
<p>Go's API for querying an SQL database separates the fixed part of a query from the variable parts. In the following example:</p>
<div class="codehilite"><pre><span class="kn">import</span> <span class="s">&quot;database/sql&quot;</span>
<span class="kd">func</span> <span class="nx">listTracks</span><span class="p">(</span><span class="nx">db</span> <span class="nx">sql</span><span class="p">.</span><span class="nx">DB</span><span class="p">,</span> <span class="nx">artist</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">minYear</span><span class="p">,</span> <span class="nx">maxYear</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">result</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">Exec</span><span class="p">(</span>
        <span class="s">&quot;SELECT * FROM tracks WHERE artist = ? AND ? &lt;= year AND year &lt;= ?&quot;</span><span class="p">,</span>
        <span class="nx">artist</span><span class="p">,</span> <span class="nx">minYear</span><span class="p">,</span> <span class="nx">maxYear</span><span class="p">)</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>


<p>The <code>Exec</code> method replaces each '<code>?</code>' in the query string with an SQL literal denoting the corresponding argument value. Constructing queries this way helps avoid SQL injection attacks, in which an adversary takes control of the query by exploiting improper quotation of input data.</p>
<p>Within <code>Exec</code>, we might find a function like the one below, which converts each argument value to its literal SQL notation.</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">sqlQuote</span><span class="p">(</span><span class="nx">x</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">x</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">&quot;NULL&quot;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">x</span><span class="p">.(</span><span class="kt">int</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">x</span><span class="p">.(</span><span class="kt">uint</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">x</span><span class="p">.(</span><span class="kt">bool</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">b</span> <span class="p">{</span>
            <span class="k">return</span> <span class="s">&quot;TRUE&quot;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="s">&quot;FALSE&quot;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">x</span><span class="p">.(</span><span class="kt">string</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">sqlQuoteString</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="c1">// (not shown)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;unexpected type %T: %v&quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">x</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>A <code>switch</code> statement simplifies an <code>if</code>-<code>else</code> chain that performs a series of value equality tests. An analogous <a href="https://golang.org/doc/effective_go.html#type_switch">type switch</a> statement simplifies an <code>if</code>-<code>else</code> chain of type assertions.</p>
<p>In its simplest form:</p>
<ul>
<li>A type switch looks like an ordinary <code>switch</code> statement in which the operand is <code>x.(type)</code> (that's literally the keyword <code>type</code>) and each case has one or more types.</li>
<li>A type switch enables a multi-way branch based on the interface value's dynamic type. The <code>nil</code> case matches if <code>x == nil</code>, and the <code>default</code> case matches if no other case does.</li>
</ul>
<p>A type switch for <code>sqlQuote</code> would have these cases:</p>
<div class="codehilite"><pre><span class="k">switch</span> <span class="nx">x</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
<span class="k">case</span> <span class="kc">nil</span><span class="p">:</span>       <span class="c1">// ...</span>
<span class="k">case</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">uint</span><span class="p">:</span> <span class="c1">// ...</span>
<span class="k">case</span> <span class="kt">bool</span><span class="p">:</span>      <span class="c1">// ...</span>
<span class="k">case</span> <span class="kt">string</span><span class="p">:</span>    <span class="c1">// ...</span>
<span class="k">default</span><span class="p">:</span>        <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>


<p>As with an ordinary <code>switch</code> statement (<a href="../ch1/#loose-ends">Section 1.8</a>):</p>
<ul>
<li>Cases are considered in order. When a match is found, the case's body is executed.</li>
<li>Case order becomes significant when one or more case types are interfaces, since then there is a possibility of two cases matching.</li>
<li>The position of the <code>default</code> case relative to the others is immaterial.</li>
<li>No <code>fallthrough</code> is allowed.</li>
</ul>
<p>In the original function, the logic for the <code>bool</code> and <code>string</code> cases needs access to the value extracted by the type assertion. The type switch statement has an extended form that binds the extracted value to a new variable within each case:</p>
<div class="codehilite"><pre><span class="k">switch</span> <span class="nx">x</span> <span class="o">:=</span> <span class="nx">x</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</pre></div>


<p>The new variables is called <code>x</code>, since reuse of variable names is common, as with type assertions. Like a <code>switch</code> statement, a type switch implicitly creates a lexical block, so the declaration of the new variable called <code>x</code> does not conflict with a variable <code>x</code> in an outer block. Each case also implicitly creates a separate lexical block.</p>
<p><code>sqlQuote</code> can be rewritten to use the extended form of type switch:</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">sqlQuote</span><span class="p">(</span><span class="nx">x</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="nx">x</span> <span class="o">:=</span> <span class="nx">x</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="kc">nil</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">&quot;NULL&quot;</span>
    <span class="k">case</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">uint</span><span class="p">:</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="c1">// x has type interface{} here.</span>
    <span class="k">case</span> <span class="kt">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="nx">x</span> <span class="p">{</span>
            <span class="k">return</span> <span class="s">&quot;TRUE&quot;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="s">&quot;FALSE&quot;</span>
    <span class="k">case</span> <span class="kt">string</span><span class="p">:</span>
        <span class="k">return</span> <span class="nx">sqlQuoteString</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="c1">// (not shown)</span>
    <span class="k">default</span><span class="p">:</span>
        <span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;unexpected type %T: %v&quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">x</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>In the above code:</p>
<ul>
<li>Within the block of each single-type case, the variable <code>x</code> has the same type as the case.<ul>
<li>For instance, <code>x</code> has type <code>bool</code> within the <code>bool</code> case and <code>string</code> within the <code>string</code> case.</li>
</ul>
</li>
<li>In all other cases, <code>x</code> has the (interface) type of the <code>switch</code> operand, which is <code>interface{}</code>.</li>
<li>When the same action is required for multiple cases, like <code>int</code> and <code>uint</code>, the type switch makes it easy to combine them.</li>
</ul>
<p>Although <code>sqlQuote</code> accepts an argument of any type, the function runs to completion only if the argument's type matches one of the cases in the type switch; otherwise it panics with an "unexpected type" message. Although the type of <code>x</code> is <code>interface{}</code>, we consider it a discriminated union of <code>int</code>, <code>uint</code>, <code>bool</code>, <code>string</code>, and <code>nil</code>.</p>
<h3 id="example-token-based-xml-decoding">Example: Token-Based XML Decoding<a class="headerlink" href="#example-token-based-xml-decoding" title="Permanent link">&para;</a></h3>
<p><a href="../ch4/#json">Section 4.5</a> showed how to decode JSON documents into Go data structures with the <code>Marshal</code> and <code>Unmarshal</code> functions from the <code>encoding/json</code> package. The <code>encoding/xml</code> package provides a similar API.</p>
<p>This approach is convenient when we want to construct a representation of the document tree, but that's unnecessary for many programs. The <code>encoding/xml</code> package also provides a lower-level token-based API for decoding XML. In the token-based style, the parser consumes the input and produces a stream of tokens, primarily of four kinds:</p>
<ul>
<li><code>StartElement</code></li>
<li><code>EndElement</code></li>
<li><code>CharData</code></li>
<li><code>Comment</code></li>
</ul>
<p>Each of them is a concrete type in the <code>encoding/xml</code> package. Each call to <code>(*xml.Decoder).Token</code> returns a token. The relevant parts of the API are shown here:</p>
<div class="codehilite"><pre><span class="kn">package</span> <span class="nx">xml</span>

<span class="kd">type</span> <span class="nx">Name</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Local</span> <span class="kt">string</span> <span class="c1">// e.g., &quot;Title&quot; or &quot;id&quot;</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Attr</span> <span class="kd">struct</span> <span class="p">{</span> <span class="c1">// e.g., name=&quot;value&quot;</span>
    <span class="nx">Name</span> <span class="nx">Name</span>
    <span class="nx">Value</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="c1">// A Token includes StartElement, EndElement, CharData,</span>
<span class="c1">// and Comment, plus a few esoteric types (not shown).</span>
<span class="kd">type</span> <span class="nx">Token</span> <span class="kd">interface</span><span class="p">{}</span>
<span class="kd">type</span> <span class="nx">StartElement</span> <span class="kd">struct</span> <span class="p">{</span> <span class="c1">// e.g., &lt;name&gt;</span>
    <span class="nx">Name</span> <span class="nx">Name</span>
    <span class="nx">Attr</span> <span class="p">[]</span><span class="nx">Attr</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">EndElement</span> <span class="kd">struct</span> <span class="p">{</span> <span class="nx">Name</span> <span class="nx">Name</span> <span class="p">}</span> <span class="c1">// e.g., &lt;/name&gt;</span>
<span class="kd">type</span> <span class="nx">CharData</span> <span class="p">[]</span><span class="kt">byte</span>                 <span class="c1">// e.g., &lt;p&gt;CharData&lt;/p&gt;</span>
<span class="kd">type</span> <span class="nx">Comment</span> <span class="p">[]</span><span class="kt">byte</span>                  <span class="c1">// e.g., &lt;!-- Comment --&gt;</span>

<span class="kd">type</span> <span class="nx">Decoder</span> <span class="kd">struct</span><span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">NewDecoder</span><span class="p">(</span><span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span> <span class="o">*</span><span class="nx">Decoder</span>
<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">Decoder</span><span class="p">)</span> <span class="nx">Token</span><span class="p">()</span> <span class="p">(</span><span class="nx">Token</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="c1">// returns next Token in sequence</span>
</pre></div>


<p>The <code>Token</code> interface, which has no methods, is also an example of a discriminated union.</p>
<ul>
<li>The purpose of a traditional interface like <code>io.Reader</code> is to hide details of the concrete types that satisfy it so that new implementations can be created; each concrete type is treated uniformly.</li>
<li>By contrast, the set of concrete types that satisfy a discriminated union is fixed by the design and exposed, not hidden. Discriminated union types have few methods; functions that operate on them are expressed as a set of cases using a type switch, with different logic in each case.</li>
</ul>
<p>The <code>xmlselect</code> program below extracts and prints the text found beneath certain elements in an XML document tree. Using the API above, it can do its job in a single pass over the input without ever materializing the tree.</p>
<p><small><a href="https://github.com/shichao-an/gopl.io/blob/master/ch7/xmlselect/main.go">gopl.io/ch7/xmlselect/main.go</a></small></p>
<div class="codehilite"><pre><span class="c1">// Xmlselect prints the text of selected elements of an XML document.</span>
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;encoding/xml&quot;</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;io&quot;</span>
    <span class="s">&quot;os&quot;</span>
    <span class="s">&quot;strings&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">dec</span> <span class="o">:=</span> <span class="nx">xml</span><span class="p">.</span><span class="nx">NewDecoder</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">)</span>
    <span class="kd">var</span> <span class="nx">stack</span> <span class="p">[]</span><span class="kt">string</span> <span class="c1">// stack of element names</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="nx">tok</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">dec</span><span class="p">.</span><span class="nx">Token</span><span class="p">()</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
            <span class="k">break</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&quot;xmlselect: %v\n&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
            <span class="nx">os</span><span class="p">.</span><span class="nx">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">switch</span> <span class="nx">tok</span> <span class="o">:=</span> <span class="nx">tok</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nx">xml</span><span class="p">.</span><span class="nx">StartElement</span><span class="p">:</span>
            <span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">tok</span><span class="p">.</span><span class="nx">Name</span><span class="p">.</span><span class="nx">Local</span><span class="p">)</span> <span class="c1">// push</span>
        <span class="k">case</span> <span class="nx">xml</span><span class="p">.</span><span class="nx">EndElement</span><span class="p">:</span>
            <span class="nx">stack</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1">// pop</span>
        <span class="k">case</span> <span class="nx">xml</span><span class="p">.</span><span class="nx">CharData</span><span class="p">:</span>
            <span class="k">if</span> <span class="nx">containsAll</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="p">{</span>
                <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%s: %s\n&quot;</span><span class="p">,</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Join</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="s">&quot; &quot;</span><span class="p">),</span> <span class="nx">tok</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// containsAll reports whether x contains the elements of y, in order.</span>
<span class="kd">func</span> <span class="nx">containsAll</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">y</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">y</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">true</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="nx">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">{</span>
            <span class="nx">y</span> <span class="p">=</span> <span class="nx">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="p">}</span>
        <span class="nx">x</span> <span class="p">=</span> <span class="nx">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>
</pre></div>


<ul>
<li>Each time the loop in main encounters a <code>StartElement</code>, it pushes the elements' name onto a stack, and for each <code>EndElement</code> it pops the name from the stack.</li>
<li>The API guarantees that the sequence of <code>StartElement</code> and <code>EndElement</code> tokens will be properly matched, even in illformed documents.</li>
<li><code>Comments</code> are ignored.</li>
<li>When <code>xmlselect</code> encounters a <code>CharData</code>, it prints the text only if the stack contains all the elements named by the command-line arguments, in order.</li>
</ul>
<p>The command below prints the text of any <code>h2</code> elements appearing beneath two levels of <code>div</code> elements.</p>
<div class="codehilite"><pre>$ go build gopl.io/ch1/fetch
$ ./fetch http://www.w3.org/TR/2006/REC-xml11-20060816 |
    ./xmlselect div div h2
html body div div h2: 1 Introduction
html body div div h2: 2 Documents
html body div div h2: 3 Logical Structures
html body div div h2: 4 Physical Structures
html body div div h2: 5 Conformance
html body div div h2: 6 Notation
html body div div h2: A References
html body div div h2: B Definitions for Character Normalization
...
</pre></div>


<h3 id="a-few-words-of-advice">A Few Words of Advice<a class="headerlink" href="#a-few-words-of-advice" title="Permanent link">&para;</a></h3>
<p>When designing a new package, novice Go programmers often start by creating a set of interfaces and only later define the concrete types that satisfy them. This approach is not recommended, because:</p>
<ul>
<li>It results in many interfaces, each of which has only a single implementation. These interfaces are unnecessary abstractions.</li>
<li>These interfaces also have a run-time cost.</li>
</ul>
<p>You can restrict which methods of a type or fields of a struct are visible outside a package using the export mechanism (<a href="../ch6/#encapsulation">Section 6.6</a>). Interfaces are only needed when there are two or more concrete types that must be dealt with in a uniform way.</p>
<p>An exception to this rule is: when an interface is satisfied by a single concrete type but that type cannot live in the same package as the interface because of its dependencies. In that case, an interface is a good way to decouple two packages.</p>
<p>Because interfaces are used only when they are satisfied by two or more types, they necessarily abstract away from the details of any particular implementation. The result is smaller interfaces with fewer, simpler methods, often just one as with <code>io.Writer</code> or <code>fmt.Stringer.</code> Small interfaces are easier to satisfy when new types come along. A good rule of thumb for interface design is <em>ask only for what you need</em>.</p>
<p>With methods and interfaces, Go has great support for the object-oriented style of programming, but this does not mean you need to use it exclusively. Not everything need be an object; standalone functions have their place, as do unencapsulated data types.</p>
<h3 id="doubts-and-solution">Doubts and Solution<a class="headerlink" href="#doubts-and-solution" title="Permanent link">&para;</a></h3>
<h4 id="verbatim">Verbatim<a class="headerlink" href="#verbatim" title="Permanent link">&para;</a></h4>
<h5 id="p210-on-assumption-of-writestring"><strong>p210 on assumption of <code>WriteString</code></strong><a class="headerlink" href="#p210-on-assumption-of-writestring" title="Permanent link">&para;</a></h5>
<blockquote>
<p>Although <code>io.WriteString</code> documents its assumption, few functions that call it are likely to document that they make the same assumption. Defining a method of a particular type is taken as an implicit assent for a certain behavioral contract.</p>
</blockquote>
<p><span class="text-danger">Question</span>: What does it mean?</p>
            </div>
        </div>

        <footer class="col-md-12">
            
        </footer>

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script>
        <script src="../../js/base.js"></script>
        <script src="../../custom.js"></script>
    </body>
</html>