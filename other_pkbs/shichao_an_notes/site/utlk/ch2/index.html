<!DOCTYPE html>
<html lang="en">
    <head>
        <!-- Global Site Tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-59055167-2"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments)};
          gtag('js', new Date());

          gtag('config', 'UA-59055167-2');
        </script>

        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://notes.shichao.io/utlk/ch2/">
        <link rel="shortcut icon" href="../../toki_32.png">
        

	<title>Chapter 2. Memory Addressing - Shichao's Notes</title>

        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../../css/base.css" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,400italic,500,600" rel="stylesheet">
        <link href="../../custom.css" rel="stylesheet">
        <link href="../../friendly.css" rel="stylesheet">
        <link href="../../theme.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        
<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../..">Shichao's Notes</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">APUE <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../apue/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch1/">Chapter 1. UNIX System Overview</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch2/">Chapter 2. UNIX Standardization and Implementations</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch3/">Chapter 3. File I/O</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch4/">Chapter 4. Files and Directories</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch5/">Chapter 5. Standard I/O Library</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch6/">Chapter 6. System Data Files and Information</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch7/">Chapter 7. Process Environment</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch8/">Chapter 8. Process Control</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch9/">Chapter 9. Process Relationships</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch10/">Chapter 10. Signals</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch11/">Chapter 11. Threads</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch12/">Chapter 12. Thread Control</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch13/">Chapter 13. Daemon Processes</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch14/">Chapter 14. Advanced I/O</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch15/">Chapter 15. Interprocess Communication</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch16/">Chapter 16. Network IPC: Sockets</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch17/">Chapter 17. Advanced IPC</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UNP <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../unp/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch2/">Chapter 2. The Transport Layer: TCP, UDP, and SCTP</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch3/">Chapter 3. Sockets Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch4/">Chapter 4. Elementary TCP Sockets</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch5/">Chapter 5. TCP Client/Server Example</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch6/">Chapter 6. I/O Multiplexing: The select and poll Functions</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch7/">Chapter 7. Socket Options</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch8/">Chapter 8. Elementary UDP Sockets</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">TCPv1 <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../tcpv1/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch2/">Chapter 2. The Internet Address Architecture</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch3/">Chapter 3. Link Layer</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch4/">Chapter 4. ARP: Address Resolution Protocol</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch5/">Chapter 5. The Internet Protocol (IP)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch6/">Chapter 6. System Configuration: DHCP and Autoconfiguration</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch7/">Chapter 7. Firewalls and Network Address Translation (NAT)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch8/">Chapter 8. ICMPv4 and ICMPv6: Internet Control Message Protocol</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch9/">Chapter 9. Broadcasting and Local Multicasting (IGMP and MLD)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch10/">Chapter 10. User Datagram Protocol (UDP) and IP Fragmentation</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch11/">Chapter 11. Name Resolution and the Domain Name System (DNS)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch12/">Chapter 12. TCP: The Transmission Control Protocol (Preliminaries)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch13/">Chapter 13. TCP Connection Management</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch14/">Chapter 14. TCP Timeout and Retransmission</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch15/">Chapter 15. TCP Data Flow and Window Management</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch16/">Chapter 16. TCP Congestion Control</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch17/">Chapter 17. TCP Keepalive</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch18/">Chapter 18. Security: EAP, IPsec, TLS, DNSSEC, and DKIM</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/headers/">Headers</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">GOPL <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../gopl/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch1/">Chapter 1. Tutorial</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch2/">Chapter 2. Program Structure</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch3/">Chapter 3. Basic Data Types</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch4/">Chapter 4. Composite Types</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch5/">Chapter 5. Functions</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch6/">Chapter 6. Methods</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch7/">Chapter 7. Interfaces</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch8/">Chapter 8. Goroutines and Channels</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch9/">Chapter 9. Concurrency with Shared Variables</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch10/">Chapter 10. Packages and the Go Tool</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch11/">Chapter 11. Testing</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch12/">Chapter 12. Reflection</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">CSN <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../csn/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../csn/part1/">Part 1: Language</a>
                        </li>
                      
                        <li>
                            <a href="../../csn/part2/">Part 2: Advanced</a>
                        </li>
                      
                    </ul>
                </li>
            <li>
                    <a href="../../toc/">TOC</a>
                </li>
            </ul>
            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    
                        <a href="https://github.com/shichao-an/notes/blob/master/docs/utlk/ch2.md">
                    
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#chapter-2-memory-addressing">Chapter 2. Memory Addressing</a></li>
        
    
        <li class="main "><a href="#memory-addresses">Memory Addresses</a></li>
        
            <li><a href="#memory-management-unit">Memory Management Unit *</a></li>
        
            <li><a href="#memory-arbiter">Memory Arbiter *</a></li>
        
    
        <li class="main "><a href="#segmentation-in-hardware">Segmentation in Hardware</a></li>
        
            <li><a href="#segment-selectors-and-segmentation-registers">Segment Selectors and Segmentation Registers</a></li>
        
            <li><a href="#segment-descriptors">Segment Descriptors</a></li>
        
            <li><a href="#fast-access-to-segment-descriptors">Fast Access to Segment Descriptors</a></li>
        
            <li><a href="#segmentation-unit">Segmentation Unit</a></li>
        
    
        <li class="main "><a href="#segmentation-in-linux">Segmentation in Linux</a></li>
        
            <li><a href="#cpl-rpl-and-registers">CPL, RPL and registers *</a></li>
        
            <li><a href="#implicit-segment-selector">Implicit Segment Selector *</a></li>
        
            <li><a href="#the-linux-gdt">The Linux GDT</a></li>
        
            <li><a href="#the-linux-ldts">The Linux LDTs</a></li>
        
    
        <li class="main "><a href="#paging-in-hardware">Paging in Hardware</a></li>
        
            <li><a href="#regular-paging">Regular Paging</a></li>
        
            <li><a href="#extended-paging">Extended Paging</a></li>
        
            <li><a href="#hardware-protection-scheme">Hardware Protection Scheme</a></li>
        
            <li><a href="#an-example-of-regular-paging">An Example of Regular Paging</a></li>
        
            <li><a href="#the-physical-address-extension-pae-paging-mechanism">The Physical Address Extension (PAE) Paging Mechanism</a></li>
        
            <li><a href="#paging-for-64-bit-architectures">Paging for 64-bit Architectures</a></li>
        
            <li><a href="#hardware-cache">Hardware Cache</a></li>
        
            <li><a href="#translation-lookaside-buffers-tlb">Translation Lookaside Buffers (TLB)</a></li>
        
    
        <li class="main "><a href="#paging-in-linux">Paging in Linux</a></li>
        
            <li><a href="#the-linear-address-fields">The Linear Address Fields</a></li>
        
            <li><a href="#page-table-handling">Page Table Handling</a></li>
        
            <li><a href="#physical-memory-layout">Physical Memory Layout</a></li>
        
            <li><a href="#process-page-tables">Process Page Tables</a></li>
        
            <li><a href="#kernel-page-tables">Kernel Page Tables</a></li>
        
            <li><a href="#fix-mapped-linear-addresses">Fix-Mapped Linear Addresses</a></li>
        
            <li><a href="#handling-the-hardware-cache-and-the-tlb">Handling the Hardware Cache and the TLB</a></li>
        
    
        <li class="main "><a href="#doubts-and-solution">Doubts and Solution</a></li>
        
            <li><a href="#verbatim">Verbatim</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">
              

<h3 id="chapter-2-memory-addressing"><strong>Chapter 2. Memory Addressing</strong><a class="headerlink" href="#chapter-2-memory-addressing" title="Permanent link">&para;</a></h3>
<p>This chapter discusses addressing techniques by offering details in <a href="http://en.wikipedia.org/wiki/X86">80×86</a> microprocessors address memory chips and how Linux uses the available addressing circuits.</p>
<h3 id="memory-addresses">Memory Addresses<a class="headerlink" href="#memory-addresses" title="Permanent link">&para;</a></h3>
<p>Programmers casually refer to a <strong>memory address</strong> as the way to access the contents of a memory cell. However, when dealing with 80×86 microprocessors, we have to distinguish three kinds of addresses:</p>
<ul>
<li><strong>Logical address</strong>: included in the machine language instructions to specify the address of an operand or of an instruction.<ul>
<li>This type of address embodies the well-known <a href="https://en.wikipedia.org/wiki/X86_memory_segmentation">80×86 segmented architecture</a>.</li>
<li>Each logical address consists of a <em>segment</em> and an <em>offset</em> (or <em>displacement</em>) that denotes the distance from the start of the segment to the actual address.</li>
</ul>
</li>
<li><strong>Linear address</strong> (also known as <strong>virtual address</strong>): a single 32-bit unsigned integer that can be used to address up to 4 GB, that is, up to 4,294,967,296 memory cells.<ul>
<li>Linear addresses are usually represented in hexadecimal notation: from <code>0x00000000</code> to <code>0xffffffff</code>.</li>
</ul>
</li>
<li><strong>Physical address</strong>: used to address memory cells in memory chips. They correspond to the electrical signals sent along the address pins of the microprocessor to the memory bus.<ul>
<li><u>Physical addresses are represented as 32-bit or 36-bit unsigned integers.</u></li>
</ul>
</li>
</ul>
<h4 id="memory-management-unit">Memory Management Unit *<a class="headerlink" href="#memory-management-unit" title="Permanent link">&para;</a></h4>
<p><a href="https://en.wikipedia.org/wiki/Memory_management_unit">Memory Management Unit</a> (MMU) transforms a logical address into a linear address (using a hardware circuit called a segmentation unit), and the linear address into a physical address (using a second hardware circuit called a paging unit), as shown in the figure below:</p>
<p><a href="../figure_2-1.png" title="Figure 2-1. Logical address translation"><img alt="Figure 2-1. Logical address translation" src="../figure_2-1_600.png" /></a></p>
<h4 id="memory-arbiter">Memory Arbiter *<a class="headerlink" href="#memory-arbiter" title="Permanent link">&para;</a></h4>
<p>The <a href="https://en.wikipedia.org/wiki/Arbiter_(electronics)"><strong>memory arbiter</strong></a> is a hardware circuit inserted between the bus and every RAM chip. Its role is to grant access to a CPU if the chip is free and to delay it if the chip is busy servicing a request by another processor.</p>
<ul>
<li>In multiprocessor systems, RAM chips may be accessed concurrently by independent CPUs, since all CPUs usually share the same memory. Thus, memory arbiters are need, because read or write operations on a RAM chip must be performed serially.</li>
<li>Uniprocessor systems also use memory arbiters, because they include specialized processors called <a href="https://en.wikipedia.org/wiki/Direct_memory_access"><em>DMA controllers</em></a> that operate concurrently with the CPU.</li>
</ul>
<p>For multiprocessor systems, the structure of the arbiter is more complex because it has more input ports. The dual Pentium, for instance, maintains a two-port arbiter at each chip entrance and requires that the two CPUs exchange synchronization messages before attempting to use the common bus. From the programming point of view, the arbiter is hidden because it is managed by hardware circuits.</p>
<h3 id="segmentation-in-hardware">Segmentation in Hardware<a class="headerlink" href="#segmentation-in-hardware" title="Permanent link">&para;</a></h3>
<p>Starting with the <a href="https://en.wikipedia.org/wiki/Intel_80286">80286</a> model, Intel microprocessors perform address translation in two different ways called <a href="https://en.wikipedia.org/wiki/Real_mode"><strong>real mode</strong></a> and <a href="https://en.wikipedia.org/wiki/Protected_mode"><strong>protected mode</strong></a>. The following sections focus on address translation when <strong>protected mode</strong> is enabled. Real mode exists mostly to maintain processor compatibility with older models and to allow the operating system to bootstrap.</p>
<h4 id="segment-selectors-and-segmentation-registers">Segment Selectors and Segmentation Registers<a class="headerlink" href="#segment-selectors-and-segmentation-registers" title="Permanent link">&para;</a></h4>
<p>A logical address consists of two parts:</p>
<ul>
<li>Segment identifier: 16-bit field called <strong>Segment Selector</strong> (<a href="#fast-access-to-segment-descriptors">described later</a>)</li>
<li>Offset: 32-bit field</li>
</ul>
<p><a href="../figure_2-2.png" title="Figure 2-2. Segment Selector format"><img alt="Figure 2-2. Segment Selector format" src="../figure_2-2_600.png" /></a></p>
<p>To retrieve segment selectors easily and quickly, the processor provides <strong>segmentation registers</strong> whose only purpose is to hold Segment Selectors:</p>
<ul>
<li><code>cs</code>: code segment register, which points to a segment containing program instructions<ul>
<li>It includes 2-bit field for CPU's <a href="https://en.wikipedia.org/wiki/Privilege_level">Current Privilege Level</a> (CPL), Linux uses only levels 0 and 3 for Kernel Mode and User Mode</li>
</ul>
</li>
<li><code>ss</code>: stack segment register, which points to a segment containing the current program stack</li>
<li><code>ds</code>: data segment register, which points to a segment containing global and static data</li>
<li><code>es</code>, <code>fs</code>, and <code>gs</code>: general purpose registers, which may refer to arbitrary data</li>
</ul>
<p>Despite only six of them, a program can reuse the same segmentation register for different purposes by saving its content in memory and then restoring it later.</p>
<h4 id="segment-descriptors">Segment Descriptors<a class="headerlink" href="#segment-descriptors" title="Permanent link">&para;</a></h4>
<p>Each segment is represented by an 8-byte <strong>Segment Descriptor</strong> that describes the segment characteristics. Segment Descriptors are stored either in the <a href="https://en.wikipedia.org/wiki/Global_Descriptor_Table"><strong>Global Descriptor Table</strong></a> (GDT) or in the <a href="https://en.wikipedia.org/wiki/Global_Descriptor_Table#Local_Descriptor_Table"><strong>Local Descriptor Table</strong></a> (LDT).</p>
<p>Usually only one GDT is defined, while each process is permitted to have its own LDT if it needs to create additional segments besides those stored in the GDT. The address and size of the GDT in main memory are contained in the <code>gdtr</code> <a href="https://en.wikipedia.org/wiki/Control_register">control register</a>, while the address and size of the currently used LDT are contained in the <code>ldtr</code> control register.</p>
<p>The Segment Descriptor format is illustrated in the following figure:</p>
<p><a href="../figure_2-3.png" title="Figure 2-3. Segment Descriptor format"><img alt="Figure 2-3. Segment Descriptor format" src="../figure_2-3_600.png" /></a></p>
<p>Segment Descriptor fields are explained in the following table:</p>
<table>
<thead>
<tr>
<th>Field name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Base</code></td>
<td>Contains the linear address of the first byte of the segment.</td>
</tr>
<tr>
<td><code>G</code></td>
<td><em>Granularity flag</em>: if it is cleared (equal to 0), the segment size is expressed in bytes; otherwise, it is expressed in multiples of 4096 bytes.</td>
</tr>
<tr>
<td><code>Limit</code></td>
<td>Holds the offset of the last memory cell in the segment, thus binding the segment length. When G is set to 0, the size of a segment may vary between 1 byte and 1 MB; otherwise, it may vary between 4 KB and 4 GB.</td>
</tr>
<tr>
<td><code>S</code></td>
<td><em>System flag</em>: if it is cleared, the segment is asystem segment that stores critical data structures such as the Local Descriptor Table; otherwise, it is a normal code or data segment.</td>
</tr>
<tr>
<td><code>Type</code></td>
<td>Characterizes the segment type and its access rights (see the text that follows this table).</td>
</tr>
<tr>
<td><code>DPL</code></td>
<td><em>Descriptor Privilege Level</em>: used to restrict accesses to the segment. It represents the minimal CPU privilege level requested for accessing the segment. Therefore, a segment with its DPL set to 0 is accessible only when the CPL is 0—that is, in Kernel Mode—while a segment with its DPL set to 3 is accessible with every CPL value.</td>
</tr>
<tr>
<td><code>P</code></td>
<td><em>Segment-Present flag</em>: is equal to 0 if the segment is not stored currently in main memory. Linux always sets this flag (bit 47) to 1, because it never swaps out whole segments to disk.</td>
</tr>
<tr>
<td><code>D</code> or <code>B</code></td>
<td>Called <code>D</code> or <code>B</code> depending on whether the segment contains code or data. Its meaning is slightly different in the two cases, but it is basically set (equal to 1) if the addresses used as segment offsets are 32 bits long, and it is cleared if they are 16 bits long (see the Intel manual for further details).</td>
</tr>
<tr>
<td><code>AVL</code></td>
<td>May be used by the operating system, but it is ignored by Linux.</td>
</tr>
</tbody>
</table>
<p>There are several types of segments, and thus several types of Segment Descriptors. The following list shows the types that are widely used in Linux:</p>
<ul>
<li><strong>Code Segment Descriptor</strong>: indicates that the Segment Descriptor refers to a code segment; included in GDT or LDT.<ul>
<li>This descriptor has the S flag set (non-system segment).</li>
</ul>
</li>
<li><strong>Data Segment Descriptor</strong>: indicates that the Segment Descriptor refers to a data segment; included in GDT or LDT<ul>
<li>This descriptor has the S flag set.</li>
<li>Stack segments are implemented by means of generic data segments.</li>
</ul>
</li>
<li><strong>Task State Segment Descriptor</strong> (TSSD): refers to a <a href="https://en.wikipedia.org/wiki/Task_state_segment">Task State Segment</a> (TSS), a segment used to save the contents of the processor registers; included in GDT only<ul>
<li>The corresponding <code>Type</code> field has the value 11 or 9, depending on whether the corresponding process is currently executing on a CPU.</li>
<li>The <code>S</code> flag of such descriptors is set to 0.</li>
</ul>
</li>
<li><strong>Local Descriptor Table Descriptor</strong> (LDTD): refers to a segment containing an LDT; included in GDT only<ul>
<li>The corresponding <code>Type</code> field has the value 2.</li>
<li>The <code>S</code> flag of such descriptors is set to 0.</li>
</ul>
</li>
</ul>
<h4 id="fast-access-to-segment-descriptors">Fast Access to Segment Descriptors<a class="headerlink" href="#fast-access-to-segment-descriptors" title="Permanent link">&para;</a></h4>
<p>Recall that <u>logical addresses consist of a 16-bit Segment Selector and a 32-bit Offset, and that segmentation registers store only the Segment Selector.</u></p>
<p>To speed up the translation of logical addresses into linear addresses, the 80×86 processor provides an additional nonprogrammable register, which cannot be set by a programmer, for each of the six programmable segmentation registers.</p>
<ol>
<li>Each nonprogrammable register contains the 8-byte Segment Descriptor specified by the Segment Selector contained in the corresponding segmentation register.</li>
<li>Every time a Segment Selector is loaded in a segmentation register, the corresponding Segment Descriptor is loaded from memory into the matching nonprogrammable CPU register.</li>
<li>From then on, translations of logical addresses referring to that segment can be performed without accessing the GDT or LDT stored in main memory; the processor can refer only directly to the CPU register containing the Segment Descriptor.</li>
<li>Accesses to the GDT or LDT are necessary only when the contents of the segmentation registers change.</li>
</ol>
<p>The Segment Selector includes three fields, described in the following table:</p>
<table>
<thead>
<tr>
<th>Field name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>index</code></td>
<td>Identifies the Segment Descriptor entry contained in the GDT or in the LDT.</td>
</tr>
<tr>
<td><code>TI</code></td>
<td><em>Table Indicator</em>: specifies whether the Segment Descriptor is included in the GDT (TI = 0) or in the LDT (<code>TI</code> = 1).</td>
</tr>
<tr>
<td><code>RPL</code></td>
<td><em>Requestor Privilege Level:</em> specifies the <a href="#cpl-rpl-and-registers">Current Privilege Level</a> (CPL)  of the CPU when the corresponding Segment Selector is loaded into the <code>cs</code> register; it also may be used to selectively weaken the processor privilege level when accessing data segments.</td>
</tr>
</tbody>
</table>
<p>Because a Segment Descriptor is 8 bytes long, its relative address inside the GDT or the LDT is obtained by multiplying the 13-bit <code>index</code> field (<a href="../figure_2-2.png">Figure 2-2</a>) of the Segment Selector by 8. For instance, if the GDT is at <code>0x00020000</code> (the value stored in the <code>gdtr</code> register) and the <code>index</code> specified by the Segment Selector is 2, the address of the corresponding Segment Descriptor is <code>0x00020000 + (2 × 8)</code>, or <code>0x00020010</code>.</p>
<p>The first entry of the GDT is always set to 0. This ensures that logical addresses with a null Segment Selector will be considered invalid, thus causing a processor exception. The maximum number of Segment Descriptors that can be stored in the GDT is 8,191 (2<sup>13</sup>–1).</p>
<h4 id="segmentation-unit">Segmentation Unit<a class="headerlink" href="#segmentation-unit" title="Permanent link">&para;</a></h4>
<p>The <strong>segmentation unit</strong> performs the following operations to obtain the linear address:</p>
<p><a href="../figure_2-5.png" title="Figure 2-5. Translating a logical address"><img alt="Figure 2-5. Translating a logical address" src="../figure_2-5_600.png" /></a></p>
<ul>
<li>Examines the <code>TI</code> field of the Segment Selector to determine which Descriptor Table (GDT or LDT) stores the Segment Descriptor.<ul>
<li>If the Descriptor is in the GDT, then the segmentation unit gets the base linear address of the GDT from the <code>gdtr</code> register.</li>
<li>If the Descriptor is in the active LDT, then the segmentation unit gets the base linear address of that LDT from the <code>ldtr</code> register.</li>
</ul>
</li>
<li>Computes the address of the Segment Descriptor from the <code>index</code> field of the Segment Selector.<ul>
<li>The <code>index</code> field is multiplied by 8 (the size of a Segment Descriptor), and the result is added to the content of the <code>gdtr</code> or <code>ldtr</code> register.</li>
</ul>
</li>
<li>Adds the offset of the logical address to the <code>Base</code> field of the Segment Descriptor to obtain the linear address.</li>
</ul>
<p>Thanks to the nonprogrammable registers associated with the segmentation registers, the first two operations need to be performed only when a segmentation register has been changed.</p>
<h3 id="segmentation-in-linux">Segmentation in Linux<a class="headerlink" href="#segmentation-in-linux" title="Permanent link">&para;</a></h3>
<p>Segmentation has been included in 80×86 microprocessors to encourage programmers to split their applications into logically related entities, such as subroutines or global and local data areas. However, Linux uses segmentation in a very limited way. Both segmentation and paging can be used to separate the physical address spaces of processes:</p>
<ul>
<li>Segmentation can assign a different linear address space to each process.</li>
<li>Paging can map the same linear address space into different physical address spaces.</li>
</ul>
<p>Linux prefers paging to segmentation for the following reasons:</p>
<ul>
<li>Memory management is simpler when all processes use the same segment register values: they share the same set of linear addresses.</li>
<li>Paging makes Linux is portable to a wide range of architectures; RISC architectures in particular have limited support for segmentation.</li>
</ul>
<p><u>The 2.6 version of Linux uses segmentation only when required by the 80×86 architecture.</u></p>
<ul>
<li>All Linux processes running in User Mode use the same pair of segments to address instructions and data, called <strong>user code segment</strong> and <strong>user data segment</strong>, respectively.</li>
<li>All Linux processes running in Kernel Mode use the same pair of segments to address instructions and data, called <strong>kernel code segment</strong> and <strong>kernel data segment</strong>, respectively.</li>
</ul>
<p>The following table shows the values of the Segment Descriptor fields for these four crucial segments.</p>
<table>
<thead>
<tr>
<th>Segment</th>
<th>Base</th>
<th>G</th>
<th>Limit</th>
<th>S</th>
<th>Type</th>
<th>DPL</th>
<th>D/B</th>
<th>P</th>
</tr>
</thead>
<tbody>
<tr>
<td>user code</td>
<td><code>0x00000000</code></td>
<td>1</td>
<td><code>0xfffff</code></td>
<td>1</td>
<td>10</td>
<td>3</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>user data</td>
<td><code>0x00000000</code></td>
<td>1</td>
<td><code>0xfffff</code></td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>kernel code</td>
<td><code>0x00000000</code></td>
<td>1</td>
<td><code>0xfffff</code></td>
<td>1</td>
<td>10</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>kernel data</td>
<td><code>0x00000000</code></td>
<td>1</td>
<td><code>0xfffff</code></td>
<td>1</td>
<td>2</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>Segment Selectors are defined by the macros:</p>
<ul>
<li><code>__USER_CS</code></li>
<li><code>__USER_DS</code></li>
<li><code>__KERNEL_CS</code></li>
<li><code>__KERNEL_DS</code></li>
</ul>
<p>To address the kernel code segment, for instance, the kernel just loads the value yielded by the <code>__KERNEL_CS</code> macro into the <code>cs</code> segmentation register.</p>
<p>The linear addresses associated with such segments all start at 0 and reach the addressing limit of 2<sup>32</sup> –1. This means that all processes, either in User Mode or in Kernel Mode, may use the same logical addresses.</p>
<p>Another important consequence of having all segments start at <code>0x00000000</code> is that in Linux, logical addresses coincide with linear addresses: the value of the Offset field of a logical address always coincides with the value of the corresponding linear address.</p>
<h4 id="cpl-rpl-and-registers"><a href="http://en.wikipedia.org/wiki/Protection_ring">CPL</a>, <code>RPL</code> and registers *<a class="headerlink" href="#cpl-rpl-and-registers" title="Permanent link">&para;</a></h4>
<p>The Current Privilege Level (CPL) of the CPU indicates whether the processor is in User or Kernel Mode and is specified by the <code>RPL</code> field of the Segment Selector stored in the <code>cs</code> register. [p42]</p>
<p>Whenever the CPL is changed, some segmentation registers must be correspondingly updated. For instance:</p>
<ul>
<li>When the CPL is equal to 3 (User Mode), the <code>ds</code> register must contain the Segment Selector of the user data segment; when the CPL is equal to 0, it must contain the Segment Selector of the kernel data segment.</li>
<li>When the CPL is 3, the <code>ss</code> must refer to a User Mode stack inside the user data segment; when the CPL is 0, it must refer to a Kernel Mode stack inside the kernel data segment. When switching from User Mode to Kernel Mode, Linux always makes sure that the <code>ss</code> register contains the Segment Selector of the kernel data segment.</li>
</ul>
<h4 id="implicit-segment-selector">Implicit Segment Selector *<a class="headerlink" href="#implicit-segment-selector" title="Permanent link">&para;</a></h4>
<p>When saving a pointer to an instruction or to a data structure, the kernel does not need to store the Segment Selector component of the logical address, because the <code>ss</code> register contains the current Segment Selector.</p>
<p>For example, when the kernel invokes a function, it executes a <code>call</code> assembly language instruction specifying only the Offset component of its logical address; the Segment Selector is implicitly selected as the one referred to by the <code>cs</code> register. Because there is only one segment of type "executable in Kernel Mode", namely the code segment identified by <code>__KERNEL_CS</code>, it is sufficient to load <code>__KERNEL_CS</code> into <code>cs</code> whenever the CPU switches to Kernel Mode.</p>
<p>The same argument goes for pointers to kernel data structures (implicitly using the <code>ds</code> register), as well as for pointers to user data structures (the kernel explicitly uses the <code>es</code> register).</p>
<ul>
<li><code>ss</code>: kernel saves a pointer to an instruction or to a data structure</li>
<li><code>cs</code>: kernel invokes a function</li>
<li><code>ds</code>: kernel data structure</li>
<li><code>es</code>: user data structure</li>
</ul>
<p>Besides the four segments described, Linux makes use of a few other specialized segments (discussed in The Linux GDT).</p>
<h4 id="the-linux-gdt">The Linux GDT<a class="headerlink" href="#the-linux-gdt" title="Permanent link">&para;</a></h4>
<p>In multiprocessor systems there is one GDT for every CPU [p43].</p>
<ul>
<li>All GDTs are stored in the <a href="https://github.com/shichao-an/linux-2.6.11.12/blob/master/arch/i386/kernel/head.S#L479"><code>cpu_gdt_table</code></a> array.</li>
<li>The addresses and sizes of the GDTs (used when initializing the <code>gdtr</code> registers) are stored in the <a href="https://github.com/shichao-an/linux-2.6.11.12/blob/master/arch/i386/kernel/head.S"><code>cpu_gdt_descr</code></a> array.</li>
</ul>
<p>These symbols are defined in the file <a href="https://github.com/shichao-an/linux-2.6.11.12/blob/master/arch/i386/kernel/head.S">arch/i386/kernel/head.S</a>.</p>
<p>The layout of the GDTs is shown schematically in the following figure:</p>
<p><a href="../figure_2-6.png" title="Figure 2-6. The Global Descriptor Table"><img alt="Figure 2-6. The Global Descriptor Table" src="../figure_2-6_600.png" /></a></p>
<p>Each GDT includes 18 segment descriptors and 14 null, unused, or reserved entries. Unused entries are inserted on purpose so that Segment Descriptors usually accessed together are kept in the same 32-byte line of the <a href="#hardware-cache">hardware cache</a>.</p>
<p>The 18 segment descriptors included in each GDT point to the following segments:</p>
<ul>
<li>Four user and kernel code and data segments (see <a href="#segmentation-in-linux">previous section</a>)</li>
<li><a href="https://en.wikipedia.org/wiki/Task_state_segment">Task State Segment</a> (TSS): different for each processor in the system.<ul>
<li>The linear address space corresponding to a TSS is a small subset of the linear address space corresponding to the kernel data segment.</li>
<li>The Task State Segments are sequentially stored in the <code>init_tss</code> array; in particular, the <code>Base</code> field of the TSS descriptor for the <em>n</em>th CPU points to the <em>n</em>th component of the <code>init_tss</code> array.</li>
<li>The <code>G</code> (granularity) flag is cleared, while the <code>Limit</code> field is set to <code>0xeb</code>, because the TSS segment is 236 bytes long.</li>
<li>The <code>Type</code> field is set to 9 or 11 (available 32-bit TSS), and the <code>DPL</code> is set to 0, because processes in User Mode are not allowed to access TSS segments.</li>
</ul>
</li>
<li>A segment including the default Local Descriptor Table (LDT), usually shared by all processes</li>
<li>Three <a href="https://en.wikipedia.org/wiki/Thread-local_storage">Thread-Local Storage</a> (TLS) segments: allows multithreaded applications to make use of up to three segments containing data local to each thread. The <code>set_thread_area()</code> and <code>get_thread_area()</code> system calls, respectively, create and release a TLS segment for the executing process.</li>
<li>Three segments related to <a href="https://en.wikipedia.org/wiki/Advanced_Power_Management">Advanced Power Management</a> (APM)</li>
<li>Five segments related to <a href="https://en.wikipedia.org/wiki/Plug_and_play">Plug and Play</a> (PnP) BIOS services</li>
<li>A special TSS segment used by the kernel to handle "Double fault" exceptions</li>
</ul>
<p>There is a copy of the GDT for each processor in the system. All copies of the GDT store identical entries, except for a few cases:</p>
<ol>
<li>Each processor has its own TSS segment, thus the corresponding GDT's entries differ.</li>
<li>A few entries in the GDT may depend on the process that the CPU is executing (LDT and TLS Segment Descriptors).</li>
<li>In some cases a processor may temporarily modify an entry in its copy of the GDT, for instance, when invoking an APM's BIOS procedure.</li>
</ol>
<h4 id="the-linux-ldts">The Linux LDTs<a class="headerlink" href="#the-linux-ldts" title="Permanent link">&para;</a></h4>
<p>Most Linux User Mode applications do not make use of a Local Descriptor Table. The kernel defines a default LDT to be shared by most processes. It has five entries but only two are used by the kernel:</p>
<ul>
<li>A <a href="http://en.wikipedia.org/wiki/Call_gate">call gate</a> for <a href="http://en.wikipedia.org/wiki/Intel_Binary_Compatibility_Standard">iBCS</a> executables</li>
<li>A call gate for Solaris/x86 executables</li>
</ul>
<p><strong>Call gates</strong> are a mechanism provided by 80×86 microprocessors to change the privilege level of the CPU while invoking a predefined function.</p>
<p>In some cases, processes may require to set up their own LDT, such as applications (such as <a href="https://en.wikipedia.org/wiki/Wine_(software)">Wine</a>) that execute segment-oriented Microsoft Windows applications. The <a href="http://man7.org/linux/man-pages/man2/modify_ldt.2.html"><code>modify_ldt()</code></a> system call allows a process to do this.</p>
<p>Any custom LDT created by <code>modify_ldt()</code> also requires its own segment. When a processor starts executing a process having a custom LDT, the LDT entry in the CPU-specific copy of the GDT is changed accordingly.</p>
<p>User Mode applications also may allocate new segments by means of <code>modify_ldt()</code>; the kernel, however, never makes use of these segments, and it does not have to keep track of the corresponding Segment Descriptors, because they are included in the custom LDT of the process.</p>
<h3 id="paging-in-hardware">Paging in Hardware<a class="headerlink" href="#paging-in-hardware" title="Permanent link">&para;</a></h3>
<p>The paging unit translates linear addresses into physical ones. Its key task is to check the requested access type against the access rights of the linear address, and generates a <a href="https://en.wikipedia.org/wiki/Page_fault">Page Fault</a> exception if memory access is not valid.</p>
<ul>
<li><strong>Pages</strong>: grouped fixed-length intervals of linear addresses; contiguous linear addresses within a page are mapped into contiguous physical addresses. The term "page" to refer both to a set of linear addresses and to the data contained in this group of addresses.</li>
<li><strong>Page frames</strong> (or <strong>physical pages</strong>): the paging unit thinks of all RAM as partitioned into fixed-length page frames.<ul>
<li>Each page frame contains a page, thus the length of a page frame coincides with that of a page.</li>
<li>A page frame is a constituent of main memory, and hence it is a storage area.</li>
<li>It is important to distinguish a page from a page frame: the former is just a block of data, which may be stored in any page frame or on disk.</li>
</ul>
</li>
<li><strong>Page table</strong>: data structures that map linear to physical addresses<ul>
<li>Page tables are stored in main memory and must be properly initialized by the kernel before enabling the paging unit.</li>
</ul>
</li>
</ul>
<p>Starting with the <a href="https://en.wikipedia.org/wiki/Intel_80386">80386</a>, all 80×86 processors support paging; it is enabled by setting the <code>PG</code> flag of a control register named <code>cr0</code>. When <code>PG = 0</code>, linear addresses are interpreted as physical addresses.</p>
<h4 id="regular-paging">Regular Paging<a class="headerlink" href="#regular-paging" title="Permanent link">&para;</a></h4>
<p>Starting with the 80386, the paging unit of Intel processors handles 4 KB pages.</p>
<p>The 32 bits of a linear address are divided into three fields:</p>
<ul>
<li><strong>Directory</strong>: the most significant 10 bits</li>
<li><strong>Table</strong>: the intermediate 10 bits</li>
<li><strong>Offset</strong>: the least significant 12 bits</li>
</ul>
<p>The translation of linear addresses is accomplished in two steps, each based on a
type of translation table.</p>
<ol>
<li>The first translation table is called the <strong>Page Directory</strong>.</li>
<li>The second is called the <strong>Page Table</strong>.</li>
</ol>
<p>In the following texts</p>
<ul>
<li>The lowercase "page table" term denotes any page storing the mapping between linear and physical addresses.</li>
<li>The capitalized "Page Table" term denotes a page in the last level of page tables.</li>
</ul>
<p>The aim of this two-level scheme is to reduce the amount of RAM required for per-process Page Tables:</p>
<ul>
<li>If a simple one-level Page Table was used, then it would require up to 2<sup>20</sup> entries (at 4 bytes per entry, 4 MB of RAM) to represent the Page Table for each process (if the process used a full 4 GB linear address space), even though a process does not use all addresses in that range.</li>
<li><u>The two-level scheme reduces the memory by requiring Page Tables only for those virtual memory regions actually used by a process.</u></li>
</ul>
<p>Each active process must have a Page Directory assigned to it. However, there is no need to allocate RAM for all Page Tables of a process at once; it is more efficient to allocate RAM for a Page Table only when the process effectively needs it.</p>
<ul>
<li>The physical address of the Page Directory in use is stored in a control register named <code>cr3</code>.</li>
<li>The Directory field within the linear address determines the entry in the Page Directory that points to the proper Page Table.</li>
<li>The Table field determines the entry in the Page Table that contains the physical address of the page frame containing the page.</li>
<li>The Offset field determines the relative position within the page frame (see the following figure).<ul>
<li>Because it is 12 bits long, each page consists of 4096 bytes of data.</li>
</ul>
</li>
</ul>
<p><a href="../figure_2-7.png" title="Figure 2-7. Paging by 80 × 86 processors"><img alt="Figure 2-7. Paging by 80 × 86 processors" src="../figure_2-7_600.png" /></a></p>
<p>Both the Directory and the Table fields are 10 bits long, so Page Directories and Page Tables can include up to 1,024 entries. Thus, a Page Directory can address up to 1024 × 1024 × 4096=2<sup>32</sup> memory cells, which is expected in 32-bit addresses.</p>
<p>The entries of Page Directories and Page Tables have the same structure. Each entry includes the following fields:</p>
<ul>
<li><code>Present</code> flag.<ul>
<li>If it is set, the referred-to page (or Page Table) is contained in main memory.</li>
<li>If it is 0, the page is not contained in main memory. The remaining entry bits may be used by the operating system for its own purposes.</li>
<li><u>If the entry of a Page Table or Page Directory needed to perform an address translation has the <code>Present</code> flag cleared, the paging unit stores the linear address in a control register named <code>cr2</code> and generates exception 14: the Page Fault exception.</u></li>
</ul>
</li>
<li>Field containing the 20 most significant bits of a page frame physical address.<ul>
<li><u>Because each page frame has a 4-KB capacity, its physical address must be a multiple of 4096, so the 12 least significant bits of the physical address are always equal to 0.</u></li>
<li>If the field refers to a Page Directory, the page frame contains a Page Table; if it refers to a Page Table, the page frame contains a page of data.</li>
</ul>
</li>
<li><code>Accessed</code> flag.<ul>
<li>This flag is set each time the paging unit addresses the corresponding page frame.</li>
<li>This flag may be used by the operating system when selecting pages to be swapped out.</li>
<li>The paging unit never resets this flag; this must be done by the operating system.</li>
</ul>
</li>
<li><code>Dirty</code> flag.<ul>
<li>This flag applies only to the Page Table entries. It is set each time a write operation is performed on the page frame.</li>
<li>As with the <code>Accessed</code> flag, <code>Dirty</code> may be used by the operating system when selecting pages to be swapped out.</li>
<li>The paging unit never resets this flag; this must be done by the operating system.</li>
</ul>
</li>
<li><code>Read/Write</code> flag.<ul>
<li>This flag contains the access right (Read/Write or Read) of the page or of the Page Table (see <a href="#hardware-protection-scheme">Hardware Protection Scheme</a>).</li>
</ul>
</li>
<li><code>User/Supervisor</code> flag.<ul>
<li>This flag contains the privilege level required to access the page or Page Table (see <a href="#hardware-protection-scheme">Hardware Protection Scheme</a>).</li>
</ul>
</li>
<li><code>PCD</code> and <code>PWT</code> flags<ul>
<li>The flags control the way the page or Page Table is handled by the hardware cache (see <a href="#hardware-cache">Hardware Cache</a>).</li>
</ul>
</li>
<li><code>Page Size</code> flag.<ul>
<li>This flag applies only to Page Directory entries. If it is set, the entry refers to a 2 MB (or 4 MB) long page frame (see the following sections).</li>
</ul>
</li>
<li><code>Global</code> flag.<ul>
<li>This applies only to Page Table entries.</li>
<li>This flag was introduced in the Pentium Pro to prevent frequently used pages from being flushed from the TLB cache (see <a href="#translation-lookaside-buffers">Translation Lookaside Buffers</a>).</li>
<li>It works only if the Page Global Enable (<code>PGE</code>) flag of register <code>cr4</code> is set.</li>
</ul>
</li>
</ul>
<p>The entries of Page Directories and Page Tables have the following structure:</p>
<p><a href="../figure_u2-1.png" title="Structure of a Page Directory and Page Table entry"><img alt="Structure of a Page Directory and Page Table entry" src="../figure_u2-1_600.png" /></a></p>
<h4 id="extended-paging">Extended Paging<a class="headerlink" href="#extended-paging" title="Permanent link">&para;</a></h4>
<p>Starting with the <a href="https://en.wikipedia.org/wiki/Pentium">Pentium</a> model, 80×86 microprocessors introduce <strong>extended paging</strong>, which allows page frames to be 4 MB instead of 4 KB in size, as show in the following figure:</p>
<p><a href="../figure_2-8.png" title="Figure 2-8. Extended paging"><img alt="Figure 2-8. Extended paging" src="../figure_2-8_600.png" /></a></p>
<p>Extended paging is used to translate large contiguous linear address ranges into corresponding physical ones. The kernel can do without intermediate Page Tables and thus save memory and preserve TLB entries.</p>
<p>As mentioned in the previous section, extended paging is enabled by setting the <code>Page Size</code> flag of a Page Directory entry. In this case, the paging unit divides the 32 bits of a linear address into two fields:</p>
<ul>
<li>Directory: the most significant 10 bits</li>
<li>Offset: the remaining 22 bits</li>
</ul>
<p>Page Directory entries for extended paging are the same as for normal paging, except that:</p>
<ul>
<li>The Page Size flag must be set.</li>
<li>Only the 10 most significant bits of the 20-bit physical address field are significant. This is because each physical address is aligned on a 4-MB boundary, so the 22 least significant bits of the address are 0.</li>
</ul>
<div class="codehilite"><pre>           |      Field       |
Regular    XXXXXXXXXXXXXXXXXXXX000000000000
           |      20 SGFNT    |

           |      Field       |
Extended   XXXXXXXXXX0000000000000000000000
           |10 SGFNT|
</pre></div>


<h4 id="hardware-protection-scheme">Hardware Protection Scheme<a class="headerlink" href="#hardware-protection-scheme" title="Permanent link">&para;</a></h4>
<p>The paging unit uses a different protection scheme from the segmentation unit.  While 80×86 processors allow four possible privilege levels to a segment, only two privilege levels are associated with pages and Page Tables, because privileges are controlled by the <code>User/Supervisor</code> flag mentioned in <a href="#regular-paging">Regular Paging</a>:</p>
<ul>
<li>When this flag is 0, the page can be addressed only when the CPL is less than 3 (this means, for Linux, when the processor is in Kernel Mode).</li>
<li>When the flag is 1, the page can always be addressed.</li>
</ul>
<p>Instead of the three types of access rights (Read, Write, and Execute) associated with segments, only two types of access rights (Read and Write) are associated with pages:</p>
<ul>
<li>If the <code>Read/Write</code> flag of a Page Directory or Page Table entry is equal to 0, the corresponding Page Table or page can only be read.</li>
<li>If the <code>Read/Write</code> flag is equal to 1, it can be read and written.</li>
</ul>
<h4 id="an-example-of-regular-paging">An Example of Regular Paging<a class="headerlink" href="#an-example-of-regular-paging" title="Permanent link">&para;</a></h4>
<p>This section help you understand how regular paging works. Assume that the kernel assigns the linear address space between <code>0x20000000</code> and <code>0x2003ffff</code> to a running process. (The 3 GB linear address space is an upper limit, but a User Mode process is allowed to reference only a subset of it.) This space consists of exactly 64 pages. We don't care about the physical addresses of the page frames containing the pages; in fact, some of them might not even be in main memory. We are interested only in the remaining fields of the Page Table entries.</p>
<h5 id="directory-field"><strong>Directory field</strong> *<a class="headerlink" href="#directory-field" title="Permanent link">&para;</a></h5>
<p>The 10 most significant bits of the linear addresses assigned to the process are the Directory field (interpreted by the paging unit).</p>
<ul>
<li>The addresses start with a 2 followed by zeros, so the 10 bits all have the same value, namely <code>0x080</code> or 128 decimal.<ul>
<li>Thus the Directory field in all the addresses refers to the 129th entry of the process Page Directory.</li>
<li>The corresponding entry must contain the physical address of the Page Table assigned to the process (see the following figure).</li>
</ul>
</li>
<li>If no other linear addresses are assigned to the process, all the remaining 1,023 entries of the Page Directory are filled with zeros.</li>
</ul>
<p><a href="../figure_2-9.png" title="Figure 2-9. An example of paging"><img alt="Figure 2-9. An example of paging" src="../figure_2-9_600.png" /></a></p>
<h5 id="table-field"><strong>Table field</strong> *<a class="headerlink" href="#table-field" title="Permanent link">&para;</a></h5>
<p>The values of the intermediate 10 bits, Table field, range from 0 to <code>0x03f</code>, or from 0 to 63 decimal. Thus, only the first 64 entries of the Page Table are valid. The remaining 960 entries are filled with zeros.</p>
<p>Suppose that the process needs to read the byte at linear address <code>0x20021406</code>. This address is handled by the paging unit as follows:</p>
<ol>
<li>The Directory field <code>0x80</code> is used to select entry <code>0x80</code> of the Page Directory, which points to the Page Table associated with the process's pages.</li>
<li>The Table field <code>0x21</code> is used to select entry <code>0x21</code> of the Page Table, which points to the page frame containing the desired page.</li>
<li>Finally, the Offset field <code>0x406</code> is used to select the byte at offset <code>0x406</code> in the desired page frame.</li>
</ol>
<h5 id="page-fault-exception"><strong>Page Fault exception</strong> *<a class="headerlink" href="#page-fault-exception" title="Permanent link">&para;</a></h5>
<p>The paging unit issues a Page Fault exception while translating the linear address in the following two cases:</p>
<ul>
<li>If the <code>Present</code> flag of the <code>0x21</code> entry of the Page Table is cleared, then the page is not present in main memory.</li>
<li>The process attempts to access linear addresses outside of the interval delimited by <code>0x20000000</code> and <code>0x2003ffff</code>. Because the Page Table entries not assigned to the process are filled with zeros, their <code>Present</code> flags are all cleared.</li>
</ul>
<h4 id="the-physical-address-extension-pae-paging-mechanism">The Physical Address Extension (PAE) Paging Mechanism<a class="headerlink" href="#the-physical-address-extension-pae-paging-mechanism" title="Permanent link">&para;</a></h4>
<p>The amount of RAM supported by a processor is limited by the number of address pins connected to the address bus. Older Intel processors from the 80386 to the Pentium used 32-bit physical addresses. In theory, up to 4 GB of RAM could be installed on such systems; in practice, <u>due to the linear address space requirements of User Mode processes, the kernel cannot directly address more than 1 GB of RAM</u>, as we will see in the later section <a href="#paging-in-linux">Paging in Linux</a>.</p>
<p>However, big servers require more than 4 GB of RAM, which in recent years created a pressure on Intel to expand the amount of RAM supported on the 32-bit 80×86 architecture. Intel has satisfied these requests by increasing the number of address pins on its processors from 32 to 36. Starting with the <a href="https://en.wikipedia.org/wiki/Pentium_Pro">Pentium Pro</a>, all Intel processors are now able to address up to 2<sup>36</sup> = 64 GB of RAM. However, the increased range of physical addresses can be exploited only by introducing a new paging mechanism that translates 32-bit linear addresses into 36-bit physical ones.</p>
<p>With the Pentium Pro processor, Intel introduced a mechanism called <a href="https://en.wikipedia.org/wiki/Physical_Address_Extension">Physical Address Extension</a> (PAE). (Another mechanism, Page Size Extension (PSE-36), introduced in the Pentium III processor, is not used by Linux, and is thus ignored in this book.)</p>
<p>PAE is activated by setting the Physical Address Extension (<code>PAE</code>) flag in the <code>cr4</code> control register. The Page Size (<code>PS</code>) flag in the page directory entry enables large page sizes (2 MB when PAE is enabled).</p>
<p>Intel has changed the paging mechanism in order to support PAE.</p>
<ul>
<li>The 64 GB of RAM are split into 2<sup>24</sup> distinct page frames, and the physical address field of Page Table entries has been expanded from 20 to 24 bits.<ul>
<li>A PAE Page Table entry must include the 12 flag bits (32 - 20 (<code>Field</code>) = 12, see <a href="#regular-paging">Regular Paging</a>) and the 24 physical address bits, for a total of 36 bits, so the Page Table entry size has been doubled from 32 bits to 64 bits. As a result, a 4-KB PAE Page Table includes 512 entries instead of 1,024.</li>
</ul>
</li>
<li>A new level of Page Table called the Page Directory Pointer Table (PDPT) consisting of four 64-bit entries has been introduced.</li>
<li>The <code>cr3</code> control register contains a 27-bit Page Directory Pointer Table base address field. Because PDPTs are stored in the first 4 GB of RAM and aligned to a multiple of 32 bytes (2<sup>5</sup>) (because each PDPT has four 8-byte entries), 27 bits are sufficient to represent the base address of such tables.</li>
<li>When mapping linear addresses to 4 KB pages (<code>PS</code> flag cleared in Page Directory entry), the 32 bits of a linear address are interpreted in the following way:<ul>
<li><code>cr3</code>: points to a PDPT</li>
<li>bits 31–30: point to 1 of 4 possible entries in PDPT</li>
<li>bits 29–21: point to 1 of 512 possible entries in Page Directory</li>
<li>bits 20–12: point to 1 of 512 possible entries in Page Table</li>
<li>bits 11–0: Offset of 4-KB page</li>
</ul>
</li>
<li>When mapping linear addresses to 2-MB pages (<code>PS</code> flag set in Page Directory entry), the 32 bits of a linear address are interpreted in the following way:<ul>
<li><code>cr3</code>: points to a PDPT</li>
<li>bits 31–30: point to 1 of 4 possible entries in PDPT</li>
<li>bits 29–21: point to 1 of 512 possible entries in Page Directory</li>
<li>bits 20–0: Offset of 2-MB page</li>
</ul>
</li>
</ul>
<p>Once <code>cr3</code> is set, it is possible to address up to 4 GB of RAM. If we want to address more RAM, we'll have to put a new value in <code>cr3</code> or change the content of the PDPT.</p>
<p>However, the main problem with PAE is that linear addresses are still 32 bits long. This forces kernel programmers to reuse the same linear addresses to map different areas of RAM.</p>
<ul>
<li>How Linux initializes Page Tables when PAE is enabled is discussed in section <a href="#final-kernel-page-table-when-ram-size-is-more-than-4096-mb">Final kernel Page Table when RAM size is more than 4096 MB</a>.</li>
<li>PAE does not enlarge the linear address space of a process, because it deals only with physical addresses.</li>
<li>Only the kernel can modify the page tables of the processes, thus a process running in User Mode cannot use a physical address space larger than 4 GB.</li>
<li>On the other hand, PAE allows the kernel to exploit up to 64 GB of RAM, and thus to increase significantly the number of processes in the system.</li>
</ul>
<h4 id="paging-for-64-bit-architectures">Paging for 64-bit Architectures<a class="headerlink" href="#paging-for-64-bit-architectures" title="Permanent link">&para;</a></h4>
<p>As seen in previous sections, two-level paging is commonly used by 32-bit microprocessors and is not suitable for computers that adopt a 64-bit architecture. (The third level of paging present in 80x86 processors with PAE enabled has been introduced only to lower from 1024 to 512 the number of entries in the Page Directory and Page Tables. This enlarges the Page Table entries from 32 bits to 64 bits so that they can store the 24 most significant bits of the physical address.)</p>
<p>Assume for a 64-bit architecture, the standard page size is 4 KB, so the Offset field is 12 bits. This leaves up to 52 bits of the linear address to be distributed between the Table and the Directory fields. If we use only 48 of the 64 bits for addressing (256 TB address space), the remaining 48-12 = 36 bits will have to be split among Table and the Directory fields. If we reserve 18 bits for each of these two fields, both the Page Directory and the Page Tables of each process should include 2<sup>18</sup> entries, which more than 256,000 entries.</p>
<p>For that reason, all hardware paging systems for 64-bit processors make use of additional paging levels. The number of levels used depends on the type of processor. The following table summarizes the main characteristics of the hardware paging systems used by some 64-bit platforms supported by Linux. See section <a href="../ch1/#hardware-dependency">Hardware Dependency</a> in Chapter 1 for a short description of the hardware associated with the platform name.</p>
<h5 id="paging-levels-in-some-64-bit-architectures"><strong>Paging levels in some 64-bit architectures</strong> *<a class="headerlink" href="#paging-levels-in-some-64-bit-architectures" title="Permanent link">&para;</a></h5>
<table>
<thead>
<tr>
<th>Platform name</th>
<th>Page size</th>
<th>Number of address bits used</th>
<th>Number of paging levels</th>
<th>Linear address splitting</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>alpha</code></td>
<td>8 KB</td>
<td>43</td>
<td>3</td>
<td>10 + 10 + 10 + 13</td>
</tr>
<tr>
<td><code>ia64</code></td>
<td>4 KB</td>
<td>39</td>
<td>3</td>
<td>9 + 9 + 9 + 12</td>
</tr>
<tr>
<td><code>ppc64</code></td>
<td>4 KB</td>
<td>41</td>
<td>3</td>
<td>10 + 10 + 9 + 12</td>
</tr>
<tr>
<td><code>sh64</code></td>
<td>4 KB</td>
<td>41</td>
<td>3</td>
<td>10 + 10 + 9 + 12</td>
</tr>
<tr>
<td><code>x86_64</code></td>
<td>4 KB</td>
<td>48</td>
<td>4</td>
<td>9 + 9 + 9 + 9 + 12</td>
</tr>
</tbody>
</table>
<p>As we will see in the section <a href="#paging-in-linux">Paging in Linux</a> later in this chapter, Linux succeeds in providing a common paging model that fits most of the supported hardware paging systems.</p>
<h4 id="hardware-cache">Hardware Cache<a class="headerlink" href="#hardware-cache" title="Permanent link">&para;</a></h4>
<p>Today's microprocessors have clock rates of several gigahertz (GHz), while <a href="https://en.wikipedia.org/wiki/Dynamic_random-access_memory">dynamic RAM</a> (DRAM) chips have access times in the range of hundreds of clock cycles. This means that the CPU may be held back considerably while executing instructions that require fetching operands from RAM and/or storing results into RAM.</p>
<p>Hardware cache memories were introduced to reduce the speed mismatch between CPU and RAM. They are based on the well-known <a href="https://en.wikipedia.org/wiki/Locality_of_reference">locality principle</a>, which holds both for programs and data structures. This states that because of the cyclic structure of programs and the packing of related data into linear arrays, addresses close to the ones most recently used have a high probability of being used in the near future. It makes sense to introduce a smaller and faster memory that contains the most recently used code and data. Therefore, a new unit called the <a href="https://en.wikipedia.org/wiki/CPU_cache#Cache_entries"><em>line</em></a> was introduced into the 80×86 architecture. It consists of a few dozen contiguous bytes that are transferred in <a href="https://en.wikipedia.org/wiki/Burst_mode_(computing)">burst mode</a> between the slow DRAM and the fast on-chip static RAM (SRAM) used to implement caches.</p>
<p>The cache is subdivided into subsets of lines:</p>
<ul>
<li>At one extreme, the cache can be <strong>direct mapped</strong>, in which case a line in main memory is always stored at the exact same location in the cache.</li>
<li>At the other extreme, the cache is <strong>fully associative</strong>, meaning that any line in memory can be stored at any location in the cache.</li>
<li>Most caches are to some degree <strong>N-way set associative</strong>, where any line of main memory can be stored in any one of <em>N</em> lines of the cache.<ul>
<li>For instance, a line of memory can be stored in two different lines of a two-way set associative cache.</li>
</ul>
</li>
</ul>
<p><a href="../figure_2-10.png" title="Figure 2-10. Processor hardware cache"><img alt="Figure 2-10. Processor hardware cache" src="../figure_2-10_600.png" /></a></p>
<p>As shown in the figure above, the cache unit is inserted between the paging unit and the main memory.</p>
<p>The cache unit includes:</p>
<ul>
<li>A <strong>hardware cache</strong> memory, which stores actual lines of memory.</li>
<li>A <strong>cache controller</strong>, which stores an array of entries, one entry for each line of the cache memory.<ul>
<li>Each entry includes a <em>tag</em> and a few flags that describe the status of the cache line.</li>
<li>The tag consists of some bits that allow the cache controller to recognize the memory location currently mapped by the line.</li>
<li>The bits of the memory's physical address are usually split into three groups:<ul>
<li>The most significant ones correspond to the tag</li>
<li>The middle ones to the cache controller subset index</li>
<li>The least significant ones to the offset within the line</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>When accessing a RAM memory cell, the CPU extracts the subset index from the physical address and compares the tags of all lines in the subset with the high-order bits of the physical address:</p>
<ul>
<li>If a line with the same tag as the high-order bits of the address is found, the CPU has a <em>cache hit</em>.</li>
<li>Otherwise, it has a <em>cache miss</em>.</li>
</ul>
<p>When a cache hit occurs, the cache controller behaves differently, depending on the access type:</p>
<ul>
<li>For a read operation, the controller selects the data from the cache line and transfers it into a CPU register; the RAM is not accessed and the CPU saves time.</li>
<li>
<p>For a write operation, the controller may implement one of <a href="https://en.wikipedia.org/wiki/Cache_(computing)#Writing_policies">two basic strategies</a> called <em>write-through</em> and <em>write-back</em>.</p>
<ul>
<li>In a write-through, the controller always writes into both RAM and the cache line, effectively switching off the cache for write operations.</li>
<li>In a write-back, which offers more immediate efficiency, only the cache line is updated and the contents of the RAM are left unchanged. After a write-back, the RAM must eventually be updated.</li>
</ul>
<p>The cache controller writes the cache line back into RAM only when the CPU executes an instruction requiring a flush of cache entries or when a FLUSH hardware signal occurs (usually after a cache miss).</p>
</li>
</ul>
<p>When a cache miss occurs, the cache line is written to memory if necessary, and the correct line is fetched from RAM into the cache entry.</p>
<p>Multiprocessor systems have a separate hardware cache for every processor, and therefore they need additional hardware circuitry to synchronize the cache contents.</p>
<p>As shown in the figure below, each CPU has its own local hardware cache. Whenever a CPU modifies its hardware cache, it must check whether the same data is contained in the other hardware cache; if so, it must notify the other CPU to update it with the proper value. This activity is often called <a href="https://en.wikipedia.org/wiki/Cache_coherence#Coherency_mechanisms"><em>cache snooping</em></a>. Luckily, all this is done at the hardware level and is of no concern to the kernel.</p>
<p><a href="../figure_2-11.png" title="Figure 2-11. The caches in a dual processor"><img alt="Figure 2-11. The caches in a dual processor" src="../figure_2-11_600.png" /></a></p>
<p>Cache technology is rapidly evolving. For example, the first Pentium models included a single on-chip cache called the <strong>L1-cache</strong>. More recent models also include other larger, slower on-chip caches called the <strong>L2-cache</strong>, <strong>L3-cache</strong>, etc. The consistency between the cache levels is implemented at the hardware level. Linux ignores these hardware details and assumes there is a single cache.</p>
<ul>
<li>The <code>CD</code> flag of the <code>cr0</code> processor register is used to enable or disable the cache circuitry.</li>
<li>The <code>NW</code> flag, in the same register, specifies whether the write-through or the write-back strategy is used for the caches.</li>
</ul>
<p>The Pentium cache is lets an operating system associate a different cache management policy with each page frame. For this purpose, each Page Directory and each Page Table entry includes two flags:</p>
<ul>
<li><code>PCD</code> (Page Cache Disable), which specifies whether the cache must be enabled or disabled while accessing data included in the page frame</li>
<li><code>PWT</code> (Page Write-Through), which specifies whether the write-back or the write-through strategy must be applied while writing data into the page frame.</li>
</ul>
<p>Linux clears the <code>PCD</code> and <code>PWT</code> flags of all Page Directory and Page Table entries; as a result, caching is enabled for all page frames, and the write-back strategy is always adopted for writing.</p>
<h4 id="translation-lookaside-buffers-tlb">Translation Lookaside Buffers (TLB)<a class="headerlink" href="#translation-lookaside-buffers-tlb" title="Permanent link">&para;</a></h4>
<p>Besides general-purpose hardware caches, 80×86 processors include another cache called <a href="https://en.wikipedia.org/wiki/Translation_lookaside_buffer">Translation Lookaside Buffers</a> (TLB) to speed up linear address translation. When a linear address is used for the first time, the corresponding physical address is computed through slow accesses to the Page Tables in RAM. The physical address is then stored in a TLB entry so that further references to the same linear address can be quickly translated.</p>
<p>In a multiprocessor system, each CPU has its own TLB, called the <em>local TLB</em> of the CPU. Contrary to the hardware cache, the corresponding entries of the TLB need not be synchronized, because processes running on the existing CPUs may associate the same linear address with different physical ones.</p>
<p>When the <code>cr3</code> control register of a CPU is modified, the hardware automatically invalidates all entries of the local TLB, because a new set of page tables is in use and the TLBs are pointing to old data.</p>
<h3 id="paging-in-linux">Paging in Linux<a class="headerlink" href="#paging-in-linux" title="Permanent link">&para;</a></h3>
<p>Linux adopts a common paging model that fits both 32-bit and 64-bit architectures.  As explained in section <a href="#paging-for-64-bit-architectures">Paging for 64-bit Architectures</a>, two paging levels are sufficient for 32-bit architectures, while 64-bit architectures require a higher number of paging levels.</p>
<ul>
<li>Up to version 2.6.10, the Linux paging model consisted of three paging levels.</li>
<li>Starting with version 2.6.11, a four-level paging model has been adopted.<ul>
<li>This change has been made to fully support the linear address bit splitting used by the x86_64 platform. See <a href="#paging-levels-in-some-64-bit-architectures">table</a>.</li>
</ul>
</li>
</ul>
<p>The four types of page tables (as shown in the following figure) are:</p>
<ul>
<li>Page Global Directory</li>
<li>Page Upper Directory</li>
<li>Page Middle Directory</li>
<li>Page Table</li>
</ul>
<p><a href="../figure_2-12.png" title="Figure 2-12. The Linux paging model"><img alt="Figure 2-12. The Linux paging model" src="../figure_2-12_600.png" /></a></p>
<ul>
<li>The Page Global Directory includes the addresses of several Page Upper Directories, which in turn include the addresses of several Page Middle Directories, which in turn include the addresses of several Page Tables.</li>
<li>Each Page Table entry points to a page frame.</li>
<li>Thus the linear address can be split into up to five parts. The above figure does not show the bit numbers, because the size of each part depends on the computer architecture.</li>
</ul>
<p>For 32-bit architectures with no Physical Address Extension, two paging levels are sufficient:</p>
<ul>
<li>Linux essentially eliminates the Page Upper Directory and the Page Middle Directory fields (so that the same code can work on 32-bit and 64-bit architectures) by saying that they contain zero bits.</li>
<li>The kernel keeps a position for the Page Upper Directory and the Page Middle Directory by setting the number of entries in them to 1 and mapping these two entries into the proper entry of the Page Global Directory.</li>
</ul>
<p>For 32-bit architectures with the Physical Address Extension enabled, three paging levels are used:</p>
<ul>
<li>The Linux's Page Global Directory corresponds to the 80×86's Page Directory Pointer Table.</li>
<li>The Page Upper Directory is eliminated.</li>
<li>The Page Middle Directory corresponds to the 80×86's Page Directory.</li>
<li>The Linux's Page Table corresponds to the 80×86's Page Table.</li>
</ul>
<p>For 64-bit architectures three or four levels of paging are used depending on the linear address bit splitting performed by the hardware (see <a href="#paging-levels-in-some-64-bit-architectures">table</a>).</p>
<p>Linux's handling of processes relies heavily on paging. In fact, the automatic translation of linear addresses into physical ones makes the following design objectives feasible:</p>
<ul>
<li>Assign a different physical address space to each process, ensuring an efficient protection against addressing errors.</li>
<li><u>Distinguish pages (groups of data) from page frames (physical addresses in main memory). This allows the same page to be stored in a page frame, then saved to disk and later reloaded in a different page frame. This is the basic ingredient of the virtual memory mechanism.</u></li>
</ul>
<p>In the remaining part of this chapter, we will refer to the paging circuitry used by the 80×86 processors.</p>
<p>Each process has its own Page Global Directory and its own set of Page Tables. <u>When a process switch occurs, Linux saves the <code>cr3</code> control register in the descriptor of the process previously in execution and then loads <code>cr3</code> with the value stored in the descriptor of the process to be executed next. Thus, when the new process resumes its execution on the CPU, the paging unit refers to the correct set of Page Tables.</u></p>
<p>Mapping linear to physical addresses now becomes a mechanical task, although it is still somewhat complex. The next few sections of this chapter are a list of functions and macros that retrieve information the kernel needs to find addresses and manage the tables.</p>
<h4 id="the-linear-address-fields">The Linear Address Fields<a class="headerlink" href="#the-linear-address-fields" title="Permanent link">&para;</a></h4>
<p>The following macros simplify Page Table handling:</p>
<ul>
<li><code>PAGE_SHIFT</code>: specifies the length in bits of the Offset field. When applied to 80×86 processors, it yields the value 12.<ul>
<li>Because all the addresses in a page must fit in the Offset field, the size of a page on 80×86 systems is 2<sup>12</sup> or 4,096 bytes</li>
<li>The <code>PAGE_SHIFT</code> of 12 can be considered the logarithm base 2 of the total page size.</li>
<li>This macro is used by <code>PAGE_SIZE</code> to return the size of the page.</li>
<li>The <code>PAGE_MASK</code> macro yields the value <code>0xfffff000</code> and is used to mask all the bits of the Offset field.</li>
</ul>
</li>
<li><code>PMD_SHIFT</code>: the total length in bits of the Offset and Table fields of a linear address, which is the logarithm of the size of the area a Page Middle Directory entry can map.<ul>
<li>The <code>PMD_SIZE</code> macro computes the size of the area mapped by a single entry of the Page Middle Directory, that is, of a Page Table.</li>
<li>The <code>PMD_MASK</code> macro is used to mask all the bits of the Offset and Table fields.</li>
<li>When PAE is disabled:<ul>
<li><code>PMD_SHIFT</code> yields the value 22 (12 from Offset plus 10 from Table).</li>
<li><code>PMD_SIZE</code> yields 2<sup>22</sup> or 4 MB.</li>
<li><code>PMD_MASK</code> yields <code>0xffc00000</code>.</li>
</ul>
</li>
<li>When PAE is enabled:<ul>
<li><code>PMD_SHIFT</code> yields the value 21 (12 from Offset plus 9 from Table).</li>
<li><code>PMD_SIZE</code> yields 2<sup>21</sup> or 2 MB.</li>
<li><code>PMD_MASK</code> yields <code>0xffe00000</code>.</li>
</ul>
</li>
<li>Large pages do not make use of the last level of page tables:<ul>
<li><code>LARGE_PAGE_SIZE</code>, which yields the size of a large page, is equal to <code>PMD_SIZE</code> (2<sup><code>PMD_SHIFT</code></sup>).</li>
<li><code>LARGE_PAGE_MASK</code>, which is used to mask all the bits of the Offset and Table fields in a large page address, is equal to <code>PMD_MASK</code>.</li>
</ul>
</li>
</ul>
</li>
<li><code>PUD_SHIFT</code>: determines the logarithm of the size of the area a Page Upper Directory entry can map.<ul>
<li>The <code>PUD_SIZE</code> macro computes the size of the area mapped by a single entry of the Page Global Directory.</li>
<li>The <code>PUD_MASK</code> macro is used to mask all the bits of the Offset, Table, and Page Middle Directory fields.</li>
<li>On the 80×86 processors, <code>PUD_SHIFT</code> is always equal to <code>PMD_SHIFT</code>, and <code>PUD_SIZE</code> is equal to 4 MB or 2 MB.</li>
</ul>
</li>
<li><code>PGDIR_SHIFT</code>: determines the logarithm of the size of the area that a Page Global Directory entry can map.<ul>
<li>The <code>PGDIR_SIZE</code> macro computes the size of the area mapped by a single entry of the Page Global Directory.</li>
<li>The <code>PGDIR_MASK</code> macro is used to mask all the bits of the Offset, Table, Page Middle Directory, and PageUpper Directory fields.</li>
<li>When PAE is disabled:<ul>
<li><code>PGDIR_SHIFT</code> yields the value 22 (the same value yielded by <code>PMD_SHIFT</code> and by <code>PUD_SHIFT</code>)</li>
<li><code>PGDIR_SIZE</code> yields 2<sup>22</sup> or 4 MB, and <code>PGDIR_MASK</code> yields <code>0xffc00000</code>.</li>
</ul>
</li>
<li>When PAE is enabled:<ul>
<li><code>PGDIR_SHIFT</code> yields the value 30 (12 from Offset plus 9 from Table plus 9 from Page Middle Directory).</li>
<li><code>PGDIR_SIZE</code> yields 2<sup>30</sup> or 1 GB.</li>
<li><code>PGDIR_MASK</code> yields <code>0xc0000000</code>.</li>
</ul>
</li>
</ul>
</li>
<li><code>PTRS_PER_PTE</code>, <code>PTRS_PER_PMD</code>, <code>PTRS_PER_PUD</code>, and <code>PTRS_PER_PGD</code>: compute the number of entries in the Page Table, Page Middle Directory, Page Upper Directory, and Page Global Directory.<ul>
<li>When PAE is disabled, they yield the values 1,024, 1, 1, and 1,024, respectively.</li>
<li>When PAE is enabled, they yield the values 512, 512, 1, and 4, respectively.</li>
</ul>
</li>
</ul>
<h5 id="summary-of-linear-address-fields"><strong>Summary of linear address fields</strong> *<a class="headerlink" href="#summary-of-linear-address-fields" title="Permanent link">&para;</a></h5>
<p>For regular paging, the number of bits for each field in the linear address are:</p>
<table>
<thead>
<tr>
<th>PAE</th>
<th>Page Global Directory</th>
<th>Page Upper Directory</th>
<th>Page Middle Directory</th>
<th>Page Table</th>
<th>Offset</th>
</tr>
</thead>
<tbody>
<tr>
<td>Disabled</td>
<td>10</td>
<td>0</td>
<td>0</td>
<td>10</td>
<td>12</td>
</tr>
<tr>
<td>Enabled</td>
<td>2</td>
<td>0</td>
<td>9</td>
<td>9</td>
<td>12</td>
</tr>
</tbody>
</table>
<p>For extended paging (large pages), the number of bits for each field in the linear address are:</p>
<table>
<thead>
<tr>
<th>PAE</th>
<th>Page Global Directory</th>
<th>Page Upper Directory</th>
<th>Page Middle Directory</th>
<th>Offset</th>
</tr>
</thead>
<tbody>
<tr>
<td>Disabled</td>
<td>10</td>
<td>0</td>
<td>0</td>
<td>22</td>
</tr>
<tr>
<td>Enabled</td>
<td>2</td>
<td>0</td>
<td>9</td>
<td>21</td>
</tr>
</tbody>
</table>
<h4 id="page-table-handling">Page Table Handling<a class="headerlink" href="#page-table-handling" title="Permanent link">&para;</a></h4>
<p><code>pte_t</code>, <code>pmd_t</code>, <code>pud_t</code>, and <code>pgd_t</code> describe the format of a Page Table, a Page Middle Directory, a Page Upper Directory, and a Page Global Directory entry, respectively. They are 64-bit data types when PAE is enabled and 32-bit data types otherwise. <code>pgprot_t</code> is another 64-bit (PAE enabled) or 32-bit (PAE disabled) data type that represents the protection flags associated with a single entry.</p>
<ul>
<li>Five type-conversion macros, <code>__pte</code>, <code>__pmd</code>, <code>__pud</code>, <code>__pgd</code>, and <code>__pgprot</code>, cast an unsigned integer into the required type.</li>
<li>Five other type-conversion macros, <code>pte_val</code>, <code>pmd_val</code>, <code>pud_val</code>, <code>pgd_val</code>, and <code>pgprot_val</code>, perform the reverse casting from one of the four previously mentioned specialized types into an unsigned integer</li>
</ul>
<p>The kernel also provides several macros and functions to read or modify page table entries:</p>
<ul>
<li><code>pte_none</code>, <code>pmd_none</code>, <code>pud_none</code>, and <code>pgd_none</code> yield the value 1 if the corresponding entry has the value 0; otherwise, they yield the value 0.</li>
<li><code>pte_clear</code>, <code>pmd_clear</code>, <code>pud_clear</code>, and <code>pgd_clear</code> clear an entry of the corresponding page table, thus forbidding a process to use the linear addresses mapped by the page table entry.<ul>
<li>The <code>ptep_get_and_clear()</code> function clears a Page Table entry and returns the previous value.</li>
</ul>
</li>
<li><code>set_pte</code>, <code>set_pmd</code>, <code>set_pud</code>, and <code>set_pgd</code> write a given value into a page table entry.<ul>
<li><code>set_pte_atomic</code> is identical to <code>set_pte</code>, but when PAE is enabled it also ensures that the 64-bit value is written atomically.</li>
</ul>
</li>
<li><code>pte_same(a,b)</code> returns 1 if two Page Table entries <code>a</code> and <code>b</code> refer to the same page and specify the same access privileges, 0 otherwise.</li>
<li><code>pmd_large(e)</code> returns 1 if the Page Middle Directory entry <code>e</code> refers to a large page (2 MB or 4 MB), 0 otherwise. See <a href="#extended-paging">Extended Paging</a> and <a href="#the-linear-address-fields">The Linear Address Fields</a> for large page sizes.</li>
</ul>
<p>The <code>pmd_bad</code> macro is used by functions to check Page Middle Directory entries passed as input parameters. It yields the value 1 if the entry points to a bad Page Table, that is, if at least one of the following conditions applies:</p>
<ul>
<li>The page is not in main memory (<code>Present</code> flag cleared).</li>
<li>The page allows only Read access (<code>Read/Write</code> flag cleared).</li>
<li>Either <code>Accessed</code> or <code>Dirty</code> is cleared (<u>Linux always forces these flags to be set for every existing Page Table</u>).</li>
</ul>
<p>The <code>pud_bad</code> and <code>pgd_bad</code> macros always yield 0. No <code>pte_bad</code> macro is defined, because it is legal for a Page Table entry to refer to a page that is not present in main memory, not writable, or not accessible at all.</p>
<p>The <code>pte_present</code> macro yields the value 1 if either the <code>Present</code> flag or the <code>Page Size</code> flag of a Page Table entry is equal to 1, the value 0 otherwise. Recall that the <code>Page Size</code> flag in Page Table entries has no meaning for the paging unit of the microprocessor; <u>the kernel, however, marks <code>Present</code> equal to 0 and <code>Page Size</code> equal to 1 for the pages present in main memory but without read, write, or execute privileges. In this way, any access to such pages triggers a Page Fault exception because <code>Present</code> is cleared, and the kernel can detect that the fault is not due to a missing page by checking the value of <code>Page Size</code>.</u></p>
<p>The <code>pmd_present</code> macro yields the value 1 if the <code>Present</code> flag of the corresponding entry is equal to 1, that is, if the corresponding page or Page Table is loaded in main memory. The <code>pud_present</code> and <code>pgd_present</code> macros always yield the value 1.</p>
<p>The functions listed in the table below query the value of any flag in a Page Table entry; with the exception of <code>pte_file()</code>, these functions work properly only on Page Table entries for which <code>pte_present</code> returns 1.</p>
<table>
<thead>
<tr>
<th>Function name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>pte_user()</code></td>
<td>Reads the <code>User/Supervisor</code> flag</td>
</tr>
<tr>
<td><code>pte_read()</code></td>
<td>Reads the <code>User/Supervisor</code> flag (pages on the 80×86 processor cannot be protected against reading)</td>
</tr>
<tr>
<td><code>pte_write()</code></td>
<td>Reads the <code>Read/Write</code> flag</td>
</tr>
<tr>
<td><code>pte_exec()</code></td>
<td>Reads the <code>User/Supervisor</code> flag (pages on the 80x86 processor cannot be protected against code execution)</td>
</tr>
<tr>
<td><code>pte_dirty()</code></td>
<td>Reads the <code>Dirty</code> flag</td>
</tr>
<tr>
<td><code>pte_young()</code></td>
<td>Reads the <code>Accessed</code> flag</td>
</tr>
<tr>
<td><code>pte_file()</code></td>
<td>Reads the <code>Dirty</code> flag (when the <code>Present</code> flag is cleared and the <code>Dirty</code> flag is set, the page belongs to a non-linear disk file mapping)</td>
</tr>
</tbody>
</table>
<p>The follow table lists another group of functions that sets the value of the flags in a Page Table entry:</p>
<table>
<thead>
<tr>
<th>Function name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>mk_pte_huge()</code></td>
<td>Sets the <code>Page Size</code> and <code>Present</code> flags of a Page Table entry</td>
</tr>
<tr>
<td><code>pte_wrprotect()</code></td>
<td>Clears the <code>Read/Write</code> flag</td>
</tr>
<tr>
<td><code>pte_rdprotect()</code></td>
<td>Clears the <code>User/Supervisor</code> flag</td>
</tr>
<tr>
<td><code>pte_exprotect()</code></td>
<td>Clears the <code>User/Supervisor</code> flag</td>
</tr>
<tr>
<td><code>pte_mkwrite()</code></td>
<td>Sets the <code>Read/Write</code> flag</td>
</tr>
<tr>
<td><code>pte_mkread()</code></td>
<td>Sets the <code>User/Supervisor</code> flag</td>
</tr>
<tr>
<td><code>pte_mkexec()</code></td>
<td>Sets the <code>User/Supervisor</code> flag</td>
</tr>
<tr>
<td><code>pte_mkclean()</code></td>
<td>Clears the <code>Dirty</code> flag</td>
</tr>
<tr>
<td><code>pte_mkdirty()</code></td>
<td>Sets the <code>Dirty</code> flag</td>
</tr>
<tr>
<td><code>pte_mkold()</code></td>
<td>Clears the <code>Accessed</code> flag (makes the page old)</td>
</tr>
<tr>
<td><code>pte_mkyoung()</code></td>
<td>Sets the <code>Accessed</code> flag (makes the page young)</td>
</tr>
<tr>
<td><code>pte_modify(p,v)</code></td>
<td>Sets all access rights in a Page Table entry <code>p</code> to a specified value <code>v</code></td>
</tr>
<tr>
<td><code>ptep_set_wrprotect()</code></td>
<td>Like <code>pte_wrprotect()</code>, but acts on a pointer to a Page Table entry</td>
</tr>
<tr>
<td><code>ptep_set_access_flags()</code></td>
<td>If the <code>Dirty</code> flag is set, sets the page's access rights to a specified value and invokes <code>flush_tlb_page()</code> (see the section <a href="#handling-the-hardware-cache-and-the-tlb">Handling the Hardware Cache and the TLB</a> later in this chapter)</td>
</tr>
<tr>
<td><code>ptep_mkdirty()</code></td>
<td>Like <code>pte_mkdirty()</code> but acts on a pointer to a Page Table entry</td>
</tr>
<tr>
<td><code>ptep_test_and_clear_dirty()</code></td>
<td>Like <code>pte_mkclean()</code> but acts on a pointer to a Page Table entry and returns the old value of the flag</td>
</tr>
<tr>
<td><code>ptep_test_and_clear_young()</code></td>
<td>Like <code>pte_mkold()</code> but acts on a pointer to a Page Table entry and returns the old value of the flag</td>
</tr>
</tbody>
</table>
<p>The following table lists the macros that combine a page address and a group of protection flags into a page table entry or perform the reverse operation of extracting the page address from a page table entry. Notice that some of these macros refer to a page through the linear address of its "page descriptor" (see the section "Page Descriptors" in Chapter 8) rather than the linear address of the page itself.</p>
<p>(p64-65 skipped for now)</p>
<h4 id="physical-memory-layout">Physical Memory Layout<a class="headerlink" href="#physical-memory-layout" title="Permanent link">&para;</a></h4>
<p>During the initialization phase the kernel must build a <strong>physical addresses map</strong> that specifies which physical address ranges are usable by the kernel and which are unavailable (either because they map hardware devices' I/O shared memory or because the corresponding page frames contain BIOS data).</p>
<p>The kernel considers the following page frames as <em>reserved</em>:</p>
<ul>
<li>Those falling in the unavailable physical address ranges</li>
<li>Those containing the kernel’s code and initialized data structures</li>
</ul>
<p><u>A page contained in a reserved page frame can never be dynamically assigned or swapped to disk.</u></p>
<p>As a general rule, the Linux kernel is installed in RAM starting from the physical address <code>0x00100000</code> (i.e. from the second megabyte). The total number of page frames required depends on how the kernel is configured. A typical configuration yields a kernel that can be loaded in less than 3 MB of RAM.</p>
<p>The reason why isn't the kernel loaded starting with the first available megabyte of RAM is: the PC architecture has several peculiarities that must be taken into account. For example:</p>
<ul>
<li>Page frame 0 is used by BIOS to store the system hardware configuration detected during the <a href="https://en.wikipedia.org/wiki/Power-on_self-test">Power-On Self-Test</a> (POST)<ul>
<li>Moreover, the BIOS of many laptops writes data on this page frame even after the system is initialized.</li>
</ul>
</li>
<li>Physical addresses ranging from <code>0x000a0000</code> to <code>0x000fffff</code> are usually reserved to BIOS routines and to map the internal memory of ISA graphics cards. This area is the well-known hole from 640 KB to 1 MB in all IBM-compatible PCs: the physical addresses exist but they are reserved, and the corresponding page frames cannot be used by the operating system.</li>
<li>Additional page frames within the first megabyte may be reserved by specific computer models. For example, the IBM ThinkPad maps the <code>0xa0</code> page frame into the <code>0x9f</code> one.</li>
</ul>
<p>In the early stage of the boot sequence, the kernel queries the BIOS and learns the size of the physical memory. In recent computers, the kernel also invokes a BIOS procedure to build a list of physical address ranges and their corresponding memory types.</p>
<p>Later, the kernel executes the <code>machine_specific_memory_setup()</code> function, which builds the physical addresses map.</p>
<ul>
<li>The kernel builds this table on the basis of the BIOS list, if this is available.</li>
<li>Otherwise the kernel builds the table following the conservative default setup: all page frames with numbers from <code>0x9f</code> (<code>LOWMEMSIZE()</code>) to <code>0x100</code> (<code>HIGH_MEMORY</code>) are marked as reserved.</li>
</ul>
<p>The following table shows typical configuration for a computer having 128 MB (<code>0x00000000</code> through <code>0x07ffffff</code>) of RAM.</p>
<table>
<thead>
<tr>
<th>Start</th>
<th>End</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0x00000000</code></td>
<td><code>0x0009ffff</code></td>
<td>Usable</td>
</tr>
<tr>
<td><code>0x000f0000</code></td>
<td><code>0x000fffff</code></td>
<td>Reserved</td>
</tr>
<tr>
<td><code>0x00100000</code></td>
<td><code>0x07feffff</code></td>
<td>Usable</td>
</tr>
<tr>
<td><code>0x07ff0000</code></td>
<td><code>0x07ff2fff</code></td>
<td>ACPI data</td>
</tr>
<tr>
<td><code>0x07ff3000</code></td>
<td><code>0x07ffffff</code></td>
<td>ACPI NVS</td>
</tr>
<tr>
<td><code>0xffff0000</code></td>
<td><code>0xffffffff</code></td>
<td>Reserved</td>
</tr>
</tbody>
</table>
<ul>
<li>The physical address range from <code>0x07ff0000</code> to <code>0x07ff2fff</code> (Type "ACPI data") stores information about the hardware devices of the system written by the BIOS in the POST phase; during the initialization phase, the kernel copies such information in a suitable kernel data structure, and then considers these page frames usable.</li>
<li>Conversely, the physical address range of <code>0x07ff3000</code> to <code>0x07ffffff</code> (Type "ACPI NVS") is mapped to ROM chips of the hardware devices.</li>
<li>The physical address range starting from <code>0xffff0000</code> is marked as reserved, because it is mapped by the hardware to the BIOS's ROM chip.</li>
<li>Notice that the BIOS may not provide information for some physical address ranges (in the table, the range is <code>0x000a0000</code> to <code>0x000effff</code>). To be on the safe side, Linux assumes that such ranges are not usable.</li>
</ul>
<p>The kernel might not see all physical memory reported by the BIOS: for instance, the kernel can address only 4 GB of RAM if it has not been compiled with PAE support, even if a larger amount of physical memory is actually available.</p>
<p>The <code>setup_memory()</code> function is invoked right after <code>machine_specific_memory_setup()</code>: it analyzes the table of physical memory regions and initializes a few variables that describe the kernel's physical memory layout. These variables are shown in the following table:</p>
<table>
<thead>
<tr>
<th>Variable name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>num_physpages</code></td>
<td>Page frame number of the highest usable page frame</td>
</tr>
<tr>
<td><code>totalram_pages</code></td>
<td>Total number of usable page frames</td>
</tr>
<tr>
<td><code>min_low_pfn</code></td>
<td>Page frame number of the first usable page frame after the kernel image in RAM</td>
</tr>
<tr>
<td><code>max_pfn</code></td>
<td>Page frame number of the last usable page frame</td>
</tr>
<tr>
<td><code>max_low_pfn</code></td>
<td>Page frame number of the last page frame directly mapped by the kernel (low memory)</td>
</tr>
<tr>
<td><code>totalhigh_pages</code></td>
<td>Total number of page frames not directly mapped by the kernel (high memory)</td>
</tr>
<tr>
<td><code>highstart_pfn</code></td>
<td>Page frame number of the first page frame not directly mapped by the kernel</td>
</tr>
<tr>
<td><code>highend_pfn</code></td>
<td>Page frame number of the last page frame not directly mapped by the kernel</td>
</tr>
</tbody>
</table>
<p>To avoid loading the kernel into groups of noncontiguous page frames, Linux prefers to skip the first megabyte of RAM. Page frames not reserved by the PC architecture will be used by Linux to store dynamically assigned pages.</p>
<p>The figure below shows how the first 3 MB of RAM are filled by Linux, which assume that the kernel requires less than 3 MB of RAM.</p>
<p><a href="../figure_2-13.png" title="Figure 2-13. The first 768 page frames (3 MB) in Linux 2.6"><img alt="Figure 2-13. The first 768 page frames (3 MB) in Linux 2.6" src="../figure_2-13_600.png" /></a></p>
<ul>
<li>The symbol <code>_text</code>, which corresponds to physical address <code>0x00100000</code>, denotes the address of the first byte of kernel code.</li>
<li>The symbol <code>_etext</code> identifies the end of the kernel code.</li>
<li>Kernel data is divided into two groups: initialized and uninitialized.<ul>
<li>The initialized data starts right after <code>_etext</code> and ends at <code>_edata</code>.</li>
<li>The uninitialized data follows and ends up at <code>_end</code>.</li>
</ul>
</li>
</ul>
<p>The symbols appearing in the figure are not defined in Linux source code; they are produced while compiling the kernel. You can find the linear address of these symbols in the file <a href="https://en.wikipedia.org/wiki/System.map">System.map</a>, which is created right after the kernel is compiled.</p>
<h4 id="process-page-tables">Process Page Tables<a class="headerlink" href="#process-page-tables" title="Permanent link">&para;</a></h4>
<p>The linear address space of a process is divided into two parts:</p>
<ul>
<li>Linear addresses from <code>0x00000000</code> to <code>0xbfffffff</code> can be addressed when the process runs in either User or Kernel Mode.</li>
<li>Linear addresses from <code>0xc0000000</code> to <code>0xffffffff</code> can be addressed only when the process runs in Kernel Mode.</li>
</ul>
<p>When a process runs in User Mode, it issues linear addresses smaller than <code>0xc0000000</code>; when it runs in Kernel Mode, it is executing kernel code and the linear addresses issued are greater than or equal to <code>0xc0000000</code>. In some cases, however, the kernel must access the User Mode linear address space to retrieve or store data.</p>
<p>The <code>PAGE_OFFSET</code> macro yields the value <code>0xc0000000</code>, which is the offset in the linear address space of a process where the kernel lives.</p>
<ul>
<li>The content of the first entries of the Page Global Directory that map linear addresses lower than <code>0xc0000000</code> (the first 768 entries with PAE disabled, or the first 3 entries with PAE enabled) depends on the specific process.</li>
<li>Conversely, the remaining entries should be the same for all processes and equal to the corresponding entries of the master kernel Page Global Directory (see the following section).</li>
</ul>
<h4 id="kernel-page-tables">Kernel Page Tables<a class="headerlink" href="#kernel-page-tables" title="Permanent link">&para;</a></h4>
<p>The kernel maintains a set of page tables for its own use, rooted at a so-called <strong>master kernel Page Global Directory</strong>. After system initialization, this set of page tables is never directly used by any process or kernel thread; rather, the highest entries of the master kernel Page Global Directory are the reference model for the corresponding entries of the Page Global Directories of every regular process in the system.</p>
<p>The kernel ensures that changes to the master kernel Page Global Directory are propagated to the Page Global Directories that are actually used by processes. [p69]</p>
<p>The kernel initializes its own page tables in two phases. In fact, right after the kernel image is loaded into memory, the CPU is still running in real mode (see <a href="#segmentation-in-hardware">Segmentation in Hardware</a>); thus, paging is not enabled.</p>
<ol>
<li>In the first phase, the kernel creates a limited address space including the kernel's code and data segments, the initial Page Tables, and 128 KB for some dynamic data structures. This minimal address space is just large enough to install the kernel in RAM and to initialize its core data structures.</li>
<li>In the second phase, the kernel takes advantage of all of the existing RAM and sets up the page tables properly.</li>
</ol>
<h5 id="provisional-kernel-page-tables"><strong>Provisional kernel Page Tables</strong><a class="headerlink" href="#provisional-kernel-page-tables" title="Permanent link">&para;</a></h5>
<p>A provisional Page Global Directory is initialized statically during kernel compilation, while the provisional Page Tables are initialized by the <a href="https://github.com/shichao-an/linux-2.6.11.12/blob/master/arch/i386/kernel/head.S#L57"><code>startup_32()</code></a> assembly language function defined in <a href="https://github.com/shichao-an/linux-2.6.11.12/blob/master/arch/i386/kernel/head.S"><code>arch/i386/kernel/head.S</code></a>. We won't mention the Page Upper Directories and Page Middle Directories anymore, because they are equated to Page Global Directory entries. PAE support is not enabled at this stage.</p>
<p>The provisional Page Global Directory is contained in the <code>swapper_pg_dir</code> variable. The provisional Page Tables are stored starting from <code>pg0</code>, right after the end of the kernel's uninitialized data segments (symbol <code>_end</code> in <a href="../figure_2-13.png">Figure 2-13</a>). For simplicity, assume that the kernel's segments, the provisional Page Tables, and the 128 KB memory area fit in the first 8 MB of RAM. In order to map 8 MB of RAM, two Page Tables are required.</p>
<p>The objective of this first phase of paging is to allow these 8 MB of RAM to be easily addressed both in real mode and protected mode. Therefore, the kernel must create a mapping from both the linear addresses <code>0x00000000</code> through <code>0x007fffff</code> and the linear addresses <code>0xc0000000</code> through <code>0xc07fffff</code> into the physical addresses <code>0x00000000</code> through <code>0x007fffff</code>. In other words, the kernel during its first phase of initialization can address the first 8 MB of RAM by either linear addresses identical to the physical ones or 8 MB worth of linear addresses, starting from <code>0xc0000000</code>.</p>
<p>The kernel creates the desired mapping by filling all the <code>swapper_pg_dir</code> entries with zeroes, except for entries 0, 1, <code>0x300</code> (decimal 768), and <code>0x301</code> (decimal 769); the latter two entries span all linear addresses between <code>0xc0000000</code> and <code>0xc07fffff</code>. The 0, 1, <code>0x300</code>, and <code>0x301</code> entries are initialized as follows:</p>
<ul>
<li>The address field of entries 0 and <code>0x300</code> is set to the physical address of <code>pg0</code>, while the address field of entries 1 and <code>0x301</code> is set to the physical address of the page frame following <code>pg0</code>.</li>
<li>The <code>Present</code>, <code>Read/Write</code>, and <code>User/Supervisor</code> flags are set in all four entries.</li>
<li>The <code>Accessed</code>, <code>Dirty</code>, <code>PCD</code>, <code>PWD</code>, and <code>Page Size</code> flags are cleared in all four entries.</li>
</ul>
<p>The <code>startup_32()</code> assembly language function also enables the paging unit. This is achieved by loading the physical address of <code>swapper_pg_dir</code> into the <code>cr3</code> control register and by setting the <code>PG</code> flag of the <code>cr0</code> control register, as shown in the following equivalent code fragment:</p>
<p><small><a href="https://github.com/shichao-an/linux-2.6.11.12/blob/master/arch/i386/kernel/head.S#L186">arch/i386/kernel/head.S#L186</a></small></p>
<div class="codehilite"><pre><span class="nf">movl</span> <span class="no">$swapper_pg_dir-0xc0000000</span><span class="p">,</span><span class="nv">%eax</span>
<span class="nf">movl</span> <span class="nv">%eax</span><span class="p">,</span><span class="nv">%cr3</span> <span class="err">/</span><span class="p">*</span> <span class="no">set</span> <span class="no">the</span> <span class="no">page</span> <span class="no">table</span> <span class="no">pointer..</span> <span class="p">*</span><span class="err">/</span>
<span class="nf">movl</span> <span class="nv">%cr0</span><span class="p">,</span><span class="nv">%eax</span>
<span class="nf">orl</span> <span class="no">$0x80000000</span><span class="p">,</span><span class="nv">%eax</span>
<span class="nf">movl</span> <span class="nv">%eax</span><span class="p">,</span><span class="nv">%cr0</span> <span class="err">/</span><span class="p">*</span> <span class="no">..and</span> <span class="no">set</span> <span class="no">paging</span> <span class="p">(</span><span class="no">PG</span><span class="p">)</span> <span class="no">bit</span> <span class="p">*</span><span class="err">/</span>
</pre></div>


<h5 id="final-kernel-page-table-when-ram-size-is-less-than-896-mb"><strong>Final kernel Page Table when RAM size is less than 896 MB</strong><a class="headerlink" href="#final-kernel-page-table-when-ram-size-is-less-than-896-mb" title="Permanent link">&para;</a></h5>
<p>The final mapping provided by the kernel page tables must transform linear addresses starting from <code>0xc0000000</code> into physical addresses starting from 0.</p>
<ul>
<li>The <code>__pa</code> macro is used to convert a linear address starting from <code>PAGE_OFFSET</code> to the corresponding physical address.</li>
<li>The <code>__va</code> macro does the reverse of <code>__pa</code>.</li>
</ul>
<p>The master kernel Page Global Directory is still stored in <code>swapper_pg_dir</code>. It is initialized by the <a href="https://github.com/shichao-an/linux-2.6.11.12/blob/master/arch/i386/mm/init.c#L499"><code>paging_init()</code></a> function, which does the following:</p>
<ol>
<li>Invokes <a href="https://github.com/shichao-an/linux-2.6.11.12/blob/master/arch/i386/mm/init.c#L310"><code>pagetable_init()</code></a> to set up the Page Table entries properly.</li>
<li>Writes the physical address of <code>swapper_pg_dir</code> in the <code>cr3</code> control register.</li>
<li>If the CPU supports PAE and if the kernel is compiled with PAE support, sets the PAE flag in the <code>cr4</code> control register.</li>
<li>Invokes <a href="https://github.com/shichao-an/linux-2.6.11.12/blob/master/include/asm-i386/tlbflush.h"><code>__flush_tlb_all()</code></a> to invalidate all TLB entries.</li>
</ol>
<p>The actions performed by <code>pagetable_init()</code> depend on both the amount of RAM present and on the CPU model. In the simplest case, if the computer has less than 896 MB of RAM, 32-bit physical addresses are sufficient to address all the available RAM, and there is no need to activate the PAE mechanism. (See section <a href="#the-physical-address-extension-pae-paging-mechanism">The Physical Address Extension (PAE) Paging Mechanism</a>.)</p>
<p><span class="text-muted">The highest 128 MB of linear addresses are left available for several kinds of mappings (see sections <a href="#fix-mapped-linear-addresses">Fix-Mapped Linear Addresses</a> later in this chapter and "Linear Addresses of Noncontiguous Memory Areas" in Chapter 8). The kernel address space left for mapping the RAM is thus 1 GB – 128 MB = 896 MB.</span></p>
<p>The <code>swapper_pg_dir</code> Page Global Directory is reinitialized by a cycle equivalent to the following:</p>
<div class="codehilite"><pre><span class="n">pgd</span> <span class="o">=</span> <span class="n">swapper_pg_dir</span> <span class="o">+</span> <span class="n">pgd_index</span><span class="p">(</span><span class="n">PAGE_OFFSET</span><span class="p">);</span> <span class="cm">/* 768 */</span>
<span class="n">phys_addr</span> <span class="o">=</span> <span class="mh">0x00000000</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">phys_addr</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">max_low_pfn</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">pmd</span> <span class="o">=</span> <span class="n">one_md_table_init</span><span class="p">(</span><span class="n">pgd</span><span class="p">);</span> <span class="cm">/* returns pgd itself */</span>
    <span class="n">set_pmd</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">__pmd</span><span class="p">(</span><span class="n">phys_addr</span> <span class="o">|</span> <span class="n">pgprot_val</span><span class="p">(</span><span class="n">__pgprot</span><span class="p">(</span><span class="mh">0x1e3</span><span class="p">))));</span>
    <span class="cm">/* 0x1e3 == Present, Accessed, Dirty, Read/Write,</span>
<span class="cm">                Page Size, Global */</span>
    <span class="n">phys_addr</span> <span class="o">+=</span> <span class="n">PTRS_PER_PTE</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">;</span> <span class="cm">/* 0x400000 */</span>
    <span class="o">++</span><span class="n">pgd</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>The <a href="https://github.com/shichao-an/linux-2.6.11.12/blob/master/arch/i386/mm/init.c#L55"><code>one_md_table_init</code></a> function a Page Global Directory entry.</p>
<p>We assume that the CPU is a recent 80×86 microprocessor supporting 4 MB pages and "global" TLB entries. Notice that:</p>
<ul>
<li>The <code>User/Supervisor</code> flags in all Page Global Directory entries referencing linear addresses above <code>0xc0000000</code> are cleared, thus denying processes in User Mode access to the kernel address space.</li>
<li>The <code>Page Size</code> flag is set so that the kernel can address the RAM by making use of large pages (see section <a href="#extended-paging">Extended Paging</a>).</li>
</ul>
<p>The identity mapping of the first megabytes of physical memory (8 MB in our example) built by the <code>startup_32()</code> function is required to complete the initialization phase of the kernel. When this mapping is no longer necessary, the kernel clears the corresponding page table entries by invoking the <code>zap_low_mappings()</code> function.</p>
<p>Actually, this description does not state the whole truth. The later section <a href="#fix-mapped-linear-addresses">Fix-Mapped Linear Addresses</a> will discuss that the kernel also adjusts the entries of Page Tables corresponding to the "fix-mapped linear addresses".</p>
<h5 id="final-kernel-page-table-when-ram-size-is-between-896-mb-and-4096-mb"><strong>Final kernel Page Table when RAM size is between 896 MB and 4096 MB</strong><a class="headerlink" href="#final-kernel-page-table-when-ram-size-is-between-896-mb-and-4096-mb" title="Permanent link">&para;</a></h5>
<p>In this case, the RAM cannot be mapped entirely into the kernel linear address space. The best Linux can do during the initialization phase is to map a RAM window of size 896 MB into the kernel linear address space. If a program needs to address other parts of the existing RAM, some other linear address interval must be mapped to the required RAM. This implies changing the value of some page table entries. This kind of dynamic remapping is discussed in Chapter 8. To initialize the Page Global Directory, the kernel uses the same code as in the previous case.</p>
<h5 id="final-kernel-page-table-when-ram-size-is-more-than-4096-mb"><strong>Final kernel Page Table when RAM size is more than 4096 MB</strong><a class="headerlink" href="#final-kernel-page-table-when-ram-size-is-more-than-4096-mb" title="Permanent link">&para;</a></h5>
<p>The kernel Page Table initialization for computers with more than 4 GB deals with cases in which the following happens:</p>
<ul>
<li>The CPU model supports Physical Address Extension (PAE).</li>
<li>The amount of RAM is larger than 4 GB.</li>
<li>The kernel is compiled with PAE support.</li>
</ul>
<p>Although PAE handles 36-bit physical addresses, linear addresses are still 32-bit addresses. As in the previous case, Linux maps a 896-MB RAM window into the kernel linear address space; the remaining RAM is left unmapped and handled by dynamic remapping, as described in Chapter 8. The main difference with the previous case is that a three-level paging model is used, so the Page Global Directory is initialized by a cycle equivalent to the following:</p>
<div class="codehilite"><pre><span class="n">pgd_idx</span> <span class="o">=</span> <span class="n">pgd_index</span><span class="p">(</span><span class="n">PAGE_OFFSET</span><span class="p">);</span> <span class="cm">/* 3 */</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">pgd_idx</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">set_pgd</span><span class="p">(</span><span class="n">swapper_pg_dir</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">__pgd</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">empty_zero_page</span><span class="p">)</span> <span class="o">+</span> <span class="mh">0x001</span><span class="p">));</span>
    <span class="cm">/* 0x001 == Present */</span>
<span class="n">pgd</span> <span class="o">=</span> <span class="n">swapper_pg_dir</span> <span class="o">+</span> <span class="n">pgd_idx</span><span class="p">;</span>
<span class="n">phys_addr</span> <span class="o">=</span> <span class="mh">0x00000000</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">PTRS_PER_PGD</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="o">++</span><span class="n">pgd</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pmd</span> <span class="o">=</span> <span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">alloc_bootmem_low_pages</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">);</span>
    <span class="n">set_pgd</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">__pgd</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">pmd</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x001</span><span class="p">));</span> <span class="cm">/* 0x001 == Present */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">phys_addr</span> <span class="o">&lt;</span> <span class="n">max_low_pfn</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">PTRS_PER_PMD</span> <span class="cm">/* 512 */</span>
                  <span class="o">&amp;&amp;</span> <span class="n">phys_addr</span> <span class="o">&lt;</span> <span class="n">max_low_pfn</span><span class="o">*</span><span class="n">PAGE_SIZE</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">set_pmd</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">__pmd</span><span class="p">(</span><span class="n">phys_addr</span> <span class="o">|</span>
                                <span class="n">pgprot_val</span><span class="p">(</span><span class="n">__pgprot</span><span class="p">(</span><span class="mh">0x1e3</span><span class="p">))));</span>
            <span class="cm">/* 0x1e3 == Present, Accessed, Dirty, Read/Write,</span>
<span class="cm">                        Page Size, Global */</span>
            <span class="n">phys_addr</span> <span class="o">+=</span> <span class="n">PTRS_PER_PTE</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">;</span> <span class="cm">/* 0x200000 */</span>
        <span class="p">}</span>
<span class="p">}</span>
<span class="n">swapper_pg_dir</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">swapper_pg_dir</span><span class="p">[</span><span class="n">pgd_idx</span><span class="p">];</span>
</pre></div>


<p>The above code does the following:</p>
<ul>
<li>The kernel initializes the first three entries in the Page Global Directory corresponding to the user linear address space with the address of an empty page (<code>empty_zero_page</code>).</li>
<li>The fourth entry is initialized with the address of a Page Middle Directory (<code>pmd</code>) allocated by invoking <code>alloc_bootmem_low_pages()</code>. The first 448 entries in the Page Middle Directory (there are 512 entries, but the last 64 are reserved for noncontiguous memory allocation; see the section "Noncontiguous Memory Area Management" in Chapter 8) are filled with the physical address of the first 896 MB of RAM.</li>
<li>The fourth Page Global Directory entry is then copied into the first entry, so as to mirror the mapping of the low physical memory in the first 896 MB of the linear address space. This mapping is required in order to complete the initialization of SMP systems: when it is no longer necessary, the kernel clears the corresponding page table entries by invoking the <code>zap_low_mappings()</code> function, as in the previous cases.</li>
</ul>
<p>Notice that:</p>
<ul>
<li>All CPU models that support PAE also support large 2-MB pages and global pages.</li>
<li>As in the previous cases, whenever possible, Linux uses large pages to reduce the number of Page Tables.</li>
</ul>
<h4 id="fix-mapped-linear-addresses">Fix-Mapped Linear Addresses<a class="headerlink" href="#fix-mapped-linear-addresses" title="Permanent link">&para;</a></h4>
<p>The previous sections discussed that the initial part of the fourth gigabyte of kernel linear addresses maps the physical memory of the system. However, at least 128 MB of linear addresses are always left available because the kernel uses them to implement:</p>
<ul>
<li>Noncontiguous memory allocation, which is just a special way to dynamically allocate and release pages of memory, and is described in the section "Linear Addresses of Noncontiguous Memory Areas" in Chapter 8.</li>
<li>Fix-mapped linear addresses, which is focused in this section.</li>
</ul>
<p>Basically, a <em>fix-mapped linear address</em> is a constant linear address like <code>0xffffc000</code> whose corresponding physical address does not have to be the linear address minus <code>0xc000000</code>, but rather a physical address set in an arbitrary way. Thus, each fix-mapped linear address maps one page frame of the physical memory. Later chapters discuss that the kernel uses fix-mapped linear addresses instead of pointer variables that never change their value.</p>
<p>Fix-mapped linear addresses are conceptually similar to the linear addresses that map the first 896 MB of RAM. However, a fix-mapped linear address can map any physical address, while the mapping established by the linear addresses in the initial portion of the fourth gigabyte is linear (linear address <em>X</em> maps physical address <em>X</em> - <code>PAGE_OFFSET</code>).</p>
<p>With respect to variable pointers, fix-mapped linear addresses are more efficient:</p>
<ul>
<li>Dereferencing a variable pointer requires one memory access more than dereferencing an immediate constant address.</li>
<li>Checking the value of a variable pointer before dereferencing it is a good programming practice; conversely, the check is never required for a constant linear address.</li>
</ul>
<p>Each fix-mapped linear address is represented by a small integer index defined in the <a href="https://github.com/shichao-an/linux-2.6.11.12/blob/master/include/asm-i386/fixmap.h#L53"><code>enum fixed_addresses</code></a> (<a href="https://github.com/shichao-an/linux-2.6.11.12/blob/master/include/asm-i386/fixmap.h">include/asm-i386/fixmap.h</a>) data structure:</p>
<div class="codehilite"><pre><span class="k">enum</span> <span class="n">fixed_addresses</span> <span class="p">{</span>
    <span class="n">FIX_HOLE</span><span class="p">,</span>
    <span class="n">FIX_VSYSCALL</span><span class="p">,</span>
    <span class="n">FIX_APIC_BASE</span><span class="p">,</span>
    <span class="n">FIX_IO_APIC_BASE_0</span><span class="p">,</span>
    <span class="p">[...]</span>
    <span class="n">__end_of_fixed_addresses</span>
<span class="p">};</span>
</pre></div>


<p>Fix-mapped linear addresses are placed at the end of the fourth gigabyte of linear addresses. The <a href="https://github.com/shichao-an/linux-2.6.11.12/blob/master/include/asm-i386/fixmap.h#L134"><code>fix_to_virt()</code></a> function computes the constant linear address starting from the index:</p>
<div class="codehilite"><pre><span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">fix_to_virt</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="n">__end_of_fixed_addresses</span><span class="p">)</span>
        <span class="n">__this_fixmap_does_not_exist</span><span class="p">();</span>
    <span class="k">return</span> <span class="p">(</span><span class="mh">0xfffff000UL</span> <span class="o">-</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>


<p>Assume that some kernel function invokes <code>fix_to_virt(FIX_IO_APIC_BASE_0)</code>:</p>
<ul>
<li>Because the function is declared as "inline", the C compiler does not generate a call to <code>fix_to_virt()</code>, but inserts its code in the calling function.</li>
<li>The check on the index value is never performed at runtime.<ul>
<li><code>FIX_IO_APIC_BASE_0</code> is a constant equal to 3, so the compiler can cut away the <code>if</code> statement because its condition is false at compile time.</li>
<li>Conversely, if the condition is true or the argument of <code>fix_to_virt()</code> is not a constant, the compiler issues an error during the linking phase because the symbol <code>__this_fixmap_does_not_exist</code> is not defined anywhere.</li>
</ul>
</li>
<li>Eventually, the compiler computes <code>0xfffff000-(3&lt;&lt;PAGE_SHIFT)</code> and replaces the <code>fix_to_virt()</code> function call with the constant linear address <code>0xffffc000</code>.</li>
</ul>
<p>To associate a physical address with a fix-mapped linear address, the kernel uses the following two macros:</p>
<ul>
<li><code>set_fixmap(idx,phys)</code></li>
<li><code>set_fixmap_nocache(idx,phys)</code></li>
</ul>
<p>Both of them initialize the Page Table entry corresponding to the <code>fix_to_virt(idx)</code> linear address with the physical address <code>phys</code>; however, the second function also sets the <code>PCD</code> flag of the Page Table entry, thus disabling the hardware cache when accessing the data in the page frame (see the section <a href="#hardware-cache">Hardware Cache</a> earlier in this chapter).</p>
<p>Conversely, <code>clear_fixmap(idx)</code> removes the linking between a fix-mapped linear address <code>idx</code> and the physical address.</p>
<h4 id="handling-the-hardware-cache-and-the-tlb">Handling the Hardware Cache and the TLB<a class="headerlink" href="#handling-the-hardware-cache-and-the-tlb" title="Permanent link">&para;</a></h4>
<p>The last topic of memory addressing is how the kernel makes an optimal use of the hardware caches. Hardware caches and Translation Lookaside Buffers play a crucial role in boosting the performance of modern computer architectures. Several techniques are used by kernel developers to reduce the number of cache and TLB misses.</p>
<h5 id="handling-the-hardware-cache"><strong>Handling the hardware cache</strong><a class="headerlink" href="#handling-the-hardware-cache" title="Permanent link">&para;</a></h5>
<p>As <a href="#hardware-cache">mentioned earlier in this chapter</a>, hardware caches are addressed by cache lines.</p>
<p>The <code>L1_CACHE_BYTES</code> macro yields the size of a cache line in bytes:</p>
<ul>
<li>On Intel models earlier than the Pentium 4, this macro yields the value 32</li>
<li>On a Pentium 4, this macro it yields the value 128.</li>
</ul>
<p>To optimize the cache hit rate, the kernel considers the architecture in making the following decisions:</p>
<ul>
<li>The most frequently used fields of a data structure are placed at the low offset within the data structure, so they can be cached in the same line.</li>
<li>When allocating a large set of data structures, the kernel tries to store each of them in memory in such a way that all cache lines are used uniformly.</li>
</ul>
<p>Cache synchronization is performed automatically by the 80×86 microprocessors, thus the Linux kernel for this kind of processor does not perform any hardware cache flushing. The kernel does provide, however, cache flushing interfaces for processors that do not synchronize caches.</p>
<h5 id="handling-the-tlb"><strong>Handling the TLB</strong><a class="headerlink" href="#handling-the-tlb" title="Permanent link">&para;</a></h5>
<p>Processors cannot synchronize their own TLB cache automatically because it is the kernel (not the hardware) that decides when a mapping between a linear and a physical address is no longer valid.</p>
<p>Linux 2.6 offers several TLB flush methods that should be applied appropriately, depending on the type of page table change. The following table shows architecture-independent TLB-invalidating methods:</p>
<table>
<thead>
<tr>
<th>Method name</th>
<th>Description</th>
<th>Typically used when</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>flush_tlb_all</code></td>
<td>Flushes all TLB entries (including those that refer to global pages, that is, pages whose <code>Global</code> flag is set)</td>
<td>Changing the kernel page table entries</td>
</tr>
<tr>
<td><code>flush_tlb_kernel_range</code></td>
<td>Flushes all TLB entries in a given range of linear addresses (including those that refer to global pages)</td>
<td>Changing a range of kernel page table entries</td>
</tr>
<tr>
<td><code>flush_tlb</code></td>
<td>Flushes all TLB entries of the non-global pages owned by the current process</td>
<td>Performing a process switch</td>
</tr>
<tr>
<td><code>flush_tlb_mm</code></td>
<td>Flushes all TLB entries of the non-global pages owned by a given process</td>
<td>Forking a new process</td>
</tr>
<tr>
<td><code>flush_tlb_range</code></td>
<td>Flushes the TLB entries corresponding to a linear address interval of a given process</td>
<td>Releasing a linear address interval of a process</td>
</tr>
<tr>
<td><code>flush_tlb_pgtables</code></td>
<td>Flushes the TLB entries of a given contiguous subset of page tables of a given process</td>
<td>Releasing some page tables of a process</td>
</tr>
<tr>
<td><code>flush_tlb_page</code></td>
<td>Flushes the TLB of a single Page Table entry of a given process</td>
<td>Processing a Page Fault</td>
</tr>
</tbody>
</table>
<p>Although the generic Linux kernel offers a rich set of TLB methods, every microprocessor usually offers a far more restricted set of TLB-invalidating assembly language instructions, such as the more flexible hardware platforms, Sun's <a href="https://en.wikipedia.org/wiki/UltraSPARC">UltraSPARC</a>. In contrast, Intel microprocessors offers only two TLB-invalidating techniques:</p>
<ul>
<li>All Pentium models automatically flush the TLB entries relative to non-global pages when a value is loaded into the <code>cr3</code> register.</li>
<li>In Pentium Pro and later models, the <code>invlpg</code> assembly language instruction invalidates a single TLB entry mapping a given linear address.</li>
</ul>
<p>The following table lists the Linux TLB-invalidating macros for the Intel Pentium Pro and later processor, which exploit the hardware techniques mentioned above. These macros are the basic ingredients to implement the architecture-independent methods listed in the previous table.</p>
<table>
<thead>
<tr>
<th>Macro name</th>
<th>Description</th>
<th>Used by</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__flush_tlb()</code></td>
<td>Rewrites <code>cr3</code> register back into itself</td>
<td><code>flush_tlb</code>, <code>flush_tlb_mm</code>, <code>flush_tlb_range</code></td>
</tr>
<tr>
<td><code>__flush_tlb_global()</code></td>
<td>Disables global pages by clearing the <code>PGE</code> flag of <code>cr4</code>, rewrites <code>cr3</code> register back into itself, and sets again the <code>PGE</code> flag</td>
<td><code>flush_tlb_all</code>, <code>flush_tlb_kernel_range</code></td>
</tr>
<tr>
<td><code>__flush_tlb_single(addr)</code></td>
<td>Executes <code>invlpg</code> assembly language instruction with parameter <code>addr</code></td>
<td><code>flush_tlb_page</code></td>
</tr>
</tbody>
</table>
<p>Notice that the <code>flush_tlb_pgtables</code> method is missing from the above table: in the 80×86 architecture nothing has to be done when a page table is unlinked from its parent table, thus the function implementing this method is empty.</p>
<p>The architecture-independent TLB-invalidating methods are extended quite simply to multiprocessor systems. The function running on a CPU sends an <a href="https://en.wikipedia.org/wiki/Inter-processor_interrupt">Interprocessor Interrupt</a> (see "Interprocessor Interrupt Handling" in <a href="ch4.md">Chapter 4</a>) to the other CPUs that forces them to execute the proper TLB-invalidating function.</p>
<p>As a general rule, <u>any process switch implies changing the set of active page tables. Local TLB entries relative to the old page tables must be flushed; this is done automatically when the kernel writes the address of the new Page Global Directory into the <code>cr3</code> control register.</u> However, the kernel succeeds in avoiding TLB flushes in the following cases:</p>
<ul>
<li>When performing a process switch between two regular processes that use the same set of page tables (see the section <a href="ch7.md#the-schedule-function">The <code>schedule()</code> Function</a> in <a href="ch7.md">Chapter 7</a>).</li>
<li>When performing a process switch between a regular process and a kernel thread. <u>In fact, kernel threads do not have their own set of page tables; they use the set of page tables owned by the regular process that was scheduled last for execution on the CPU.</u> This is discussed in section <a href="ch9.md#memory-descriptor-of-kernel-threads">Memory Descriptor of Kernel Threads</a> in <a href="../ch9.md.">Chapter 9</a>.</li>
</ul>
<p>Besides process switches, there are other cases in which the kernel needs to flush some entries in a TLB. For instance:</p>
<ul>
<li>When the kernel assigns a page frame to a User Mode process and stores its physical address into a Page Table entry, it must flush any local TLB entry that refers to the corresponding linear address.</li>
<li>On multiprocessor systems, the kernel also must flush the same TLB entry on the CPUs that are using the same set of page tables, if any.</li>
</ul>
<h5 id="lazy-tlb-mode"><strong>Lazy TLB mode</strong> *<a class="headerlink" href="#lazy-tlb-mode" title="Permanent link">&para;</a></h5>
<p>To avoid useless TLB flushing in multiprocessor systems, the kernel uses a technique called <em>lazy TLB mode</em>. The basic idea is the following: if several CPUs are using the same page tables and a TLB entry must be flushed on all of them, then TLB flushing may, in some cases, be delayed on CPUs running kernel threads.</p>
<p>In fact, each kernel thread does not have its own set of page tables; rather, it makes use of the set of page tables belonging to a regular process. However, there is no need to invalidate a TLB entry that refers to a User Mode linear address, because no kernel thread accesses the User Mode address space.</p>
<p>By the way, the <code>flush_tlb_all</code> method does not use the lazy TLB mode mechanism; it is usually invoked whenever the kernel modifies a Page Table entry relative to the Kernel Mode address space.</p>
<p>When some CPUs start running a kernel thread, the kernel sets it into lazy TLB mode. When requests are issued to clear some TLB entries, each CPU in lazy TLB mode does not flush the corresponding entries; however, the CPU remembers that its current process is running on a set of page tables whose TLB entries for the User Mode addresses are invalid.</p>
<ul>
<li>As soon as the CPU in lazy TLB mode switches to a regular process with a different set of page tables, the hardware automatically flushes the TLB entries, and the kernel sets the CPU back in non-lazy TLB mode.</li>
<li>However, if a CPU in lazy TLB mode switches to a regular process that owns the same set of page tables used by the previously running kernel thread, then any deferred TLB invalidation must be effectively applied by the kernel. This "lazy" invalidation is effectively achieved by flushing all non-global TLB entries of the CPU.</li>
</ul>
<p>Some extra data structures are needed to implement the lazy TLB mode:</p>
<ul>
<li>The <code>cpu_tlbstate</code> variable is a static array of <code>NR_CPUS</code> (number) <code>tlb_state</code> structures. (See <a href="https://github.com/shichao-an/linux-2.6.11.12/blob/master/include/asm-i386/tlbflush.h#L128">include/asm-i386/tlbflush.h</a>)</li>
<li>The default value for <code>NR_CPUS</code> macro is 32, which denotes the maximum number of CPUs in the system</li>
<li>Each <code>tlb_state</code> structure consists of:<ul>
<li>An <code>active_mm</code> field pointing to the memory descriptor of the current process (see <a href="ch9.md">Chapter 9</a>)</li>
<li>A <code>state</code> flag that can assume only two values: <code>TLBSTATE_OK</code> (non-lazy TLB mode) or <code>TLBSTATE_LAZY</code> (lazy TLB mode).</li>
</ul>
</li>
<li>Furthermore, each memory descriptor includes a <code>cpu_vm_mask</code> field that stores the indices of the CPUs that should receive Interprocessor Interrupts related to TLB flushing. This field is meaningful only when the memory descriptor belongs to a process currently in execution.</li>
</ul>
<p>When a CPU starts executing a kernel thread, the kernel sets the <code>state</code> field of its <code>cpu_tlbstate</code> element to <code>TLBSTATE_LAZY</code>; moreover, the <code>cpu_vm_mask</code> field of the active memory descriptor stores the indices of all CPUs in the system, including the one that is entering in lazy TLB mode. When another CPU wants to invalidate the TLB entries of all CPUs relative to a given set of page tables, it delivers an Interprocessor Interrupt to all CPUs whose indices are included in the <code>cpu_vm_mask</code> field of the corresponding memory descriptor.</p>
<p>When a CPU receives an Interprocessor Interrupt related to TLB flushing and verifies that it affects the set of page tables of its current process, it checks whether the <code>state</code> field of its <code>cpu_tlbstate</code> element is equal to <code>TLBSTATE_LAZY</code>. In this case, the kernel refuses to invalidate the TLB entries and removes the CPU index from the <code>cpu_vm_mask</code> field of the memory descriptor. This has two consequences:</p>
<ul>
<li>As long as the CPU remains in lazy TLB mode, it will not receive other Interprocessor Interrupts related to TLB flushing.</li>
<li>If the CPU switches to another process that is using the same set of page tables as the kernel thread that is being replaced, the kernel invokes <code>__flush_tlb()</code> to invalidate all non-global TLB entries of the CPU.</li>
</ul>
<h3 id="doubts-and-solution">Doubts and Solution<a class="headerlink" href="#doubts-and-solution" title="Permanent link">&para;</a></h3>
<h4 id="verbatim">Verbatim<a class="headerlink" href="#verbatim" title="Permanent link">&para;</a></h4>
<h5 id="p72-on-final-kernel-page-table-when-ram-size-is-more-than-4096-mb"><strong>p72 on Final kernel Page Table when RAM size is more than 4096 MB</strong><a class="headerlink" href="#p72-on-final-kernel-page-table-when-ram-size-is-more-than-4096-mb" title="Permanent link">&para;</a></h5>
<blockquote>
<p>The fourth Page Global Directory entry is then copied into the first entry, so as to mirror the mapping of the low physical memory in the first 896 MB of the linear address space. This mapping is required in order to complete the initialization of SMP systems</p>
</blockquote>
<p><span class="text-danger">Question</span>: Why is that?</p>
            </div>
        </div>

        <footer class="col-md-12">
            
        </footer>

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script>
        <script src="../../js/base.js"></script>
        <script src="../../custom.js"></script>
    </body>
</html>