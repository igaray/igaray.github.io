<!DOCTYPE html>
<html lang="en">
    <head>
        <!-- Global Site Tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-59055167-2"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments)};
          gtag('js', new Date());

          gtag('config', 'UA-59055167-2');
        </script>

        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://notes.shichao.io/golang/">
        <link rel="shortcut icon" href="../toki_32.png">
        

	<title>Go - Shichao's Notes</title>

        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../css/highlight.css">
        <link href="../css/base.css" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,400italic,500,600" rel="stylesheet">
        <link href="../custom.css" rel="stylesheet">
        <link href="../friendly.css" rel="stylesheet">
        <link href="../theme.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        
<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="..">Shichao's Notes</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">APUE <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../apue/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../apue/ch1/">Chapter 1. UNIX System Overview</a>
                        </li>
                      
                        <li>
                            <a href="../apue/ch2/">Chapter 2. UNIX Standardization and Implementations</a>
                        </li>
                      
                        <li>
                            <a href="../apue/ch3/">Chapter 3. File I/O</a>
                        </li>
                      
                        <li>
                            <a href="../apue/ch4/">Chapter 4. Files and Directories</a>
                        </li>
                      
                        <li>
                            <a href="../apue/ch5/">Chapter 5. Standard I/O Library</a>
                        </li>
                      
                        <li>
                            <a href="../apue/ch6/">Chapter 6. System Data Files and Information</a>
                        </li>
                      
                        <li>
                            <a href="../apue/ch7/">Chapter 7. Process Environment</a>
                        </li>
                      
                        <li>
                            <a href="../apue/ch8/">Chapter 8. Process Control</a>
                        </li>
                      
                        <li>
                            <a href="../apue/ch9/">Chapter 9. Process Relationships</a>
                        </li>
                      
                        <li>
                            <a href="../apue/ch10/">Chapter 10. Signals</a>
                        </li>
                      
                        <li>
                            <a href="../apue/ch11/">Chapter 11. Threads</a>
                        </li>
                      
                        <li>
                            <a href="../apue/ch12/">Chapter 12. Thread Control</a>
                        </li>
                      
                        <li>
                            <a href="../apue/ch13/">Chapter 13. Daemon Processes</a>
                        </li>
                      
                        <li>
                            <a href="../apue/ch14/">Chapter 14. Advanced I/O</a>
                        </li>
                      
                        <li>
                            <a href="../apue/ch15/">Chapter 15. Interprocess Communication</a>
                        </li>
                      
                        <li>
                            <a href="../apue/ch16/">Chapter 16. Network IPC: Sockets</a>
                        </li>
                      
                        <li>
                            <a href="../apue/ch17/">Chapter 17. Advanced IPC</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UNP <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../unp/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../unp/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../unp/ch2/">Chapter 2. The Transport Layer: TCP, UDP, and SCTP</a>
                        </li>
                      
                        <li>
                            <a href="../unp/ch3/">Chapter 3. Sockets Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../unp/ch4/">Chapter 4. Elementary TCP Sockets</a>
                        </li>
                      
                        <li>
                            <a href="../unp/ch5/">Chapter 5. TCP Client/Server Example</a>
                        </li>
                      
                        <li>
                            <a href="../unp/ch6/">Chapter 6. I/O Multiplexing: The select and poll Functions</a>
                        </li>
                      
                        <li>
                            <a href="../unp/ch7/">Chapter 7. Socket Options</a>
                        </li>
                      
                        <li>
                            <a href="../unp/ch8/">Chapter 8. Elementary UDP Sockets</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">TCPv1 <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../tcpv1/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../tcpv1/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../tcpv1/ch2/">Chapter 2. The Internet Address Architecture</a>
                        </li>
                      
                        <li>
                            <a href="../tcpv1/ch3/">Chapter 3. Link Layer</a>
                        </li>
                      
                        <li>
                            <a href="../tcpv1/ch4/">Chapter 4. ARP: Address Resolution Protocol</a>
                        </li>
                      
                        <li>
                            <a href="../tcpv1/ch5/">Chapter 5. The Internet Protocol (IP)</a>
                        </li>
                      
                        <li>
                            <a href="../tcpv1/ch6/">Chapter 6. System Configuration: DHCP and Autoconfiguration</a>
                        </li>
                      
                        <li>
                            <a href="../tcpv1/ch7/">Chapter 7. Firewalls and Network Address Translation (NAT)</a>
                        </li>
                      
                        <li>
                            <a href="../tcpv1/ch8/">Chapter 8. ICMPv4 and ICMPv6: Internet Control Message Protocol</a>
                        </li>
                      
                        <li>
                            <a href="../tcpv1/ch9/">Chapter 9. Broadcasting and Local Multicasting (IGMP and MLD)</a>
                        </li>
                      
                        <li>
                            <a href="../tcpv1/ch10/">Chapter 10. User Datagram Protocol (UDP) and IP Fragmentation</a>
                        </li>
                      
                        <li>
                            <a href="../tcpv1/ch11/">Chapter 11. Name Resolution and the Domain Name System (DNS)</a>
                        </li>
                      
                        <li>
                            <a href="../tcpv1/ch12/">Chapter 12. TCP: The Transmission Control Protocol (Preliminaries)</a>
                        </li>
                      
                        <li>
                            <a href="../tcpv1/ch13/">Chapter 13. TCP Connection Management</a>
                        </li>
                      
                        <li>
                            <a href="../tcpv1/ch14/">Chapter 14. TCP Timeout and Retransmission</a>
                        </li>
                      
                        <li>
                            <a href="../tcpv1/ch15/">Chapter 15. TCP Data Flow and Window Management</a>
                        </li>
                      
                        <li>
                            <a href="../tcpv1/ch16/">Chapter 16. TCP Congestion Control</a>
                        </li>
                      
                        <li>
                            <a href="../tcpv1/ch17/">Chapter 17. TCP Keepalive</a>
                        </li>
                      
                        <li>
                            <a href="../tcpv1/ch18/">Chapter 18. Security: EAP, IPsec, TLS, DNSSEC, and DKIM</a>
                        </li>
                      
                        <li>
                            <a href="../tcpv1/headers/">Headers</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">GOPL <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../gopl/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../gopl/ch1/">Chapter 1. Tutorial</a>
                        </li>
                      
                        <li>
                            <a href="../gopl/ch2/">Chapter 2. Program Structure</a>
                        </li>
                      
                        <li>
                            <a href="../gopl/ch3/">Chapter 3. Basic Data Types</a>
                        </li>
                      
                        <li>
                            <a href="../gopl/ch4/">Chapter 4. Composite Types</a>
                        </li>
                      
                        <li>
                            <a href="../gopl/ch5/">Chapter 5. Functions</a>
                        </li>
                      
                        <li>
                            <a href="../gopl/ch6/">Chapter 6. Methods</a>
                        </li>
                      
                        <li>
                            <a href="../gopl/ch7/">Chapter 7. Interfaces</a>
                        </li>
                      
                        <li>
                            <a href="../gopl/ch8/">Chapter 8. Goroutines and Channels</a>
                        </li>
                      
                        <li>
                            <a href="../gopl/ch9/">Chapter 9. Concurrency with Shared Variables</a>
                        </li>
                      
                        <li>
                            <a href="../gopl/ch10/">Chapter 10. Packages and the Go Tool</a>
                        </li>
                      
                        <li>
                            <a href="../gopl/ch11/">Chapter 11. Testing</a>
                        </li>
                      
                        <li>
                            <a href="../gopl/ch12/">Chapter 12. Reflection</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">CSN <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../csn/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../csn/part1/">Part 1: Language</a>
                        </li>
                      
                        <li>
                            <a href="../csn/part2/">Part 2: Advanced</a>
                        </li>
                      
                    </ul>
                </li>
            <li>
                    <a href="../toc/">TOC</a>
                </li>
            </ul>
            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    
                        <a href="https://github.com/shichao-an/notes/blob/master/docs/golang/index.md">
                    
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#go">Go</a></li>
        
    
        <li class="main "><a href="#how-to-write-go-code">How to Write Go Code</a></li>
        
    
        <li class="main "><a href="#basic-constructs-and-elementary-data-types">Basic constructs and elementary data types</a></li>
        
            <li><a href="#filenames-keywords-and-identifiers">Filenames, Keywords and Identifiers</a></li>
        
            <li><a href="#packages-import-and-visibility">Packages, import and visibility</a></li>
        
            <li><a href="#functions">Functions</a></li>
        
            <li><a href="#comments">Comments</a></li>
        
            <li><a href="#types">Types</a></li>
        
            <li><a href="#program-structure">Program structure</a></li>
        
            <li><a href="#conversions">Conversions</a></li>
        
            <li><a href="#naming">Naming</a></li>
        
            <li><a href="#constants">Constants</a></li>
        
            <li><a href="#variables">Variables</a></li>
        
            <li><a href="#value-types-and-reference-types">Value types and reference types</a></li>
        
            <li><a href="#printing">Printing</a></li>
        
            <li><a href="#short-forms-of-declaration-and-assignment">Short forms of declaration and assignment</a></li>
        
    
        <li class="main "><a href="#structs">Structs</a></li>
        
            <li><a href="#visibility">Visibility</a></li>
        
            <li><a href="#factory-methods">Factory methods</a></li>
        
            <li><a href="#structs-with-tags">Structs with tags</a></li>
        
            <li><a href="#anonymous-fields-and-embedded-structs">Anonymous fields and embedded structs</a></li>
        
    
        <li class="main "><a href="#methods">Methods</a></li>
        
            <li><a href="#methods-on-embedded-types-and-inheritance">Methods on embedded types and inheritance</a></li>
        
            <li><a href="#embed-functionality-in-a-type">Embed functionality in a type</a></li>
        
            <li><a href="#format-specifiers">Format specifiers</a></li>
        
    
        <li class="main "><a href="#interfaces">Interfaces</a></li>
        
            <li><a href="#interface-embedding-interfaces">Interface embedding interfaces</a></li>
        
            <li><a href="#detect-and-convert-the-type-of-an-interface-variable-type-assertions">Detect and convert the type of an interface variable: type assertions</a></li>
        
            <li><a href="#the-type-switch">The type switch</a></li>
        
            <li><a href="#testing-if-a-value-implements-an-interface">Testing if a value implements an interface</a></li>
        
            <li><a href="#variables-of-interface-type">Variables of interface type</a></li>
        
            <li><a href="#using-method-sets-with-interfaces">Using method sets with interfaces</a></li>
        
            <li><a href="#empty-interface">Empty Interface</a></li>
        
            <li><a href="#interface-slice">Interface Slice</a></li>
        
            <li><a href="#interface-to-interface">Interface to interface</a></li>
        
    
        <li class="main "><a href="#reflection">Reflection</a></li>
        
            <li><a href="#setting-a-value-through-reflection">Setting a value through reflection</a></li>
        
            <li><a href="#reflection-on-structs">Reflection on structs</a></li>
        
            <li><a href="#printf-and-reflection">Printf and reflection</a></li>
        
            <li><a href="#interfaces-and-dynamic-typing">Interfaces and dynamic typing</a></li>
        
            <li><a href="#summary-of-object-orientedness-of-go">Summary of object-orientedness of Go</a></li>
        
            <li><a href="#higher-order-functions">Higher order functions</a></li>
        
    
        <li class="main "><a href="#references">References</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">
              

<h3 id="go"><strong>Go</strong><a class="headerlink" href="#go" title="Permanent link">&para;</a></h3>
<h3 id="how-to-write-go-code">How to Write Go Code<a class="headerlink" href="#how-to-write-go-code" title="Permanent link">&para;</a></h3>
<ul>
<li><a href="https://golang.org/doc/code.html">How to Write Go Code</a></li>
</ul>
<h3 id="basic-constructs-and-elementary-data-types">Basic constructs and elementary data types<a class="headerlink" href="#basic-constructs-and-elementary-data-types" title="Permanent link">&para;</a></h3>
<h4 id="filenames-keywords-and-identifiers">Filenames, Keywords and Identifiers<a class="headerlink" href="#filenames-keywords-and-identifiers" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>Filenames</strong> consist of lowercase-letters (that may separated by underscores _), like <code>scanner.go</code> and <code>scanner_test.go</code>.  Filenames may not contain spaces or any other special characters.</li>
<li><strong>Identifiers</strong> begin with a letter (a <strong>letter</strong> is every letter in Unicode UTF-8 or _) and followed by 0 or more letters or Unicode digits, like: <code>X56</code>, <code>group1</code>, <code>_x23</code>, <code>i</code>, <code>өԑ12</code>.<ul>
<li>The <code>_</code> itself is a special identifier, called the <strong>blank identifier</strong>. It can be used in declarations or variable assignments like any other identifier (and any type can be assigned to it), but its value is discarded, so it cannot be used anymore in the code that follows.</li>
</ul>
</li>
<li><strong>Keywords</strong> or reserved words are: <code>break</code>, <code>default</code>, <code>func</code>, <code>interface</code>, <code>select</code>, <code>case</code>, <code>defer</code>, <code>go</code>, <code>map</code>, <code>struct</code>, <code>chan</code>, <code>else</code>, <code>goto</code>, <code>package</code>, <code>switch</code>, <code>const</code>, <code>fallthrough</code>, <code>if</code>, <code>range</code>, <code>type</code>, <code>continue</code>, <code>for</code>, <code>import</code>, <code>return</code>, <code>var</code>.</li>
<li><strong>Predeclared identifiers</strong> (names of elementary types and some basic built-in functions): <code>append</code>, <code>bool</code>, <code>byte</code>, <code>cap</code>, <code>close</code>, <code>complex</code>, <code>complex64</code>, <code>complex128</code>, <code>uint16</code>, <code>copy</code>, <code>false</code>, <code>float32</code>, <code>float64</code>, <code>imag</code>, <code>int</code>, <code>int8</code>, <code>int16</code>, <code>uint32</code>, <code>int32</code>, <code>int64</code>, <code>iota</code>, <code>len</code>, <code>make</code>, <code>new</code>, <code>nil</code>, <code>panic</code>, <code>uint64</code>, <code>print</code>, <code>println</code>, <code>real</code>, <code>recover</code>, <code>string</code>, <code>true</code>, <code>uint</code>, <code>uint8</code>, <code>uintptr</code>,</li>
<li>Programs consist out of keywords, constants, variables, operators, types and functions.</li>
<li>Delimiters: parentheses <code>( )</code>, brackets <code>[ ]</code> and braces <code>{ }</code>.</li>
<li>Punctuation characters: <code>.</code>, <code>;</code>, <code>...</code>.</li>
<li>Code is structured in <strong>statements</strong>. A statement doesn’t need to end with a <code>;</code>. The Go compiler automatically inserts semicolons at the end of statements. However, if multiple statements are written on one line (which is not encouraged for readability reasons), they must be separated by <code>;</code>.</li>
</ul>
<h4 id="packages-import-and-visibility">Packages, import and visibility<a class="headerlink" href="#packages-import-and-visibility" title="Permanent link">&para;</a></h4>
<p><a href="https://github.com/shichao-an/twtg/blob/master/code_examples/chapter_4/hello_world.go">hello_world.go</a></p>
<p>Every go file belongs to one and only one <strong>package</strong> (like a library or namespace in other languages). Many different .go files can belong to one package, so the filename(s) and package name are generally not the same.</p>
<ul>
<li>The package to which the code-file belongs must be indicated on the first line, e.g. <code>package main</code>.</li>
<li>A standalone executable belongs to package <code>main</code> and each Go application contains one package <code>main</code>.</li>
<li>A package name is written in lowercase letters.</li>
</ul>
<p>An application can consist of different packages. Even if you use only package <code>main</code>, you don’t have to stuff all code in one big file: you can make a number of smaller files each having <code>package main</code> as the first codeline. If you compile a source file with a package name other than <code>main</code>, like <code>pack1</code>, the object file is stored in <code>pack1.a</code>.</p>
<p>The <a href="https://golang.org/pkg/#stdlib">standard library</a> contains ready-to-use packages of the Go installation.</p>
<h5 id="package-compilation"><strong>Package compilation</strong><a class="headerlink" href="#package-compilation" title="Permanent link">&para;</a></h5>
<ul>
<li>To build a program, the packages, and the files within them, must be compiled in the correct order.  Package dependencies determine the order in which to build packages.</li>
<li>Within a package, the source files must all be compiled together. The package is compiled as a unit, and by convention each directory contains one package.</li>
<li>If a package is changed and recompiled, all the client programs that use this package must be recompiled.</li>
<li>The package model uses <strong>explicit dependencies</strong> to enable faster builds. [TWTG p52]</li>
</ul>
<h5 id="import"><strong>Import</strong><a class="headerlink" href="#import" title="Permanent link">&para;</a></h5>
<p>A Go program is created by linking together a set of packages through the <code>import</code> keyword. For example, <code>import "fmt"</code> tells Go that this program needs (functions, or other elements, from) the package <code>fmt</code>.</p>
<ul>
<li>The package names are enclosed within ""</li>
<li>Import loads the public declarations from the compiled package; it does not insert the source code.</li>
</ul>
<p>If multiple packages are needed, they can each be imported by a separate statement:</p>
<div class="codehilite"><pre><span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>
<span class="kn">import</span> <span class="s">&quot;os&quot;</span>
</pre></div>


<p>The shorter and more elegant way (called <em>factoring the keyword</em>, also applicable to <code>const</code>, <code>var</code> and <code>type</code>) is available (<u>it is also clearer to list the package names in alphabetical order</u>):</p>
<div class="codehilite"><pre><span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;os&quot;</span>
<span class="p">)</span>
</pre></div>


<ul>
<li>If the name of a package does not start with . or /, like "fmt" or "container/list", Go looks for it in the global Go tree.</li>
<li>If it starts with ./ the package is searched in the actual directory</li>
<li>If it starts with /, the package is searched for in the (absolute) path indicated.</li>
</ul>
<p>Apart from <code>_</code>, identifiers of code-objects have to be unique in a package: there can be no naming conflicts. But the same identifier can be used in different packages: the package name qualifies it to be different.</p>
<h5 id="visibility-rule"><strong>Visibility rule</strong><a class="headerlink" href="#visibility-rule" title="Permanent link">&para;</a></h5>
<p>Packages expose their code-objects to code outside of the package according to the following rule:</p>
<ul>
<li>When the identifier (of a constant, variable, type, function, struct field, etc.) starts with an uppercase letter, like <code>Group1</code>, then the "object" with this identifier is visible in code outside the package (thus available to client-programs, "importers" of the package), it is said to be exported (like public in OO languages).</li>
<li>Identifiers which start with a lowercase letter are not visible outside the package, but they are visible and usable in the whole package (like private).</li>
</ul>
<p>Some notes on this rule:</p>
<ul>
<li>Uppercase letters can come from the entire Unicode-range, like Greek; not only ASCII letters are allowed.</li>
<li>Importing a package gives (only) access to the exported objects in that package.</li>
<li>Packages also serve as namespaces and can help to avoid name-clashes (name-conflicts): variables with the same name in two packages are differentiated by their package name. For example, <code>pack1.Thing</code> and <code>pack2.Thing</code>.</li>
</ul>
<p>A package can also be given another name (an <strong>alias</strong>), for example:</p>
<div class="codehilite"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="nx">fm</span> <span class="s">&quot;fmt&quot;</span>  <span class="c1">// alias</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fm</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;hello, world&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>Importing a package which is not used in the rest of the code is a build-error.</p>
<h5 id="package-level-declarations-and-initializations"><strong>Package level declarations and initializations</strong><a class="headerlink" href="#package-level-declarations-and-initializations" title="Permanent link">&para;</a></h5>
<p>After the import statement, zero or more constants (<code>const</code>), variables (<code>var)</code>, and types (<code>type</code>) can be declared; these are <em>global</em> (have package scope) and are known in all functions in the code (like <code>c</code> and <code>v</code> in <a href="https://github.com/shichao-an/twtg/blob/master/code_examples/chapter_4/gotemplate.go">gotemplate.go</a> below), and they are followed by one or more functions (<code>func</code>).</p>
<ul>
<li><a href="https://github.com/shichao-an/twtg/blob/master/code_examples/chapter_4/gotemplate.go">gotemplate.go</a></li>
</ul>
<h4 id="functions">Functions<a class="headerlink" href="#functions" title="Permanent link">&para;</a></h4>
<p>The simplest function declaration has the format:</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">functionName</span><span class="p">()</span>
</pre></div>


<p>A <code>main</code> function as starting is required. The <code>main</code> function must have no arguments and no return values results.</p>
<p>When the program executes, after initializations the first function called (the entry-point of the application) will be <code>main.main()</code>. The program exits immediately and successfully when <code>main.main</code> returns.</p>
<p>The code in functions (the body) is enclosed between braces: <code>{ }</code>.</p>
<ul>
<li>The first <code>{</code> must be on the same line as the function declaration: this is imposed by the compiler and <code>gofmt</code>.</li>
<li>The last <code>}</code> is positioned after the function code beneath function.</li>
<li>For small functions it is allowed that everything is written on one line, like for example: <code>func Sum(a, b int) int { return a + b }</code>.</li>
<li>The same rule applies wherever <code>{ }</code> are used (for example: <code>if</code>, etc.).</li>
</ul>
<p>Schematically, a general function looks like:</p>
<div class="codehilite"><pre><span class="kd">func</span> <span class="nx">functionName</span><span class="p">(</span><span class="nx">param1</span> <span class="nx">type1</span><span class="p">,</span> <span class="nx">param2</span> <span class="nx">type2</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span> <span class="p">(</span><span class="nx">ret1</span> <span class="nx">type1</span><span class="p">,</span> <span class="nx">ret2</span> <span class="nx">type2</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>


<h5 id="function-names"><strong>Function names</strong><a class="headerlink" href="#function-names" title="Permanent link">&para;</a></h5>
<ul>
<li><code>PascalCasing</code> (exported): function names only start with a capital letter when the function has to be used outside the package.</li>
<li><code>camelCasing</code> (private): every new word in the name starts with a capital letter.</li>
</ul>
<h5 id="fmtprint-and-fmtprintln"><strong><code>fmt.Print</code> and <code>fmt.Println</code></strong><a class="headerlink" href="#fmtprint-and-fmtprintln" title="Permanent link">&para;</a></h5>
<ul>
<li>The line <code>fmt.Println("hello, world")</code> calls the function <code>Println</code> from the package <code>fmt</code>, which prints the string-parameter to the console, followed by a newline-character <code>\n</code>.</li>
<li>The same result can be obtained with <code>fmt.Print("hello, world\n")</code>.</li>
<li><code>Print</code> and <code>Println</code> can also be applied to variables, like in: <code>fmt.Println(arr)</code>; they use the default output-format for the variable <code>arr</code>.</li>
</ul>
<h5 id="print-and-println"><strong><code>print</code> and <code>println</code></strong><a class="headerlink" href="#print-and-println" title="Permanent link">&para;</a></h5>
<p>Printing a string or a variable can be done even simpler with the predefined functions <code>print</code> and <code>println</code>. For example,</p>
<div class="codehilite"><pre><span class="nb">print</span><span class="p">(</span><span class="s">&quot;ABC&quot;</span><span class="p">)</span>
<span class="nb">println</span><span class="p">(</span><span class="s">&quot;ABC&quot;</span><span class="p">)</span>
<span class="nb">println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
</pre></div>


<p>These are only to be used in the debugging phase; when deploying a program replace them with their <code>fmt</code> relatives.</p>
<h4 id="comments">Comments<a class="headerlink" href="#comments" title="Permanent link">&para;</a></h4>
<p>Comments are not compiled. They are used by <a href="https://godoc.org/golang.org/x/tools/cmd/godoc">godoc</a>.</p>
<ul>
<li>A one-line comment starts with <code>//</code>, at the beginning or somewhere in a line; this is mostly used.</li>
<li>A multi-line or block-comment starts with <code>/*</code> and ends with <code>*/</code>, nesting is not allowed; this is used for making package documentation and commenting out code.</li>
</ul>
<p>[TWTG p56]</p>
<p>Every package should have a package comment, a block comment immediately preceding the package statement. A package can be spread over many files, but the comment needs to be in only one of them. This comment is shown when a developer demands info of the package with <code>godoc</code>.</p>
<h4 id="types">Types<a class="headerlink" href="#types" title="Permanent link">&para;</a></h4>
<p>A declaration of a variable with <code>var</code> automatically initializes it to the zero-value defined for its type. A type defines the set of values and the set of operations that can take place on those values.</p>
<p>Types can be:</p>
<ul>
<li><strong>Elementary</strong> (or <strong>primitive</strong>): int, float, bool, string,</li>
<li><strong>Structured</strong> (or <strong>composite</strong>): struct, array, slice, map, channel,</li>
<li><strong>Interfaces</strong> only describe the behavior of a type.</li>
</ul>
<p>A structured type which has no real value (yet) has the value <code>nil</code>, which is also the default value for these types (in C anc C++ it is NULL).</p>
<p>Use the keyword <code>type</code> for defining your own type (usually a struct type). It is also possible to define an <strong>alias</strong> for an existing type, for example:</p>
<div class="codehilite"><pre><span class="kd">type</span> <span class="p">(</span>
    <span class="nx">IZ</span> <span class="kt">int</span>
    <span class="nx">FZ</span> <span class="kt">float</span>
    <span class="nx">STR</span> <span class="kt">string</span>
<span class="p">)</span>
</pre></div>


<h4 id="program-structure">Program structure<a class="headerlink" href="#program-structure" title="Permanent link">&para;</a></h4>
<p><a href="https://github.com/shichao-an/twtg/blob/master/code_examples/chapter_4/gotemplate.go">gotemplate.go</a> is an example of the general structure of a Go program. This structure is not necessary, the compiler does not mind if <code>main()</code> or the variable declarations come last, but a uniform structure makes Go code better readable from top to bottom:</p>
<ul>
<li>After import: declare constants, variables and the types</li>
<li>Then comes the <code>init()</code> function if there is any: this is a special function that every package can contain and that is executed first.</li>
<li>Then comes the <code>main()</code> function (only in the package <code>main</code>)</li>
<li>Then come the rest of the functions:<ul>
<li>The methods on the types first, or;</li>
<li>The functions in order as they are called from <code>main()</code> onwards, or;</li>
<li>The methods and functions alphabetically if the number of functions is high.</li>
</ul>
</li>
</ul>
<h5 id="order-of-execution"><strong>Order of execution</strong><a class="headerlink" href="#order-of-execution" title="Permanent link">&para;</a></h5>
<ol>
<li>All packages in package <code>main</code> are imported in the order as indicated.</li>
<li>In every package, if it imports packages, Step 1 is called for this package (recursively) but a certain package is imported only once.</li>
<li>For every package (in reverse order of dependencies) all constants and variables are evaluated, and the <code>init()</code> if it contains this function.</li>
<li>In package <code>main</code> the same happens, and then <code>main()</code> starts executing.</li>
</ol>
<h4 id="conversions">Conversions<a class="headerlink" href="#conversions" title="Permanent link">&para;</a></h4>
<p>A value can be <em>converted</em> (<em>cast</em>, <em>coerced</em>) into a value of another type. Go never does <em>implicit</em> (automatic) conversion, it must be done explicitly with the syntax like a function call, as in <code>valueOfTypeB = typeB(valueOfTypeA)</code>. For example:</p>
<div class="codehilite"><pre><span class="nx">a</span> <span class="o">:=</span> <span class="mf">5.0</span>
<span class="nx">b</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
</pre></div>


<p>This can only succeed in certain well defined cases (from a narrower type to a broader type, for example: <code>int16</code> to <code>int32</code>). When converting from a broader type to a narrower type (for example: <code>int32</code> to <code>int16</code>, or <code>float32</code> to <code>int</code>) loss of value (<em>truncation</em>) can occur. When the conversion is impossible and the compiler detects this, a compile-error is given, otherwise a runtime-error occurs.</p>
<p><u>Variables with the same underlying type can be converted into one another:</u></p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">a</span> <span class="nx">IZ</span> <span class="p">=</span> <span class="mi">5</span>
<span class="nx">c</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
<span class="nx">d</span> <span class="o">:=</span> <span class="nx">IZ</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
</pre></div>


<h4 id="naming">Naming<a class="headerlink" href="#naming" title="Permanent link">&para;</a></h4>
<p>[TWTG p60]</p>
<ul>
<li><a href="https://golang.org/doc/effective_go.html#names">Names - Effective Go</a></li>
</ul>
<h4 id="constants">Constants<a class="headerlink" href="#constants" title="Permanent link">&para;</a></h4>
<p>A constant (<code>const</code>) contains data which does not change. This data can only be of type boolean, number (integer, float or complex) or string. It is defined with the format <code>const identifier [type] = value</code> (type specifier <code>[type]</code> is optional, the compiler can implicitly derive the type from the value). For example:</p>
<div class="codehilite"><pre><span class="kd">const</span> <span class="nx">b</span> <span class="kt">string</span> <span class="p">=</span> <span class="s">&quot;abc&quot;</span>
<span class="kd">const</span> <span class="nx">Pi</span> <span class="p">=</span> <span class="mf">3.14159</span>
</pre></div>


<p>A value derived from an untyped constant becomes typed when it is used within a context that requires a typed value. For example:</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">n</span> <span class="kt">int</span>
<span class="nx">f</span><span class="p">(</span><span class="nx">n</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">// untyped numeric constant 5 becomes typed as int</span>
</pre></div>


<p>Constants must be evaluated at compile time; a const can be defined as a calculation, but all the values necessary for the calculation must be available at compile time. For example:</p>
<div class="codehilite"><pre><span class="kd">const</span> <span class="nx">c1</span> <span class="p">=</span> <span class="mi">2</span><span class="o">/</span><span class="mi">3</span> <span class="c1">// ok</span>
<span class="kd">const</span> <span class="nx">c2</span> <span class="p">=</span> <span class="nx">getNumber</span><span class="p">()</span> <span class="c1">// gives the build error: getNumber() used as value</span>
</pre></div>


<p>Constants can be used for <strong>enumerations</strong>:</p>
<div class="codehilite"><pre><span class="kd">const</span> <span class="p">(</span>
    <span class="nx">Unknown</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="nx">Female</span> <span class="p">=</span> <span class="mi">1</span>
    <span class="nx">Male</span> <span class="p">=</span> <span class="mi">2</span>
<span class="p">)</span>
</pre></div>


<p>In such cases, the value <code>iota</code> can be used to enumerate the values:</p>
<div class="codehilite"><pre><span class="kd">const</span> <span class="p">(</span>  <span class="c1">// iota is reset to 0</span>
    <span class="nx">c0</span> <span class="p">=</span> <span class="kc">iota</span>  <span class="c1">// c0 == 0</span>
    <span class="nx">c1</span> <span class="p">=</span> <span class="kc">iota</span>  <span class="c1">// c1 == 1</span>
    <span class="nx">c2</span> <span class="p">=</span> <span class="kc">iota</span>  <span class="c1">// c2 == 2</span>
<span class="p">)</span>
</pre></div>


<p>This can be shortened to:</p>
<div class="codehilite"><pre><span class="kd">const</span> <span class="p">(</span>
    <span class="nx">c0</span> <span class="p">=</span> <span class="kc">iota</span>
    <span class="nx">c1</span>
    <span class="nx">c2</span>
<span class="p">)</span>
</pre></div>


<p>[TWTG p62-63]</p>
<p>See <a href="https://golang.org/ref/spec#Constant_declarations">Constant declarations</a> and <a href="https://golang.org/ref/spec#Iota">iota</a>.</p>
<h4 id="variables">Variables<a class="headerlink" href="#variables" title="Permanent link">&para;</a></h4>
<p>The general form for declaring a variable is <code>var identifier type</code>. The type is written after the identifier of the variable, contrary to almost any other programming language. Why did the Go designers chose for this convention? It removes some ambiguity which can exist in C declarations, for example, in <code>int* a, b;</code>, only <code>a</code> is a pointer and <code>b</code> is not; in Go, they can both be declared pointers as follows: <code>var a, b *int</code>.</p>
<p>Variables can be declared using the following format:</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">a</span> <span class="kt">int</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="kt">bool</span>
<span class="kd">var</span> <span class="nx">str</span> <span class="kt">string</span>
</pre></div>


<p>This can be also written as (<u>mainly used to declare variables globally</u>):</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="p">(</span>
    <span class="nx">a</span> <span class="kt">int</span>
    <span class="nx">b</span> <span class="kt">bool</span>
    <span class="nx">str</span> <span class="kt">string</span>
<span class="p">)</span>
</pre></div>


<p>When a variable is declared it contains automatically the default <a href="https://golang.org/ref/spec#The_zero_value">zero value</a> for its type: <code>false</code> for booleans, 0 for integers, 0.0 for floats, "" for strings, and <code>nil</code> for pointers, functions, interfaces, slices, channels, and maps. <u>All memory in Go is initialized.</u></p>
<p>A variable (constant, type, function) is only known in a certain range of the program, called the <strong>scope</strong>:</p>
<ul>
<li>Variables declared outside of any function (at the top level) have <strong>global scope</strong> (or <strong>package scope</strong>): they are visible and available in all source files of the package.</li>
<li>Variables declared in a function have <strong>local scope</strong>: they are only known in that function, the same goes for parameters and return-variables.</li>
<li>Variables defined inside such a construct (e.g. <code>if</code>, <code>for</code>) are only known within that construct (<strong>construct scope</strong>). Mostly you can think of a scope as the codeblock ( surrounded by <code>{ }</code> ) in which the variable is declared.</li>
</ul>
<p>Although identifiers have to be unique, an identifier declared in a block may be redeclared in an inner block: in this block (but only there) the redeclared variable takes priority and <em>shadows</em> the outer variable with the same name; if used, care must be taken to avoid subtle errors.</p>
<p>Variables can get their value (which is called <em>assigning</em> and uses the assignment operator <code>=</code>) at compile time, but a value can also be computed or changed during runtime. For example:</p>
<div class="codehilite"><pre><span class="nx">a</span> <span class="p">=</span> <span class="mi">15</span>
<span class="nx">b</span> <span class="p">=</span> <span class="kc">false</span>
</pre></div>


<p>In general, <code>a</code> variable <code>b</code> can only be assigned to a variable <code>a</code> as in <code>a = b</code>, when <code>a</code> and <code>b</code> are of the same type.</p>
<p>Declaration and assignment (initialization) can be combined, in the general format <code>var identifier [type] = value</code>. For example:</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">a</span> <span class="kt">int</span> <span class="p">=</span> <span class="mi">15</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="kt">bool</span> <span class="p">=</span> <span class="kc">false</span>
</pre></div>


<p>However, the Go compiler is intelligent enough to derive the type of a variable from its value (dynamically, also called <strong>automatic type inference</strong>, similar to Python and Ruby, but there it happens in run time), so the following forms (omitting the type) are also correct:</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">a</span> <span class="p">=</span> <span class="mi">15</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="p">=</span> <span class="kc">false</span>
<span class="c1">// Or, equivalently:</span>
<span class="kd">var</span> <span class="p">(</span>
    <span class="nx">a</span> <span class="p">=</span> <span class="mi">15</span>
    <span class="nx">b</span> <span class="p">=</span> <span class="kc">false</span>
<span class="p">)</span>
</pre></div>


<p>It can still be useful to include the type information in the case where you want the variable to be typed something different than what would be inferred, such as in: <code>var n int64 = 2</code>.</p>
<p>However, an expression (declaration) like <code>var a</code> is not correct, because the compiler has no clue about the type of <code>a</code>.</p>
<p>Variables could also be expressions computed at runtime, like:</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="p">(</span>
    <span class="nx">HOME</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Getenv</span><span class="p">(</span><span class="s">&quot;HOME&quot;</span><span class="p">)</span>
    <span class="nx">USER</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Getenv</span><span class="p">(</span><span class="s">&quot;USER&quot;</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>


<p>The <code>var</code> syntax is mainly used at a global, package level; in functions it is replaced by the short declaration syntax <code>:=</code>.</p>
<h4 id="value-types-and-reference-types">Value types and reference types<a class="headerlink" href="#value-types-and-reference-types" title="Permanent link">&para;</a></h4>
<p>Memory in a computer is used in programs as a enormous number of <strong>words</strong>:</p>
<ul>
<li>All words have the same length of 32 bits (4 bytes) or 64 bits (8 bytes), according to the processor and the operating system.</li>
<li>All words are identified by their memory address (represented as a hexadecimal number).</li>
</ul>
<p>All variables of elementary (primitive) types like int, float, bool, string are <strong>value types</strong>. They point directly to their value contained in memory.</p>
<p>Composite types like arrays and structs are also value types.</p>
<p>When assigning the value of a value type to another variable: <code>j = i</code>, a copy of the original value <code>i</code> is made in memory, as illustrated in the figure below:</p>
<p><a href="./twtg_figure_4.2.png" title="Fig 4.2: Assignment of value types"><img alt="Fig 4.2: Assignment of value types" src="./twtg_figure_4.2.png" /></a></p>
<p>The memory address of the word where variable <code>i</code> is stored is given by <code>&amp;i</code>.</p>
<p>A <strong>reference type</strong> variable <code>r1</code> contains the address of the memory location where the value of <code>r1</code> is stored (or at least the first word of it). This address, called a <strong>pointer</strong>, is also contained in a word.</p>
<p>The different words a reference type points to could be sequential memory addresses (the memory layout is said to be contiguously) which is the most efficient storage for computation, or the words could be spread around, each pointing to the next.</p>
<p>When assigning <code>r2 = r1</code>, only the reference (the address) is copied, as illustrated in the figure below:</p>
<p><a href="./twtg_figure_4.3.png" title="Fig 4.3: Reference types and assignment"><img alt="Fig 4.3: Reference types and assignment" src="./twtg_figure_4.3.png" /></a></p>
<p>If the value of <code>r1</code> is modified, all references of that value (like <code>r1</code> and <code>r2</code>) then point to the modified content.</p>
<p>In Go, pointers are reference types, as well as slices, maps and channels. The variables that are referenced are stored in the heap, which is garbage collected and which is a much larger memory space than the stack.</p>
<h4 id="printing">Printing<a class="headerlink" href="#printing" title="Permanent link">&para;</a></h4>
<ul>
<li>The function <code>fmt.Printf</code> is visible outside the <code>fmt</code> package because it starts with a <code>P</code>, and is used to print output to the console. It generally uses a format string as its first argument.<ul>
<li>This format string can contain one or more format-specifiers <code>%..</code>, where <code>..</code> denotes the type of the value to be inserted, e.g. <code>%s</code> stands for a string value, <code>%v</code> is the general default format specifier.</li>
</ul>
</li>
<li>The function <code>fmt.Sprintf</code> behaves in exactly the same way as Printf, but simply returns the formatted string.</li>
<li>The functions <code>fmt.Print</code> and <code>fmt.Println</code> perform fully automatic formatting of their arguments using the format-specifier <code>%v</code>, adding spaces between arguments and the latter a newline at the end. For example:<ul>
<li><code>fmt.Print("Hello:", 23)</code> produces as output: <code>Hello: 23</code>.</li>
</ul>
</li>
</ul>
<h4 id="short-forms-of-declaration-and-assignment">Short forms of declaration and assignment<a class="headerlink" href="#short-forms-of-declaration-and-assignment" title="Permanent link">&para;</a></h4>
<h5 id="initializing-declaration-with"><strong>Initializing declaration with <code>:=</code></strong><a class="headerlink" href="#initializing-declaration-with" title="Permanent link">&para;</a></h5>
<p>With the type omitted, the keyword <code>var</code> is pretty superfluous (e.g. <code>var a = 50</code>), so it may be written as <code>a: = 50</code>, and the types of is inferred by the compiler.</p>
<p><code>a := 50</code> is the preferred form, but <u>it can only be used inside functions, not in package scope.</u> The <code>:=</code> operator effectively makes a new variable; it is also called an <strong>initializing declaration</strong>.</p>
<p>If after the lines above in the same codeblock we declare <code>a := 20</code>, this is not allowed: the compiler gives the error "no new variables on left side of <code>:=</code>"; however <code>a = 20</code> is ok because then the same variable only gets a new value.</p>
<h5 id="undeclared-and-unused-variables"><strong>Undeclared and unused variables</strong><a class="headerlink" href="#undeclared-and-unused-variables" title="Permanent link">&para;</a></h5>
<ul>
<li>A variable a which is used, but not declared, gives a compiler error: "undefined: a".</li>
<li>Declaring a <em>local</em> variable, but not using it, is a compiler error: "a declared and not used". However, for global variables, this is allowed. [TWTG p69]</li>
</ul>
<h5 id="multiple-declaration-and-assignment"><strong>Multiple declaration and assignment</strong><a class="headerlink" href="#multiple-declaration-and-assignment" title="Permanent link">&para;</a></h5>
<ul>
<li>Multiple declarations of variables of the same type on a single line, like: <code>var a, b, c int</code>. This is an important reason why the type is written after the identifier(s).</li>
<li>Multiple assignments of variables (parallel or simultaneous assignment):<ul>
<li>For already-declared variables: <code>a, b, c = 5, 7, "abc"</code></li>
<li>For undeclared variables: <code>a, b, c := 5, 7, "abc"</code></li>
</ul>
</li>
</ul>
<p>With two variables it can be used to perform a <em>swap</em> of the values: <code>a, b = b, a</code>.</p>
<p>The blank identifier <code>_</code> can also be used to throw away values, like the value 5 in: <code>_, b = 5, 7</code></p>
<p><code>_</code> is in effect a write-only variable, you cannot ask for its value. <u>It exists because a declared variable in Go must also be used, and sometimes you don’t need to use all return values from a function.</u></p>
<p>The multiple assignment is also used when a function returns more than 1 value, for example: <code>val, err = func1(var1)</code>.</p>
<h3 id="structs">Structs<a class="headerlink" href="#structs" title="Permanent link">&para;</a></h3>
<h4 id="visibility">Visibility<a class="headerlink" href="#visibility" title="Permanent link">&para;</a></h4>
<p>The naming of the struct type and its fields adheres to the visibility rule. It is possible that an exported struct type has a mix of fields: some exported, others not.</p>
<h4 id="factory-methods">Factory methods<a class="headerlink" href="#factory-methods" title="Permanent link">&para;</a></h4>
<p>Force using factory methods on a private type [TWTG p233]:</p>
<div class="codehilite"><pre><span class="nx">wrong</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">matrix</span><span class="p">.</span><span class="nx">matrix</span><span class="p">)</span>    <span class="c1">// will NOT compile (matrix is private)</span>
<span class="nx">right</span> <span class="o">:=</span> <span class="nx">matrix</span><span class="p">.</span><span class="nx">NewMatrix</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>   <span class="c1">// the ONLY way to instantiate a matrix</span>
</pre></div>


<h4 id="structs-with-tags">Structs with tags<a class="headerlink" href="#structs-with-tags" title="Permanent link">&para;</a></h4>
<p>Only the package <code>reflect</code> can access tag content. <code>reflect.TypeOf()</code> on a variable gives the right type; if this is a struct type, it can be indexed by <code>Field</code>, and then the <code>Tag</code> property can be used. For example:</p>
<ul>
<li><a href="https://github.com/shichao-an/twtg/blob/master/code_examples/chapter_10/struct_tag.go">struct_tag.go</a></li>
</ul>
<h4 id="anonymous-fields-and-embedded-structs">Anonymous fields and embedded structs<a class="headerlink" href="#anonymous-fields-and-embedded-structs" title="Permanent link">&para;</a></h4>
<p>Conflicting names [TWTG p239]</p>
<ol>
<li>An outer name hides an inner name. This provides a way to override a field or method.</li>
<li>If the same name appears twice at the same level, it is an error if the name is used by the program.</li>
</ol>
<h3 id="methods">Methods<a class="headerlink" href="#methods" title="Permanent link">&para;</a></h3>
<ul>
<li>Receiver type</li>
<li>Method set: collection of all the methods on a given type <code>T</code> (or <code>*T</code>)</li>
<li>No method overloading</li>
<li>A method and the type on which it acts must be defined in the same package</li>
<li>Pointer or value as receiver: if for a type <code>T</code> a method <code>Meth()</code> exists on <code>*T</code> and <code>t</code> is a variable of type <code>T</code>, then <code>t.Meth()</code> is automatically translated to <code>(&amp;t).Meth()</code> [TWTG p246]</li>
</ul>
<h4 id="methods-on-embedded-types-and-inheritance">Methods on embedded types and inheritance<a class="headerlink" href="#methods-on-embedded-types-and-inheritance" title="Permanent link">&para;</a></h4>
<ul>
<li>Overriding: <a href="https://github.com/shichao-an/twtg/blob/master/code_examples/chapter_10/method4.go">method4.go</a> [TWTG p250]</li>
<li>Embedding multiple anonymous types: <a href="https://github.com/shichao-an/twtg/blob/master/code_examples/chapter_10/mult_inheritance.go">mult_inheritance.go</a> [TWTG p253-254]</li>
</ul>
<h4 id="embed-functionality-in-a-type">Embed functionality in a type<a class="headerlink" href="#embed-functionality-in-a-type" title="Permanent link">&para;</a></h4>
<ol>
<li>Aggregation (or composition): include a named field of the type of the wanted functionality, <a href="https://github.com/shichao-an/twtg/blob/master/code_examples/chapter_10/embed_func1.go">embed_func1.go</a></li>
<li>Embedding: <a href="https://github.com/shichao-an/twtg/blob/master/code_examples/chapter_10/embed_func2.go">embed_func2.go</a></li>
</ol>
<h4 id="format-specifiers">Format specifiers<a class="headerlink" href="#format-specifiers" title="Permanent link">&para;</a></h4>
<p><code>String()</code>-method on a type [TWTG p259]:</p>
<ul>
<li><code>%T</code>: complete type specification</li>
<li><code>%#v</code> complete output of the instance with its fields</li>
</ul>
<h3 id="interfaces">Interfaces<a class="headerlink" href="#interfaces" title="Permanent link">&para;</a></h3>
<p>Interfaces in Go provide a way to specify the behavior of an object: if something can do this, then it can be used here.</p>
<ul>
<li>A type doesn’t have to state explicitly that it implements an interface: interfaces are satisfied implicitly. Multiple types can implement the same interface.</li>
<li>A type that implements an interface can also have other functions.</li>
<li>A type can implement many interfaces.</li>
<li>An interface type can contain a reference to an instance of any of the types that implement the interface (an interface has what is called a dynamic type)</li>
</ul>
<p>The interface variable both contains the value of the receiver instance and a pointer to the appropriate method in a method table.</p>
<ul>
<li><a href="https://github.com/shichao-an/twtg/blob/master/code_examples/chapter_11/interfaces_poly.go">interfaces_poly.go</a></li>
</ul>
<h4 id="interface-embedding-interfaces">Interface embedding interfaces<a class="headerlink" href="#interface-embedding-interfaces" title="Permanent link">&para;</a></h4>
<p>An interface can contain the name of one or more other interface(s), which is equivalent to explicitly enumerating the methods of the embedded interface in the containing interface. [TWTG p270]</p>
<h4 id="detect-and-convert-the-type-of-an-interface-variable-type-assertions">Detect and convert the type of an interface variable: type assertions<a class="headerlink" href="#detect-and-convert-the-type-of-an-interface-variable-type-assertions" title="Permanent link">&para;</a></h4>
<p>We can test if <code>varI</code> (interface variable) contains at a certain moment a variable of type <code>T</code> with the type assertion test [TWTG p271]:</p>
<div class="codehilite"><pre><span class="k">if</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">varI</span><span class="p">.(</span><span class="nx">T</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
    <span class="c1">// checked type assertion</span>
<span class="p">}</span>
</pre></div>


<ul>
<li><a href="https://github.com/shichao-an/twtg/blob/master/code_examples/chapter_11/type_interfaces.go">type_interfaces.go</a></li>
</ul>
<h4 id="the-type-switch">The type switch<a class="headerlink" href="#the-type-switch" title="Permanent link">&para;</a></h4>
<ul>
<li><a href="https://golang.org/doc/effective_go.html#type_switch">Type switch</a></li>
</ul>
<p><small><a href="https://gist.github.com/shichao-an/36c167f2b8f649e4a468">type_switch.go</a></small></p>
<script src="https://gist.github.com/shichao-an/36c167f2b8f649e4a468.js"></script>

<h4 id="testing-if-a-value-implements-an-interface">Testing if a value implements an interface<a class="headerlink" href="#testing-if-a-value-implements-an-interface" title="Permanent link">&para;</a></h4>
<p><code>v</code> is a value and we want to test whether it implements the <code>Stringer</code> interface:</p>
<div class="codehilite"><pre><span class="k">if</span> <span class="nx">sv</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">v</span><span class="p">.(</span><span class="nx">Stringer</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;v implements String(): %s\n&quot;</span><span class="p">,</span> <span class="nx">sv</span><span class="p">.</span><span class="nx">String</span><span class="p">());</span> <span class="c1">// note: sv, not v</span>
<span class="p">}</span>
</pre></div>


<p>Writing functions so that they accept an interface variable as a parameter makes them more general. Use interfaces to make code more generally applicable.</p>
<h4 id="variables-of-interface-type">Variables of interface type<a class="headerlink" href="#variables-of-interface-type" title="Permanent link">&para;</a></h4>
<p>A variable of interface type stores a pair: the concrete value assigned to the variable, and that value's type descriptor.</p>
<ul>
<li><a href="http://blog.golang.org/laws-of-reflection#TOC_3.">The representation of an interface</a></li>
</ul>
<h4 id="using-method-sets-with-interfaces">Using method sets with interfaces<a class="headerlink" href="#using-method-sets-with-interfaces" title="Permanent link">&para;</a></h4>
<ol>
<li>Pointer methods can be called with pointers.</li>
<li>Value methods can be called with values.</li>
<li>Value-receiver methods can be called with pointer values because they can be dereferenced first.</li>
<li>Pointer-receiver methods <strong>cannot</strong> be called with values, however, because the value stored inside an interface has no address.</li>
</ol>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/shichao-an/twtg/blob/master/code_examples/chapter_11/methodset2.go">methodset2.go</a></li>
<li><a href="https://github.com/shichao-an/twtg/blob/master/code_examples/chapter_11/sort/sort.go">sort.go</a></li>
<li><a href="https://github.com/shichao-an/twtg/blob/master/code_examples/chapter_11/sortmain.go">sortmain.go</a></li>
</ul>
<h4 id="empty-interface">Empty Interface<a class="headerlink" href="#empty-interface" title="Permanent link">&para;</a></h4>
<p>A variable of empty interface type <code>interface{}</code> can through assignment receive a variable of any type.</p>
<h4 id="interface-slice">Interface Slice<a class="headerlink" href="#interface-slice" title="Permanent link">&para;</a></h4>
<ul>
<li><a href="https://github.com/golang/go/wiki/InterfaceSlice">Interface slice</a></li>
</ul>
<h4 id="interface-to-interface">Interface to interface<a class="headerlink" href="#interface-to-interface" title="Permanent link">&para;</a></h4>
<p>An interface value can also be assigned to another interface value, as long as the underlying value implements the necessary methods.</p>
<p><small><a href="https://gist.github.com/shichao-an/4f97af9d9b7333f95b87">twtg_11.9.5.go</a></small></p>
<script src="https://gist.github.com/shichao-an/4f97af9d9b7333f95b87.js"></script>

<h3 id="reflection">Reflection<a class="headerlink" href="#reflection" title="Permanent link">&para;</a></h3>
<p>Reflection is the ability of a program to examine its own structure, particularly through the types; it’s a form of <em>metaprogramming</em>. <code>reflect</code> can be used to investigate types and variables at runtime, e.g. its size, its methods, and it can also call these methods "dynamically".</p>
<ul>
<li><code>reflect.TypeOf</code></li>
<li><code>reflect.ValueOf</code></li>
</ul>
<p><small><a href="https://gist.github.com/shichao-an/2eae3c34f717fb5bdde8">twtg_11.10.1.go</a></small></p>
<script src="https://gist.github.com/shichao-an/2eae3c34f717fb5bdde8.js"></script>

<ul>
<li><code>v.Kind()</code>: returns a constant indicating the type</li>
<li><code>v.Interface()</code>: recovers the (interface) value</li>
</ul>
<p>Example:</p>
<ul>
<li><a href="https://github.com/shichao-an/twtg/blob/master/code_examples/chapter_11/reflect1.go">reflect1.go</a></li>
</ul>
<h4 id="setting-a-value-through-reflection">Setting a value through reflection<a class="headerlink" href="#setting-a-value-through-reflection" title="Permanent link">&para;</a></h4>
<ul>
<li><a href="http://golang.org/pkg/reflect/#Value.CanSet">Settability</a>: a <code>Value</code> can be changed only if it is addressable and was not obtained by the use of unexported struct fields, <a href="https://github.com/shichao-an/twtg/blob/master/code_examples/chapter_11/reflect2.go">reflect2.go</a></li>
</ul>
<h4 id="reflection-on-structs">Reflection on structs<a class="headerlink" href="#reflection-on-structs" title="Permanent link">&para;</a></h4>
<ul>
<li><a href="https://github.com/shichao-an/twtg/blob/master/code_examples/chapter_11/reflect_struct.go">reflect_struct.go</a></li>
</ul>
<h4 id="printf-and-reflection"><code>Printf</code> and reflection<a class="headerlink" href="#printf-and-reflection" title="Permanent link">&para;</a></h4>
<p><code>Printf</code> uses the reflection package to unpack it and discover the argument list, <a href="https://github.com/shichao-an/twtg/blob/master/code_examples/chapter_11/print.go">print.go</a></p>
<h4 id="interfaces-and-dynamic-typing">Interfaces and dynamic typing<a class="headerlink" href="#interfaces-and-dynamic-typing" title="Permanent link">&para;</a></h4>
<ul>
<li>In Go there are no classes: data (structures, or more general types) and methods are treated <em>orthogonally</em>, they are much more <u>loosely coupled</u>.</li>
<li>There is no requirement for explicitly declaring that a type satisfies an interface. This allows interfaces to be defined and used without having to modify existing code.</li>
<li>Types implementing an interface can be passed to any function which takes that interface as an argument. This resembles much more the <strong>duck typing</strong> in dynamic languages.</li>
<li>Extraction of an interface reduces thereby the number of types and methods needed [TWTG p301]: <a href="https://github.com/shichao-an/twtg/blob/master/code_examples/chapter_11/multi_interfaces_poly.go">multi_interfaces_poly.go</a><ul>
<li>If a type must implement a new interface, the type itself doesn’t have to be changed, you must only make the new method(s) on the type. [TWTG p303]</li>
</ul>
</li>
<li>Empty interface and function overloading [TWTG p304]</li>
<li>Inheritance of interfaces:<ul>
<li>A type includes (embeds) another type (which implements one or more interfaces) as a pointer, then the type can use all of the interfaces-methods. [TWTG p304]</li>
<li>A type can also inherit from multiple interfaces providing something like <strong>multiple inheritance</strong>. [TWTG p305]</li>
</ul>
</li>
</ul>
<h4 id="summary-of-object-orientedness-of-go">Summary of object-orientedness of Go<a class="headerlink" href="#summary-of-object-orientedness-of-go" title="Permanent link">&para;</a></h4>
<p>[TWTG p306]</p>
<ul>
<li>Encapsulation (data hiding): visibility rule<ul>
<li><strong>Package scope</strong>: lowercase</li>
<li><strong>Exported</strong>: uppercase</li>
</ul>
</li>
<li>Inheritance: embedding one or multiple types</li>
<li>Polymorphism: a variable of a type can be assigned to a variable of any interface it implements. Types and interfaces are loosely coupled; multiple inheritance is possible through implementing multiple interfaces.</li>
</ul>
<h4 id="higher-order-functions">Higher order functions<a class="headerlink" href="#higher-order-functions" title="Permanent link">&para;</a></h4>
<p>[TWTG p306-309]</p>
<hr />
<h3 id="references">References<a class="headerlink" href="#references" title="Permanent link">&para;</a></h3>
<ul>
<li>[TWTG] <em>The Way To Go: A Thorough Introduction To The Go Programming Language</em></li>
<li>[DOC] <a href="https://golang.org/doc/">Documentation</a></li>
<li>[SPEC] <a href="https://golang.org/ref/spec#The_zero_value">The Go Programming Language Specification</a></li>
<li>[EG] <a href="https://golang.org/doc/effective_go.html">Effective Go</a></li>
<li>[TGB] <a href="https://blog.golang.org/">The Go Blog</a></li>
</ul>
            </div>
        </div>

        <footer class="col-md-12">
            
        </footer>

        <script src="../js/jquery-1.10.2.min.js"></script>
        <script src="../js/bootstrap-3.0.3.min.js"></script>
        <script src="../js/highlight.pack.js"></script>
        <script src="../js/base.js"></script>
        <script src="../custom.js"></script>
    </body>
</html>