<!DOCTYPE html>
<html lang="en">
    <head>
        <!-- Global Site Tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-59055167-2"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments)};
          gtag('js', new Date());

          gtag('config', 'UA-59055167-2');
        </script>

        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://notes.shichao.io/apue/ch9/">
        <link rel="shortcut icon" href="../../toki_32.png">
        

	<title>Chapter 9. Process Relationships - Shichao's Notes</title>

        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../../css/base.css" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,400italic,500,600" rel="stylesheet">
        <link href="../../custom.css" rel="stylesheet">
        <link href="../../friendly.css" rel="stylesheet">
        <link href="../../theme.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        
<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../..">Shichao's Notes</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">APUE <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../ch1/">Chapter 1. UNIX System Overview</a>
                        </li>
                      
                        <li>
                            <a href="../ch2/">Chapter 2. UNIX Standardization and Implementations</a>
                        </li>
                      
                        <li>
                            <a href="../ch3/">Chapter 3. File I/O</a>
                        </li>
                      
                        <li>
                            <a href="../ch4/">Chapter 4. Files and Directories</a>
                        </li>
                      
                        <li>
                            <a href="../ch5/">Chapter 5. Standard I/O Library</a>
                        </li>
                      
                        <li>
                            <a href="../ch6/">Chapter 6. System Data Files and Information</a>
                        </li>
                      
                        <li>
                            <a href="../ch7/">Chapter 7. Process Environment</a>
                        </li>
                      
                        <li>
                            <a href="../ch8/">Chapter 8. Process Control</a>
                        </li>
                      
                        <li class="active">
                            <a href="./">Chapter 9. Process Relationships</a>
                        </li>
                      
                        <li>
                            <a href="../ch10/">Chapter 10. Signals</a>
                        </li>
                      
                        <li>
                            <a href="../ch11/">Chapter 11. Threads</a>
                        </li>
                      
                        <li>
                            <a href="../ch12/">Chapter 12. Thread Control</a>
                        </li>
                      
                        <li>
                            <a href="../ch13/">Chapter 13. Daemon Processes</a>
                        </li>
                      
                        <li>
                            <a href="../ch14/">Chapter 14. Advanced I/O</a>
                        </li>
                      
                        <li>
                            <a href="../ch15/">Chapter 15. Interprocess Communication</a>
                        </li>
                      
                        <li>
                            <a href="../ch16/">Chapter 16. Network IPC: Sockets</a>
                        </li>
                      
                        <li>
                            <a href="../ch17/">Chapter 17. Advanced IPC</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UNP <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../unp/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch2/">Chapter 2. The Transport Layer: TCP, UDP, and SCTP</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch3/">Chapter 3. Sockets Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch4/">Chapter 4. Elementary TCP Sockets</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch5/">Chapter 5. TCP Client/Server Example</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch6/">Chapter 6. I/O Multiplexing: The select and poll Functions</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch7/">Chapter 7. Socket Options</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch8/">Chapter 8. Elementary UDP Sockets</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">TCPv1 <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../tcpv1/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch2/">Chapter 2. The Internet Address Architecture</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch3/">Chapter 3. Link Layer</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch4/">Chapter 4. ARP: Address Resolution Protocol</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch5/">Chapter 5. The Internet Protocol (IP)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch6/">Chapter 6. System Configuration: DHCP and Autoconfiguration</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch7/">Chapter 7. Firewalls and Network Address Translation (NAT)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch8/">Chapter 8. ICMPv4 and ICMPv6: Internet Control Message Protocol</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch9/">Chapter 9. Broadcasting and Local Multicasting (IGMP and MLD)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch10/">Chapter 10. User Datagram Protocol (UDP) and IP Fragmentation</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch11/">Chapter 11. Name Resolution and the Domain Name System (DNS)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch12/">Chapter 12. TCP: The Transmission Control Protocol (Preliminaries)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch13/">Chapter 13. TCP Connection Management</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch14/">Chapter 14. TCP Timeout and Retransmission</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch15/">Chapter 15. TCP Data Flow and Window Management</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch16/">Chapter 16. TCP Congestion Control</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch17/">Chapter 17. TCP Keepalive</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch18/">Chapter 18. Security: EAP, IPsec, TLS, DNSSEC, and DKIM</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/headers/">Headers</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">GOPL <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../gopl/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch1/">Chapter 1. Tutorial</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch2/">Chapter 2. Program Structure</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch3/">Chapter 3. Basic Data Types</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch4/">Chapter 4. Composite Types</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch5/">Chapter 5. Functions</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch6/">Chapter 6. Methods</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch7/">Chapter 7. Interfaces</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch8/">Chapter 8. Goroutines and Channels</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch9/">Chapter 9. Concurrency with Shared Variables</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch10/">Chapter 10. Packages and the Go Tool</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch11/">Chapter 11. Testing</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch12/">Chapter 12. Reflection</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">CSN <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../csn/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../csn/part1/">Part 1: Language</a>
                        </li>
                      
                        <li>
                            <a href="../../csn/part2/">Part 2: Advanced</a>
                        </li>
                      
                    </ul>
                </li>
            <li>
                    <a href="../../toc/">TOC</a>
                </li>
            </ul>
            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    
                        <a href="https://github.com/shichao-an/notes/blob/master/docs/apue/ch9.md">
                    
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#chapter-9-process-relationships">Chapter 9. Process Relationships</a></li>
        
    
        <li class="main "><a href="#introduction">Introduction</a></li>
        
    
        <li class="main "><a href="#terminal-logins">Terminal Logins</a></li>
        
            <li><a href="#bsd-terminal-logins">BSD Terminal Logins</a></li>
        
            <li><a href="#mac-os-x-terminal-logins">Mac OS X Terminal Logins</a></li>
        
            <li><a href="#linux-terminal-logins">Linux Terminal Logins</a></li>
        
            <li><a href="#solaris-terminal-logins">Solaris Terminal Logins</a></li>
        
    
        <li class="main "><a href="#network-logins">Network Logins</a></li>
        
            <li><a href="#bsd-network-logins">BSD Network Logins</a></li>
        
            <li><a href="#mac-os-x-network-logins">Mac OS X Network Logins</a></li>
        
            <li><a href="#linux-network-logins">Linux Network Logins</a></li>
        
            <li><a href="#solaris-network-logins">Solaris Network Logins</a></li>
        
    
        <li class="main "><a href="#process-groups">Process Groups</a></li>
        
            <li><a href="#process-group-lifetime">Process group lifetime</a></li>
        
            <li><a href="#setpgid-function">setpgid function</a></li>
        
    
        <li class="main "><a href="#sessions">Sessions</a></li>
        
            <li><a href="#the-setsid-function">The setsid function</a></li>
        
            <li><a href="#ensuring-the-successful-call-of-setsid">Ensuring the successful call of setsid</a></li>
        
            <li><a href="#session-leader-and-session-id">Session Leader and Session ID</a></li>
        
            <li><a href="#the-getsid-function">The getsid function</a></li>
        
    
        <li class="main "><a href="#controlling-terminal">Controlling Terminal</a></li>
        
            <li><a href="#mechanisms-of-allocating-a-controlling-terminal">Mechanisms of allocating a controlling terminal</a></li>
        
    
        <li class="main "><a href="#tcgetpgrp-tcsetpgrp-and-tcgetsid-functions">tcgetpgrp, tcsetpgrp, and tcgetsid Functions</a></li>
        
    
        <li class="main "><a href="#job-control">Job Control</a></li>
        
            <li><a href="#korn-shell-example">Korn shell example</a></li>
        
    
        <li class="main "><a href="#shell-execution-of-programs">Shell Execution of Programs</a></li>
        
            <li><a href="#the-shell-without-job-control-the-bourne-shell-on-solaris">The shell without job control: the Bourne shell on Solaris</a></li>
        
            <li><a href="#the-shell-with-job-control-bourne-again-shell-on-linux">The shell with job control: Bourne-again shell on Linux</a></li>
        
    
        <li class="main "><a href="#orphaned-process-groups">Orphaned Process Groups</a></li>
        
            <li><a href="#example-of-a-process-whose-child-is-stopped">Example of a process whose child is stopped</a></li>
        
    
        <li class="main "><a href="#freebsd-implementation">FreeBSD Implementation</a></li>
        
    
        <li class="main "><a href="#summary">Summary</a></li>
        
    
        <li class="main "><a href="#doubts-and-solutions">Doubts and Solutions</a></li>
        
            <li><a href="#verbatim">Verbatim</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">
              

<h3 id="chapter-9-process-relationships"><strong>Chapter 9. Process Relationships</strong><a class="headerlink" href="#chapter-9-process-relationships" title="Permanent link">&para;</a></h3>
<h3 id="introduction">Introduction<a class="headerlink" href="#introduction" title="Permanent link">&para;</a></h3>
<p>Every process has a parent process (the initial kernel-level process is usually its own parent). The parent is notified when the child terminates, and the parent can obtain the child’s exit status.</p>
<p>This chapter details process groups and the concept of session introduced by POSIX.1, as well as relationship between the login shell that is invoked when a user logs in and all the processes that are started from the login shell.</p>
<p>The concept of UNIX system signal mechanism in <a href="../ch10/">Chapter 10</a> is needed.</p>
<h3 id="terminal-logins">Terminal Logins<a class="headerlink" href="#terminal-logins" title="Permanent link">&para;</a></h3>
<p>In early UNIX systems, the terminals (dumb terminals that are hard-wired connected to the host) were either local (directly connected) or remote (connected through a modem). These logins came through a terminal device driver in the kernel. [p285]</p>
<p>As bitmapped graphical terminals became available, windowing systems were developed to provide users with new ways to interact with host computers.  Applications were developed to create "terminal windows" to emulate character-based terminals, allowing users to interact with hosts in familiar ways (i.e., via the shell command line).</p>
<p>Today, some platforms allow you to start a windowing system after logging in, whereas other platforms automatically start the windowing system for you. In the latter case, you might still have to log in, depending on how the windowing system is configured (some windowing systems can be configured to log you in automatically).</p>
<p>The procedure that we now describe is used to log in to a UNIX system using a terminal. The procedure is similar regardless of the type of terminal we use. It could be a:</p>
<ul>
<li>character-based terminal,</li>
<li>a graphical terminal emulating a simple character-based terminal,</li>
<li>or a graphical terminal running a windowing system.</li>
</ul>
<h4 id="bsd-terminal-logins">BSD Terminal Logins<a class="headerlink" href="#bsd-terminal-logins" title="Permanent link">&para;</a></h4>
<p>The file <code>/etc/ttys</code> (created by the system administrator) has one line per terminal device. Each line specifies the name of the device and other parameters (e.g. baud rate) that are passed to the <code>getty</code> program.</p>
<p>After the system is bootstrapped, the kernel creates the <code>init</code> process (PID 1) which brings the system up in multiuser mode. The <code>init</code> process reads the file <code>/etc/ttys</code> and, for every terminal device that allows a login, does a <code>fork</code> followed by an <code>exec</code> of the program <code>getty</code>.</p>
<p><a href="../figure_9.2.png" title="Figure 9.2 State of processes after login has been invoked"><img alt="Figure 9.2 State of processes after login has been invoked" src="../figure_9.2.png" /></a></p>
<p>All the processes shown in the figure above have a real user ID of 0 and an effective user ID of 0 (they all have superuser privileges). All the processes other than the original <code>init</code> process have a parent process ID of 1.</p>
<ul>
<li>The <code>init</code> process <code>exec</code>s the <code>getty</code> program with an empty environment.</li>
<li><code>getty</code> calls <code>open</code> to open terminal device for reading and writing. File descriptors 0, 1, and 2 are set to the device.</li>
<li>Then, <code>getty</code> outputs something like <code>login:</code> and waits for us to enter our user name. <code>getty</code> can detect special characters to change the terminal's speed (baud rate). [p287]</li>
<li>
<p>When we enter our user name, <code>getty</code>’s job is complete, and it then invokes the <code>login</code> program, similar to:</p>
<div class="codehilite"><pre>execle(&quot;/bin/login&quot;, &quot;login&quot;, &quot;-p&quot;, username, (char *)0, envp);
</pre></div>


</li>
<li>
<p>Though <code>init</code> invokes <code>getty</code> with an empty environment, <code>getty</code> creates an environment for <code>login</code> (the <code>envp</code> argument) with the name of the terminal (something like <code>TERM=foo</code>, where the type of terminal <code>foo</code> is taken from the <code>gettytab</code> file) and any environment strings that are specified in the <code>gettytab</code>. The <code>-p</code> flag to <code>login</code> tells it to preserve the environment that it is passed and to add to that environment, not replace it.</p>
</li>
<li><code>login</code> does the following things:<ul>
<li>It calls <code>getpwnam</code> to fetch our password file entry.</li>
<li>It calls <code>getpass(3)</code> to display the prompt <code>Password:</code> and read our password (with echoing disabled).</li>
<li>It calls <code>crypt(3)</code> to encrypt the password that we entered and compares the encrypted result to the <code>pw_passwd</code> field from our shadow password file entry.</li>
<li>If the login attempt fails because of an invalid password (after a few tries), <code>login</code> calls <code>exit</code> with an argument of 1. This termination will be noticed by the parent (<code>init</code>), and it will do another <code>fork</code> followed by an <code>exec</code> of <code>getty</code>, starting the procedure over again for this terminal.</li>
</ul>
</li>
</ul>
<p>This is the traditional authentication procedure used on UNIX systems. Modern UNIX systems have evolved to support multiple authentication procedures. FreeBSD, Linux, Mac OS X, and Solaris all support a more flexible scheme known as PAM (<a href="https://en.wikipedia.org/wiki/Pluggable_authentication_module">Pluggable Authentication Modules</a>). PAM allows an administrator to configure the authentication methods to be used to access services that are written to use the PAM library. [p288]</p>
<p>If we log in correctly, <code>login</code> will:</p>
<ul>
<li>Change to our home directory (<code>chdir</code>)</li>
<li>Change the ownership of our terminal device (<code>chown</code>) so we own it</li>
<li>Change the access permissions for our terminal device so we have permission to read from and write to it</li>
<li>Set our group IDs by calling <code>setgid</code> and <code>initgroups</code></li>
<li>Initialize the environment with all the information that login has:<ul>
<li>our home directory (<code>HOME</code>),</li>
<li>shell (<code>SHELL</code>),</li>
<li>user name (<code>USER</code> and <code>LOGNAME</code>),</li>
<li>and a default path (<code>PATH</code>).</li>
</ul>
</li>
<li>
<p>Change to our user ID (<code>setuid</code>) and invoke our login shell, as in</p>
<div class="codehilite"><pre>execl(&quot;/bin/sh&quot;, &quot;-sh&quot;, (char *)0);
</pre></div>


<p>The minus sign as the first character of <code>argv[0]</code> is a flag to all the shells that indicates they are being invoked as a <strong>login shell</strong>. The shells can look at this character and modify their start-up accordingly.</p>
</li>
</ul>
<p>The <code>login</code> can optionally print the <a href="https://en.wikipedia.org/wiki/Motd_(Unix)">message-of-the-day</a> file, check for new mail, and performs other tasks.</p>
<p>Since it is called by a superuser process, <code>setuid</code> changes all three user IDs: the real user ID, effective user ID, and saved set-user-ID. The call to <code>setgid</code> that was done earlier by <code>login</code> has the same effect on all three group IDs.</p>
<p>At this point, our login shell is running. Its parent process ID is the original <code>init</code> process (process ID 1), so when our login shell terminates, <code>init</code> is sent a <code>SIGCHLD</code> signal and it starts the whole procedure over again for this terminal. File descriptors 0, 1, and 2 for our login shell are set to the terminal device. See the figure below:</p>
<p><a href="../figure_9.3.png" title="Figure 9.3 Arrangement of processes after everything is set for a terminal login"><img alt="Figure 9.3 Arrangement of processes after everything is set for a terminal login" src="../figure_9.3.png" /></a></p>
<p>Our login shell now reads its start-up files (<code>.profile</code> for the Bourne shell and Korn shell; <code>.bash_profile</code>, <code>.bash_login</code>, or <code>.profile</code> for the GNU Bourne-again shell; and <code>.cshrc</code> and <code>.login</code> for the C shell). These start-up files usually change some of the environment variables and add many other variables to the environment. For example, most users set their own <code>PATH</code> and often prompt for the actual terminal type (<code>TERM</code>). When the start-up files are done, we finally get the shell’s prompt and can enter commands.</p>
<h4 id="mac-os-x-terminal-logins">Mac OS X Terminal Logins<a class="headerlink" href="#mac-os-x-terminal-logins" title="Permanent link">&para;</a></h4>
<p>On Mac OS X, the terminal login process follows essentially the same steps as in the BSD login process (since Mac OS X is based in part on FreeBSD) with the following differences:</p>
<ul>
<li>The work of <code>init</code> is performed by <code>launchd</code>.</li>
<li>We are presented with a graphical-based login screen from the start.</li>
</ul>
<h4 id="linux-terminal-logins">Linux Terminal Logins<a class="headerlink" href="#linux-terminal-logins" title="Permanent link">&para;</a></h4>
<p>The Linux login procedure is very similar to the BSD procedure. The login command is derived from 4.3BSD. The main difference is in terminal configuration.</p>
<p>Some Linux distributions ship with a version of the <code>init</code> program that uses administrative files patterned after System V’s <code>init</code> file formats. where <code>/etc/inittab</code> specifies the terminal devices for which <code>init</code> should start a <code>getty</code> process. Other Linux distributions, such as Ubuntu, ship with a version of init that is known as "<a href="https://en.wikipedia.org/wiki/Upstart">Upstart</a>". It uses configuration files named <code>*.conf</code> that are
stored in the <code>/etc/init</code> directory. For example, the specifications for running <code>getty</code> on <code>/dev/tty1</code> might be found in the file <code>/etc/init/tty1.conf</code>.</p>
<p>Depending on the version of <code>getty</code> in use, the terminal characteristics are specified either on the command line (as with <code>agetty</code>) or in the file <code>/etc/gettydefs</code> (as with <code>mgetty</code>).</p>
<h4 id="solaris-terminal-logins">Solaris Terminal Logins<a class="headerlink" href="#solaris-terminal-logins" title="Permanent link">&para;</a></h4>
<p>[p290]</p>
<h3 id="network-logins">Network Logins<a class="headerlink" href="#network-logins" title="Permanent link">&para;</a></h3>
<p>The main difference between a serial terminal login and a network login is that the connection between the terminal and the computer isn’t point-to-point. In this case, <code>login</code> is simply a service available, just like any other network service, such as FTP or SMTP.</p>
<p>With the terminal logins, <code>init</code> knows which terminal devices are enabled for logins and spawns a <code>getty</code> process for each device. In the case of network logins, however, all the logins come through the kernel’s network interface drivers (e.g., the Ethernet driver), and we don’t know ahead of time how many of these will occur. Instead of having a process waiting for each possible login, we now have to wait for a network connection request to arrive.</p>
<p>To allow the same software to process logins over both terminal logins and network logins, a software driver called a <strong>pseudo terminal</strong> (detailed in <a href="ch19.md">Chapter 19</a>) is used to emulate the behavior of a serial terminal and map terminal operations to network operations, and vice versa.</p>
<h4 id="bsd-network-logins">BSD Network Logins<a class="headerlink" href="#bsd-network-logins" title="Permanent link">&para;</a></h4>
<p>In BSD, the <code>inetd</code> process, sometimes called the <em>Internet superserver</em>, waits for most network connections.</p>
<p>As part of the system start-up, <code>init</code> invokes a shell that executes the shell script <code>/etc/rc</code>, which starts <code>inetd</code> along with other daemons. Once the shell script terminates, the parent process of <code>inetd</code> becomes <code>init</code>; <code>inetd</code> waits for TCP/IP connection requests to arrive at the host. When a connection request arrives for it to handle, <code>inetd</code> does a <code>fork</code> and <code>exec</code> of the appropriate program.</p>
<p>Assume a TCP connection request arrives for the TELNET server (a remote login application). The remote user initiates the login by starting the TELNET client:</p>
<div class="codehilite"><pre>telnet hostname
</pre></div>


<p>The client opens a TCP connection to <em>hostname</em> and the user who started the client program is now logged in to the server’s host. The figure below shows the sequence of processes involved in executing the TELNET server, called <code>telnetd</code>:</p>
<p><a href="../figure_9.4.png" title="Figure 9.4 Sequence of processes involved in executing TELNET server"><img alt="Figure 9.4 Sequence of processes involved in executing TELNET server" src="../figure_9.4.png" /></a></p>
<p>Then, <u>the <code>telnetd</code> process then opens a pseudo terminal device and splits into two processes using <code>fork</code>,</u> which do the following:</p>
<ul>
<li>The parent (<code>telnetd</code>) handles the communication across the network connection.</li>
<li>The child <code>exec</code>s the <code>login</code> program.</li>
<li>The parent and the child are connected through the pseudo terminal. Before doing the <code>exec</code>, the child sets up file descriptors 0, 1, and 2 to the pseudo terminal.</li>
<li>If we log in correctly, login performs the same steps described in <a href="#bsd-terminal-logins">Section 9.2</a>: it changes to our home directory and sets our group IDs, user ID, and our initial environment. Then <code>login</code> replaces itself with our login shell by calling <code>exec</code>.</li>
</ul>
<p><a href="../figure_9.5.png" title="Figure 9.5 Arrangement of processes after everything is set for a network login"><img alt="Figure 9.5 Arrangement of processes after everything is set for a network login" src="../figure_9.5.png" /></a></p>
<p>Whether we log in through a terminal (<a href="../figure_9.3.png">Figure 9.3</a>) or a network (<a href="../figure_9.5.png">Figure 9.5</a>), we have a login shell with its standard input, standard output, and standard error connected to either a terminal device or a pseudo terminal device.</p>
<p>In the coming sections, we'll see that the login shell is the start of a POSIX.1 session, and that the terminal or pseudo terminal is the controlling terminal for the session.</p>
<h4 id="mac-os-x-network-logins">Mac OS X Network Logins<a class="headerlink" href="#mac-os-x-network-logins" title="Permanent link">&para;</a></h4>
<p>The network login on Mac OS X is identical to that on BSD, except that the <code>telnet</code> daemon is run from <code>launchd</code>. By default, the <code>telnet</code> daemon is disabled on Mac OS X (although it can be enabled with the <code>launchctl(1)</code> command). The preferred way to perform a network login on Mac OS X is with <code>ssh</code>, the secure shell command.</p>
<h4 id="linux-network-logins">Linux Network Logins<a class="headerlink" href="#linux-network-logins" title="Permanent link">&para;</a></h4>
<p>Network logins under Linux are the same as under BSD, except that some distributions use an alternative <code>inetd</code> process called the extended Internet services daemon, <code>xinetd</code>. The <code>xinetd</code> process provides a finer level of control over services it starts compared to <code>inetd</code>.</p>
<h4 id="solaris-network-logins">Solaris Network Logins<a class="headerlink" href="#solaris-network-logins" title="Permanent link">&para;</a></h4>
<p>[p293]</p>
<h3 id="process-groups">Process Groups<a class="headerlink" href="#process-groups" title="Permanent link">&para;</a></h3>
<p>In addition to having a process ID, each process belongs to a <strong>process group</strong>.</p>
<ul>
<li>A process group is a collection of one or more processes (usually associated with the same job) that can receive signals from the same terminal.</li>
<li>Each process group has a unique process group ID. Process group IDs are similar to process IDs: they are positive integers and can be stored in a <code>pid_t</code> data type.</li>
</ul>
<p>The function <code>getpgrp</code> returns the process group ID of the calling process. The <code>getpgid</code> function took a <em>pid</em> argument and returned the process group for that process.</p>
<p><small><a href="https://gist.github.com/shichao-an/08bcc3cf9a23ca95c00a">apue_getpgrp.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>

<span class="kt">pid_t</span> <span class="nf">getpgrp</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cm">/* Returns: process group ID of calling process */</span>

<span class="kt">pid_t</span> <span class="nf">getpgid</span><span class="p">(</span><span class="kt">pid_t</span> <span class="n">pid</span><span class="p">);</span>
<span class="cm">/* Returns: process group ID if OK, −1 on error */</span>
</pre></div>


<p>For <code>getpgid</code>, if <em>pid</em> is 0, the process group ID of the calling process is returned. Thus,</p>
<div class="codehilite"><pre><span class="n">getpgid</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</pre></div>


<p>is equivalent to:</p>
<div class="codehilite"><pre><span class="n">getpgrp</span><span class="p">();</span>
</pre></div>


<p>Each process group can have a <strong>process group leader</strong>, whose process group ID equals to its process ID.</p>
<h4 id="process-group-lifetime">Process group lifetime<a class="headerlink" href="#process-group-lifetime" title="Permanent link">&para;</a></h4>
<p>The process group life time is the period of time that begins when the group is created and ends when the last remaining process leaves the group. It is possible for a process group leader to create a process group, create processes in the group, and then terminate. The process group still exists, as long as at least one process is in the group, regardless of whether the group leader terminates. The last remaining process in the process group can either terminate or enter some other process group.</p>
<h4 id="setpgid-function"><code>setpgid</code> function<a class="headerlink" href="#setpgid-function" title="Permanent link">&para;</a></h4>
<p>A process can join an existing process group or creates a new process group by calling <code>setpgid</code>.</p>
<p><small><a href="https://gist.github.com/shichao-an/0b1832544be00d3a9490">apue_setpgid.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">setpgid</span><span class="p">(</span><span class="kt">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">pid_t</span> <span class="n">pgid</span><span class="p">);</span>

<span class="cm">/* Returns: 0 if OK, −1 on error */</span>
</pre></div>


<p>The <code>setpgid</code> function sets the process group ID of the process whose process ID equals <em>pid</em> to <em>pgid</em>.</p>
<p>Arguments:</p>
<ul>
<li>If <em>pid</em> == <em>pgid</em>, the process specified by <em>pid</em> becomes a process group leader.</li>
<li>If <em>pid</em> == 0, the process ID of the caller is used.</li>
<li>If <em>pgid</em> == 0, then the specified <em>pid</em> is used as the process group ID.</li>
</ul>
<p>Rules:</p>
<ul>
<li>A process can set the process group ID of only itself or any of its children.</li>
<li>A process cannot change the process group ID of one of its children after that child has called one of the <code>exec</code> functions.</li>
</ul>
<h5 id="job-control-shells">Job-control shells<a class="headerlink" href="#job-control-shells" title="Permanent link">&para;</a></h5>
<p>In most job-control shells, this function is called after a <code>fork</code> to have the parent set the process group ID of the child, and to have the child set its own process group ID. <u>One of these calls is redundant, but by doing both, we are guaranteed that the child is placed into its own process group before either process assumes that this has happened.  If we didn’t do this, we would have a race condition, since the child’s process group membership would depend on which process executes first.</u> (See <a href="##doubts-and-solutions">Doubts and Solutions</a> for details) [p294]</p>
<h5 id="process-groups-and-signals">Process groups and signals<a class="headerlink" href="#process-groups-and-signals" title="Permanent link">&para;</a></h5>
<p>We can send a signal to either a single process (identified by its process ID) or a process group (identified by its process group ID). Similarly, the <code>waitpid</code> function lets us wait for either a single process or one process from a specified process group.</p>
<h3 id="sessions">Sessions<a class="headerlink" href="#sessions" title="Permanent link">&para;</a></h3>
<p>A <strong>session</strong> is a collection of one or more process groups.</p>
<p><a href="../figure_9.6.png" title="Figure 9.6 Arrangement of processes into process groups and sessions"><img alt="Figure 9.6 Arrangement of processes into process groups and sessions" src="../figure_9.6_600.png" /></a></p>
<p>The processes in a process group are usually placed there by a shell pipeline. The arrangement in the figure above is generated by the shell commands of the form:</p>
<div class="codehilite"><pre>proc1 <span class="p">|</span> proc2 <span class="p">&amp;</span>
proc3 <span class="p">|</span> proc4 <span class="p">|</span> proc5
</pre></div>


<h4 id="the-setsid-function">The <code>setsid</code> function<a class="headerlink" href="#the-setsid-function" title="Permanent link">&para;</a></h4>
<p>A process establishes a new session by calling the <code>setsid</code> function.</p>
<p><small><a href="https://gist.github.com/shichao-an/48edc52023515e0df704">apue_setsid.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>

<span class="kt">pid_t</span> <span class="nf">setsid</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Returns: process group ID if OK, −1 on error */</span>
</pre></div>


<p>If the calling process is not a process group leader, this function creates a new session. Three things happen:</p>
<ol>
<li>The process becomes the <strong>session leader</strong> of this new session. (A session leader is the process that creates a session.) The process is the only process in this new session</li>
<li>The process becomes the process group leader of a new process group. The new process group ID is the process ID of the calling process.</li>
<li>The process has no controlling terminal. If the process had a controlling terminal before calling <code>setsid</code>, that association is broken.</li>
</ol>
<p><u>This function returns an error if the caller is already a process group leader.</u></p>
<h4 id="ensuring-the-successful-call-of-setsid">Ensuring the successful call of <code>setsid</code><a class="headerlink" href="#ensuring-the-successful-call-of-setsid" title="Permanent link">&para;</a></h4>
<p>Since the <code>setsid</code> function returns an error if the caller is a process group leader, to ensure this is not the case, the usual practice is to call <code>fork</code> and have the parent terminate and the child continue. It is guaranteed that the child is not a process group leader, because the process group ID of the parent is inherited by the child, but the child gets a new process ID. Hence, it is impossible for the child’s process ID to equal its inherited process group ID.</p>
<h4 id="session-leader-and-session-id">Session Leader and Session ID<a class="headerlink" href="#session-leader-and-session-id" title="Permanent link">&para;</a></h4>
<p>The Single UNIX Specification talks only about a "session leader"; there is no "session ID" similar to a process ID or a process group ID. A session leader is a single process that has a unique process ID, so we could talk about a session ID that is the process ID of the session leader. This concept of a session ID was introduced in SVR4.</p>
<h4 id="the-getsid-function">The <code>getsid</code> function<a class="headerlink" href="#the-getsid-function" title="Permanent link">&para;</a></h4>
<p>The <code>getsid</code> function returns the process group ID of a process’s session leader.</p>
<p><small><a href="https://gist.github.com/shichao-an/745eaee552865545e529">apue_getsid.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>

<span class="kt">pid_t</span> <span class="nf">getsid</span><span class="p">(</span><span class="kt">pid_t</span> <span class="n">pid</span><span class="p">);</span>

<span class="cm">/* Returns: session leader’s process group ID if OK, −1 on error */</span>
</pre></div>


<p>If <em>pid</em> is 0, <code>getsid</code> returns the process group ID of the calling process’s session leader. For security reasons, some implementations may restrict the calling process from obtaining the process group ID of the session leader if <em>pid</em> doesn’t belong to the same session as the caller.</p>
<h3 id="controlling-terminal">Controlling Terminal<a class="headerlink" href="#controlling-terminal" title="Permanent link">&para;</a></h3>
<p>Sessions and process groups have a few other characteristics.</p>
<ul>
<li>A session can have a single <strong>controlling terminal</strong>. This is usually the terminal device (in the case of a <a href="##terminal-logins">terminal login</a>) or pseudo terminal device (in the case of a <a href="#network-logins">network login</a>) on which we log in.</li>
<li>The session leader that establishes the connection to the controlling terminal is called the <strong>controlling process</strong>.</li>
<li>The process groups within a session can be divided into a single <strong>foreground process group</strong> and one or more <strong>background process groups</strong>.</li>
<li>If a session has a controlling terminal, it has a single foreground process group and all other process groups in the session are background process groups.</li>
<li>Whenever we press the terminal’s interrupt key (often DELETE or Control-C), the interrupt signal is sent to all processes in the foreground process group.</li>
<li>Whenever we press the terminal’s quit key (often Control-backslash), the quit signal is sent to all processes in the foreground process group.</li>
<li>If a modem (or network) disconnect is detected by the terminal interface, the hang-up signal is sent to the controlling process (the session leader).</li>
</ul>
<p>These characteristics are shown in the figure below:</p>
<p><a href="../figure_9.7.png" title="Figure 9.7 Process groups and sessions showing controlling terminal"><img alt="Figure 9.7 Process groups and sessions showing controlling terminal" src="../figure_9.7_600.png" /></a></p>
<p>Usually, the controlling terminal is established automatically when we log in.</p>
<h4 id="mechanisms-of-allocating-a-controlling-terminal">Mechanisms of allocating a controlling terminal<a class="headerlink" href="#mechanisms-of-allocating-a-controlling-terminal" title="Permanent link">&para;</a></h4>
<h5 id="system-v">System V<a class="headerlink" href="#system-v" title="Permanent link">&para;</a></h5>
<p>Systems derived from UNIX System V allocate the controlling terminal for a session when the session leader opens the first terminal device that is not already associated with a session, as long as the call to <code>open</code> does not specify the <code>O_NOCTTY</code> flag.</p>
<h5 id="bsd">BSD<a class="headerlink" href="#bsd" title="Permanent link">&para;</a></h5>
<p>BSD-based systems allocate the controlling terminal for a session when the session leader calls <code>ioctl</code> with a request argument of <code>TIOCSCTTY</code> (the third argument is a null pointer). The session cannot already have a controlling terminal for this call to succeed. Normally, this call to <code>ioctl</code> follows a call to <code>setsid</code>, which guarantees that the process is a session leader without a controlling terminal.</p>
<p>Note that although Mac OS X 10.6.8 is derived from BSD, it behaves like System V when allocating a controlling terminal.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>FreeBSD 8.0</th>
<th>Linux 3.2.0</th>
<th>Mac OS X 10.6.8</th>
<th>Solaris 10</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>open</code> without <code>O_NOCTTY</code></td>
<td></td>
<td>x</td>
<td>x</td>
<td>x</td>
</tr>
<tr>
<td><code>TIOCSCTTY</code> <code>ioctl</code> command</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
</tr>
</tbody>
</table>
<p>When a program wants to talk to the controlling terminal, regardless of whether the standard input or standard output is redirected, it can <code>open</code> the file <code>/dev/tty</code>. This special file is a synonym within the kernel for the controlling terminal. If the program doesn’t have a controlling terminal, the <code>open</code> of this device will fail.</p>
<h5 id="the-crypt-command-and-getpass-function">The <code>crypt</code> command and <code>getpass</code> function<a class="headerlink" href="#the-crypt-command-and-getpass-function" title="Permanent link">&para;</a></h5>
<p>The classic example is the <code>getpass(3)</code> function, which reads a password (with terminal echoing turned off, of course). [p298]</p>
<p>The <code>getpass</code> function is called by the <code>crypt(1)</code> program and can be used in a pipeline. For example:</p>
<div class="codehilite"><pre>crypt &lt; salaries <span class="p">|</span> lpr
</pre></div>


<p>It decrypts the file salaries and pipes the output to the print spooler. Because <code>crypt</code> reads its input file on its standard input, the standard input can’t be used to enter the password. Also, <code>crypt</code> is designed so that we have to enter the encryption password each time we run the program, to prevent us from saving the password in a file (which could be a security hole).</p>
<h3 id="tcgetpgrp-tcsetpgrp-and-tcgetsid-functions"><code>tcgetpgrp</code>, <code>tcsetpgrp</code>, and <code>tcgetsid</code> Functions<a class="headerlink" href="#tcgetpgrp-tcsetpgrp-and-tcgetsid-functions" title="Permanent link">&para;</a></h3>
<p>We need a way to tell the kernel which process group is the foreground process group, so that the terminal device driver knows where to send the terminal input and the terminal-generated signals. (<a href="../figure_9.7.png">Figure 9.7</a>)</p>
<p><small><a href="https://gist.github.com/shichao-an/93937e8a69a6f2971055">apue_tcgetpgrp.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>

<span class="kt">pid_t</span> <span class="nf">tcgetpgrp</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">);</span>
<span class="cm">/* Returns: process group ID of foreground process group if OK, −1 on error */</span>

<span class="kt">int</span> <span class="nf">tcsetpgrp</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">pid_t</span> <span class="n">pgrpid</span><span class="p">);</span>
<span class="cm">/* Returns: 0 if OK, −1 on error */</span>
</pre></div>


<ul>
<li>The function <code>tcgetpgrp</code> returns the process group ID of the foreground process group associated with the terminal open on <em>fd</em>.</li>
<li>If the process has a controlling terminal, the process can call <code>tcsetpgrp</code> to set the foreground process group ID to <em>pgrpid</em>. The value of <em>pgrpid</em> must be the process group ID of a process group in the same session, and <em>fd</em> must refer to the controlling terminal of the session.</li>
</ul>
<p>These two functions are normally called by job-control shells.</p>
<p>The <code>tcgetsid</code> function allows an application to obtain the process group ID for the session leader given a file descriptor for the controlling TTY.</p>
<p><small><a href="https://gist.github.com/shichao-an/16ba6f5516fc48ec7f84">apue_tcgetsid.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&lt;termios.h&gt;</span><span class="cp"></span>

<span class="kt">pid_t</span> <span class="nf">tcgetsid</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">);</span>

<span class="cm">/* Returns: session leader’s process group ID if OK, −1 on error */</span>
</pre></div>


<p>Applications that need to manage controlling terminals can use <code>tcgetsid</code> to identify the session ID of the controlling terminal’s session leader, which is equivalent to the session leader’s process group ID.</p>
<h3 id="job-control">Job Control<a class="headerlink" href="#job-control" title="Permanent link">&para;</a></h3>
<p><strong>Job control</strong> allows us to start multiple jobs (groups of processes) from a single terminal and to control which jobs can access the terminal and which jobs are run in the background. Job control requires three forms of support:</p>
<ol>
<li>A shell that supports job control</li>
<li>The terminal driver in the kernel must support job control</li>
<li>The kernel must support certain job-control signals</li>
</ol>
<p>From our perspective, when using job control from a shell, we can start a job in either the foreground or the background. A job is simply a collection of processes, often a pipeline of processes.</p>
<p>For example, start a job consisting of one process in the foreground:</p>
<div class="codehilite"><pre>vi main.c
</pre></div>


<p>Start two jobs in the background (all the processes invoked by these background jobs are in the background.):</p>
<div class="codehilite"><pre>pr *.c <span class="p">|</span> lpr <span class="p">&amp;</span>
make all <span class="p">&amp;</span>
</pre></div>


<h4 id="korn-shell-example">Korn shell example<a class="headerlink" href="#korn-shell-example" title="Permanent link">&para;</a></h4>
<p>When we start a background job, the shell assigns it a job identifier and prints one or more of the process IDs.</p>
<div class="codehilite"><pre><span class="gp">$</span> make all &gt; Make.out <span class="p">&amp;</span>
<span class="go">[1] 1475</span>
<span class="gp">$</span> pr *.c <span class="p">|</span> lpr <span class="p">&amp;</span>
<span class="go">[2] 1490</span>
<span class="gp">$</span>   <span class="c1"># just press RETURN</span>
<span class="go">[2] + Done pr *.c | lpr &amp;</span>
<span class="go">[1] + Done make all &gt; Make.out &amp;</span>
</pre></div>


<ul>
<li>The <code>make</code> is job number 1 and the starting process ID is 1475. The next pipeline is job number 2 and the process ID of the first process is 1490.</li>
<li>When the jobs are done and we press RETURN, the shell tells us that the jobs are complete. The reason we have to press RETURN is to have the shell print its prompt. The shell doesn’t print the changed status of background jobs at any random time (only after we press RETURN and right before it prints its prompt, to let us enter a new command line). If the shell didn’t do this, it could produce output while we were entering an input line.</li>
<li>The interaction with the terminal driver arises because a special terminal character affects the foreground job. The terminal driver looks for three special characters, which generate signals to (all processes in ) the foreground process group:<ul>
<li><code>SIGINT</code>: generated by the interrupt character (typically DELETE or Control-C).</li>
<li><code>SIGQUIT</code>: generated by the quit character (typically Control-backslash).</li>
<li><code>SIGTSTP</code>: generated by the suspend character (typically Control-Z).</li>
</ul>
</li>
</ul>
<p>While we can have a foreground job and one or more background jobs, only the foreground job receives terminal input (the characters that we enter at the terminal). It is not an error for a background job to try to read from the terminal, but the terminal driver detects this and sends a special signal to the background job: <code>SIGTTIN</code>. This signal normally stops the background job; by using the shell, we are notified of this event and can bring the job into the foreground so that it can read from the terminal.</p>
<div class="codehilite"><pre><span class="go">cat &gt; temp.foo &amp;   # start in background, but it’ll read from standard input</span>
<span class="go">[1] 1681</span>
<span class="gp">$</span>                  <span class="c1"># we press RETURN</span>
<span class="go">[1] + Stopped (SIGTTIN) cat &gt; temp.foo &amp;</span>
<span class="gp">$</span> <span class="nb">fg</span> %1            <span class="c1"># bring job number 1 into the foreground</span>
<span class="go">cat &gt; temp.foo     # the shell tells us which job is now in the foreground</span>
<span class="go">hello, world       # enter one line</span>
<span class="go">ˆD                 # type the end-of-file character</span>
<span class="gp">$</span> cat temp.foo     <span class="c1"># check that the one line was put into the file</span>
<span class="go">hello, world</span>
</pre></div>


<ul>
<li><code>SIGTTIN</code>: When the background <code>cat</code> tries to read its standard input (the controlling terminal), the terminal driver, knowing that it is a background job, sends the <code>SIGTTIN</code> signal to the background job.</li>
<li>The shell detects the change in status of its child (see <code>wait</code> and <code>waitpid</code> function in <a href="../ch8/#wait-and-waitpid-functions">Section 8.6</a>) and tells us that the job has been stopped.</li>
<li>The shell’s <code>fg</code> command move the stopped job into the foreground, which causes the shell to place the job into the foreground process group (tcsetpgrp) and send the continue signal (<code>SIGCONT</code>) to the process group.</li>
<li>Since it is now in the foreground process group, the job can read from the controlling terminal.</li>
</ul>
<p>Note that this example doesn’t work on Mac OS X 10.6.8. When we try to bring the cat command into the foreground, the read fails with errno set to EINTR. Since Mac OS X is based on FreeBSD, and FreeBSD works as expected, this must be a bug in Mac OS X.</p>
<p>There is an option that we can allow or disallow a background job to send its output to the controlling terminal. Normally, we use the <code>stty(1)</code> command to change this option.</p>
<div class="codehilite"><pre><span class="gp">$</span> cat temp.foo <span class="p">&amp;</span>   <span class="c1"># execute in background</span>
<span class="go">[1] 1719</span>
<span class="gp">$</span> hello, world     <span class="c1"># the output from the background job appears after the prompt</span>
<span class="go">we press RETURN</span>
<span class="go">[1] + Done cat temp.foo &amp;</span>
<span class="gp">$</span> stty tostop      <span class="c1"># disable ability of background jobs to output to controlling terminal</span>
<span class="gp">$</span> cat temp.foo <span class="p">&amp;</span>   <span class="c1"># try it again in the background</span>
<span class="go">[1] 1721</span>
<span class="gp">$</span>                  <span class="c1"># we press RETURN and find the job is stopped</span>
<span class="go">[1] + Stopped(SIGTTOU) cat temp.foo &amp;</span>
<span class="gp">$</span> <span class="nb">fg</span> %1            <span class="c1"># resume stopped job in the foreground</span>
<span class="go">cat temp.foo       # the shell tells us which job is now in the foreground</span>
<span class="go">hello, world       # and here is its output</span>
</pre></div>


<p>When we disallow background jobs from writing to the controlling terminal, cat will block when it tries to write to its standard output, because the terminal driver identifies the write as coming from a background process and sends the job the <code>SIGTTOU</code> signal. When we use the shell’s <code>fg</code> command to bring the job into the foreground, the job completes.</p>
<p>The figure below summarizes some of the features of job control that have been described so far:</p>
<p><a href="../figure_9.9.png" title="Figure 9.9 Summary of job control features with foreground and background jobs, and terminal driver"><img alt="Figure 9.9 Summary of job control features with foreground and background jobs, and terminal driver" src="../figure_9.9_600.png" /></a></p>
<ul>
<li>The solid lines through the terminal driver box mean that the terminal I/O and the terminal-generated signals are always connected from the foreground process group to the actual terminal.</li>
<li>The dashed line corresponding to the <code>SIGTTOU</code> signal means that whether the output from a process in the background process group appears on the terminal is an option.</li>
</ul>
<p>Job control was originally designed and implemented before windowing terminals were widespread. It is a required feature of POSIX.1. [p302-303]</p>
<h3 id="shell-execution-of-programs">Shell Execution of Programs<a class="headerlink" href="#shell-execution-of-programs" title="Permanent link">&para;</a></h3>
<p>This section examines how the shells execute programs and how this relates to the concepts of process groups, controlling terminals, and sessions</p>
<h4 id="the-shell-without-job-control-the-bourne-shell-on-solaris">The shell without job control: the Bourne shell on Solaris<a class="headerlink" href="#the-shell-without-job-control-the-bourne-shell-on-solaris" title="Permanent link">&para;</a></h4>
<p>For example, with the classic Bourne shell running on Solaris, we execute:</p>
<div class="codehilite"><pre>ps -o pid,ppid,pgid,sid,comm
</pre></div>


<p>The output is</p>
<div class="codehilite"><pre>  PID  PPID  PGID  SID COMMAND
  949   947   949  949 sh
 1774   949   949  949 ps
</pre></div>


<ul>
<li>The parent of the <code>ps</code> command is the shell.</li>
<li>Both the shell and the <code>ps</code> command are in the same session and foreground process group (949), <u>because that is what you get when you execute a command with a shell that doesn’t support job control.</u></li>
</ul>
<h5 id="terminal-process-group-id-tpgid-option-of-the-ps1-command">Terminal process group ID: <code>tpgid</code> option of the <code>ps(1)</code> command<a class="headerlink" href="#terminal-process-group-id-tpgid-option-of-the-ps1-command" title="Permanent link">&para;</a></h5>
<p>[p303]</p>
<p>Some platforms support an <code>tpgid</code> option to have the <code>ps(1)</code> command print the process group ID associated with the session’s controlling terminal. This value would be shown under the TPGID column:</p>
<div class="codehilite"><pre>ps -o pid,ppid,pgid,sid,tpgid,comm
</pre></div>


<p>Note that it is misleading to associate a process with a terminal process group ID (the TPGID column):</p>
<ul>
<li>A process does not have a terminal process control group. A process belongs to a process group, and the process group belongs to a session.</li>
<li>The session may or may not have a controlling terminal.<ul>
<li>If the session does have a controlling terminal, then the terminal device knows the process group ID of the foreground process. This value can be set in the terminal driver with the <code>tcsetpgrp</code> function (<a href="../figure_9.9.png">Figure 9.9</a>).</li>
</ul>
</li>
<li>The foreground process group ID is an attribute of the terminal, not the process. This value from the terminal device driver is what <code>ps</code> prints as the TPGID. If it finds that the session doesn’t have a controlling terminal, <code>ps</code> prints either 0 or −1, depending on the platform.</li>
</ul>
<p>If we execute the command in the background:</p>
<div class="codehilite"><pre>ps -o pid,ppid,pgid,sid,comm <span class="p">&amp;</span>
</pre></div>


<p>The only value that changes is the process ID of the command:</p>
<div class="codehilite"><pre>  PID  PPID  PGID  SID COMMAND
  949   947   949  949 sh
 1812   949   949  949 ps
</pre></div>


<p>This shell doesn’t know about job control, so the background job is not put into its own process group and the controlling terminal isn’t taken away from the background job.</p>
<p>To see how this shell handles a pipeline, we execute:</p>
<div class="codehilite"><pre>ps -o pid,ppid,pgid,sid,comm <span class="p">|</span> cat1
</pre></div>


<p>The output is:</p>
<div class="codehilite"><pre>  PID  PPID  PGID  SID COMMAND
  949   947   949  949 sh
 1823   949   949  949 cat1
 1824  1823   949  949 ps
</pre></div>


<p>The program <code>cat1</code> is just a copy of the standard <code>cat</code> program, with a different name. The last process in the pipeline (<code>cat</code>) is the child of the shell and that the first process in the pipeline (<code>ps</code>) is a child of the last process. It appears that <u>the shell <code>fork</code>s a copy of itself and that this copy then forks to make each of the previous processes in the pipeline.</u></p>
<p>If we execute the pipeline in the background:</p>
<div class="codehilite"><pre>ps -o pid,ppid,pgid,sid,comm <span class="p">|</span> cat1 <span class="p">&amp;</span>
</pre></div>


<p>Only the process IDs change. Since the shell doesn’t handle job control, the process group ID of the background processes remains 949, as does the process group ID of the session</p>
<p>If a background process tries to read from its controlling terminal, like:</p>
<div class="codehilite"><pre>cat &gt; temp.foo <span class="p">&amp;</span>
</pre></div>


<p>Without job control, the shell automatically redirects the standard input of a background process to <code>/dev/null</code>, if the process doesn’t redirect standard input itself. A read from <code>/dev/null</code> generates an end of file. This means that our background <code>cat</code> process immediately reads an end of file and terminates normally.</p>
<p>The previous paragraph adequately handles the case of a background process accessing the controlling terminal through its standard input, but what happens if a background process specifically opens <code>/dev/tty</code> and reads from the controlling terminal? The answer is "It depends", but the result is probably not what we want. For example:</p>
<div class="codehilite"><pre>crypt &lt; salaries <span class="p">|</span> lpr <span class="p">&amp;</span>
</pre></div>


<p>This pipeline is run in the background, but the <code>crypt</code> program opens <code>/dev/tty</code>, changes the terminal characteristics (to disable echoing), reads from the device, and resets the terminal characteristics. The prompt <code>Password:</code> from <code>crypt</code> is printed on the terminal, but what we enter (the encryption password) is read by the shell, which tries to execute a command of that name. The next line we enter to the shell is taken as the password, and the file is not encrypted correctly, sending junk to the printer. Here we have two processes trying to read from the same device at the same time, and the result depends on the system. Job control, as described earlier, handles this multiplexing of a single terminal between multiple processes in a better fashion. [p304]</p>
<p>If we execute three processes in the pipeline, we can examine the process control used by this shell:</p>
<div class="codehilite"><pre>ps -o pid,ppid,pgid,sid,comm <span class="p">|</span> cat1 <span class="p">|</span> cat2
</pre></div>


<p>The output is: [p305]</p>
<div class="codehilite"><pre>  PID  PPID  PGID  SID COMMAND
  949   947   949  949 sh
 1988   949   949  949 cat2
 1989  1988   949  949 ps
 1990  1988   949  949 cat1
</pre></div>


<p>Again, the last process in the pipeline is the child of the shell, and all previous processes in the pipeline are children of the last process. See the figure below:</p>
<p><a href="../figure_9.10.png" title="Figure 9.10 Processes in the pipeline ps | cat1 | cat2 when invoked by Bourne shell"><img alt="Figure 9.10 Processes in the pipeline ps | cat1 | cat2 when invoked by Bourne shell" src="../figure_9.10.png" /></a></p>
<p>Since the last process in the pipeline is the child of the login shell, the shell is notified when that process (<code>cat2</code>) terminates.</p>
<h4 id="the-shell-with-job-control-bourne-again-shell-on-linux">The shell with job control: Bourne-again shell on Linux<a class="headerlink" href="#the-shell-with-job-control-bourne-again-shell-on-linux" title="Permanent link">&para;</a></h4>
<p>Starting with this example, foreground process group are shown in <strong><code>bolder font</code></strong>.</p>
<p>The command:</p>
<div class="codehilite"><pre>ps -o pid,ppid,pgid,sid,tpgid,comm
</pre></div>


<p>gives us:</p>
<pre>
   PID   PPID   PGID   SID  TPGID  COMMAND
  2837   2818   2837  2837   5796  bash
  <b>5796</b>   2837   <b>5796</b>  2837   5796  ps
</pre>

<p>We can see the result, which is different from the Bourne shell example:</p>
<ul>
<li>The Bourne-again shell places the foreground job (<code>ps</code>) into its own process group (5796).</li>
<li>The <code>ps</code> command is the process group leader and the only process in this process group. This process group is the foreground process group, since it has the controlling terminal.</li>
<li>The login shell is a background process group while the <code>ps</code> command executes.</li>
<li>Both process groups, 2837 and 5796, are members of the same session.</li>
</ul>
<p>Executing this process in the background:</p>
<div class="codehilite"><pre>ps -o pid,ppid,pgid,sid,tpgid,comm <span class="p">&amp;</span>
</pre></div>


<p>gives us:</p>
<pre>
   PID   PPID   PGID   SID  TPGID  COMMAND
  <b>2837</b>   2818   <b>2837</b>  2837   2837  bash
  5797   2837   5797  2837   2837  ps
</pre>

<ul>
<li><code>ps</code> command is again placed into its own process group.</li>
<li>The process group (5797) is no longer the foreground process group but a background process group.</li>
<li>The foreground process group is our login shell, as indicated by TPGID of 2837.</li>
</ul>
<p>Executing two processes in a pipeline, as in:</p>
<div class="codehilite"><pre>ps -o pid,ppid,pgid,sid,tpgid,comm <span class="p">|</span> cat1
</pre></div>


<p>gives us:</p>
<pre>
   PID   PPID   PGID   SID  TPGID  COMMAND
  2837   2818   2837  2837   5799  bash
  <b>5799</b>   2837   <b>5799</b>  2837   5799  ps
  <b>5800</b>   2837   <b>5799</b>  2837   5799  cat1
</pre>

<ul>
<li>Both processes, <code>ps</code> and <code>cat1</code>, are placed into a new process group (5799), which is the foreground process group.</li>
<li>The login shell is the parent of both processes. This is different from the Bourne shell, which created the last process (<code>cat1</code>) in the pipeline first, and this process is the parent of first process (<code>ps</code>).</li>
</ul>
<p>If we execute this pipeline in the background:</p>
<div class="codehilite"><pre>ps -o pid,ppid,pgid,sid,tpgid,comm <span class="p">|</span> cat1 <span class="p">&amp;</span>
</pre></div>


<p>The output:</p>
<pre>
   PID   PPID   PGID   SID  TPGID  COMMAND
  <b>2837</b>   2818   <b>2837</b>  2837   2837  bash
  5801   2837   5801  2837   2837  ps
  5802   2837   5801  2837   2837  cat1
</pre>

<p>The results are similar, but now <code>ps</code> and <code>cat1</code> are placed in the same background process group (5801).</p>
<p>[p307]</p>
<h3 id="orphaned-process-groups">Orphaned Process Groups<a class="headerlink" href="#orphaned-process-groups" title="Permanent link">&para;</a></h3>
<p>A process whose parent terminates is called an orphan and is inherited by the <code>init</code> process. The entire process groups that can be orphaned and this section discusses how POSIX.1 handles this situation.</p>
<h4 id="example-of-a-process-whose-child-is-stopped">Example of a process whose child is stopped<a class="headerlink" href="#example-of-a-process-whose-child-is-stopped" title="Permanent link">&para;</a></h4>
<p>The following figure shows a situation: the parent process has <code>fork</code>ed a child that stops, and the parent is about to exit.</p>
<p><a href="../figure_9.11.png" title="Figure 9.11 Example of a process group about to be orphaned"><img alt="Figure 9.11 Example of a process group about to be orphaned" src="../figure_9.11.png" /></a></p>
<p>The program that creates an orphaned process group is shown below:</p>
<ul>
<li><a href="">relation/orphan3.c</a></li>
</ul>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&quot;apue.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;errno.h&gt;</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sig_hup</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;SIGHUP received, pid = %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">getpid</span><span class="p">());</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">pr_ids</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s: pid = %ld, ppid = %ld, pgrp = %ld, tpgrp = %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
        <span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">getpid</span><span class="p">(),</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">getppid</span><span class="p">(),</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">getpgrp</span><span class="p">(),</span>
        <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">tcgetpgrp</span><span class="p">(</span><span class="n">STDIN_FILENO</span><span class="p">));</span>
    <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span>    <span class="n">c</span><span class="p">;</span>
    <span class="kt">pid_t</span>   <span class="n">pid</span><span class="p">;</span>

    <span class="n">pr_ids</span><span class="p">(</span><span class="s">&quot;parent&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;fork error&quot;</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>   <span class="cm">/* parent */</span>
        <span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>       <span class="cm">/* sleep to let child stop itself */</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>            <span class="cm">/* child */</span>
        <span class="n">pr_ids</span><span class="p">(</span><span class="s">&quot;child&quot;</span><span class="p">);</span>
        <span class="n">signal</span><span class="p">(</span><span class="n">SIGHUP</span><span class="p">,</span> <span class="n">sig_hup</span><span class="p">);</span>    <span class="cm">/* establish signal handler */</span>
        <span class="n">kill</span><span class="p">(</span><span class="n">getpid</span><span class="p">(),</span> <span class="n">SIGTSTP</span><span class="p">);</span>    <span class="cm">/* stop ourself */</span>
        <span class="n">pr_ids</span><span class="p">(</span><span class="s">&quot;child&quot;</span><span class="p">);</span>    <span class="cm">/* prints only if we&#39;re continued */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="n">STDIN_FILENO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">&quot;read error %d on controlling TTY</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">errno</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>Result in a job-control shell:</p>
<div class="codehilite"><pre><span class="gp">$</span> ./a.out
<span class="go">parent: pid = 6099, ppid = 2837, pgrp = 6099, tpgrp = 6099</span>
<span class="go">child: pid = 6100, ppid = 6099, pgrp = 6099, tpgrp = 6099</span>
<span class="gp">$</span> SIGHUP received, <span class="nv">pid</span> <span class="o">=</span> 6100
<span class="go">child: pid = 6100, ppid = 1, pgrp = 6099, tpgrp = 2837</span>
<span class="go">read error 5 on controlling TTY</span>
</pre></div>


<p>Analysis: [p307-309]</p>
<ul>
<li>The shell places the foreground process into its own process group (6099) and the shell itself stays in its own process group (2837). The child inherits the process group of its parent (6099).</li>
<li>After <code>fork</code>, the parent sleeps for 5 seconds. This is our (imperfect) way of letting the child execute before the parent terminates.</li>
<li>The child establishes a signal handler for the hang-up signal (<code>SIGHUP</code>) so we can see whether it is sent to the child. (signal handlers are discussed in <a href="../ch10/">Chapter 10</a>)</li>
<li>The child sends itself the stop signal (<code>SIGTSTP</code>) with the <code>kill</code> function. This stops the child, similar to our stopping a foreground job with our terminal’s suspend character (Control-Z).</li>
<li>When the parent terminates, the child is orphaned, so the child’s parent process ID becomes 1, which is the <code>init</code> process ID.</li>
<li>At this point, the child is a member of an <strong>orphaned process group</strong>:<ul>
<li>The POSIX.1 definition of an orphaned process group: one in which the parent of every member is either itself a member of the group or is not a member of the group’s session. Another way of saying this is: <u>the process group is not orphaned as long as a process in the group has a parent in a different process group but in the same session.</u></li>
<li>If the process group is not orphaned, there is a chance that one of those parents in a different process group but in the same session will restart a stopped process in the process group that is not orphaned. Here, the parent of every process in the group (e.g., process 1 is the parent of process 6100) belongs to another session.</li>
</ul>
</li>
<li>Since the process group is orphaned when the parent terminates, and the process group contains a stopped process, POSIX.1 requires that every process in the newly orphaned process group be sent the hang-up signal (<code>SIGHUP</code>) followed by the continue signal (<code>SIGCONT</code>).<ul>
<li>This causes the child to be continued, after processing the hang-up signal. The default action for the hang-up signal is to terminate the process, so we have to provide a signal handler to catch the signal. We therefore expect the <code>printf</code> in the <code>sig_hup</code> function to appear before the <code>printf</code> in the <code>pr_ids</code> function.</li>
</ul>
</li>
<li>Note that the shell prompt appears with the output from the child, because two processes (login shell and the child) are writing to the terminal. The parent process ID of the child has become 1.</li>
<li>After calling <code>pr_ids</code> in the child, the program tries to read from standard input. POSIX.1 specifies that the <code>read</code> is to return an error with <code>errno</code> set to <code>EIO</code> (whose value is 5 on this system) in this situation. [p309]<ul>
<li>As discussed earlier in this chapter, when a process in a background process group tries to read from its controlling terminal, <code>SIGTTIN</code> is generated for the background process group. But for an orphaned process group, if the kernel were to stop it with this signal, the processes in the process group would probably never be continued.</li>
</ul>
</li>
<li>Finally, our child was placed in a background process group when the parent terminated, since the parent was executed as a foreground job by the shell.</li>
</ul>
<h3 id="freebsd-implementation">FreeBSD Implementation<a class="headerlink" href="#freebsd-implementation" title="Permanent link">&para;</a></h3>
<p>The figure below shows the FreeBSD implementation of sessions and process groups:</p>
<p><a href="../figure_9.13.png" title="Figure 9.13 FreeBSD implementation of sessions and process groups"><img alt="Figure 9.13 FreeBSD implementation of sessions and process groups" src="../figure_9.13_600.png" /></a></p>
<ul>
<li><code>session</code> structure is allocated for each session (each time <code>setsid</code> is called).<ul>
<li><code>s_count</code>: number of process groups in the session. When this counter is decremented to 0, the structure can be freed.</li>
<li><code>s_leader</code>: pointer to the proc structure of the session leader.</li>
<li><code>s_ttyvp</code>: pointer to the vnode structure of the controlling terminal.</li>
<li><code>s_ttyp</code>: pointer to the tty structure of the controlling terminal.</li>
<li><code>s_sid</code>: session ID. (Not part of the Single UNIX Specification)</li>
</ul>
</li>
</ul>
<p>When <code>setsid</code> is called, a new session structure is allocated within the kernel. <code>s_count</code> is set to 1, <code>s_leader</code> is set to point to the <code>proc</code> structure of the calling process, <code>s_sid</code> is set to the process ID, and <code>s_ttyvp</code> and <code>s_ttyp</code> are set to null pointers, since the new session doesn’t have a controlling terminal.</p>
<ul>
<li><code>tty</code> structure is contained in the kernel for each terminal device and each pseudo terminal device.<ul>
<li><code>t_session</code> points to the <code>session</code> structure that has this terminal as its controlling terminal. This pointer is used by the terminal to send a hangup signal to the session leader if the terminal loses carrier (<a href="../figure_9.7.png">Figure 9.7</a>). Note that the <code>tty</code> and <code>session</code> structure point to each other.</li>
<li><code>t_pgrp</code> points to the <code>pgrp</code> structure of the foreground process group. This field is used by the terminal driver to send signals to the foreground process group. The three signals generated by entering special characters that are sent to the foreground process group are:<ul>
<li>interrupt</li>
<li>quit</li>
<li>suspend</li>
</ul>
</li>
<li><code>t_termios</code> is a structure containing all the special characters and related information for this terminal, such as baud rate, whether echo is enabled, and so on.</li>
<li><code>t_winsize</code> is a <code>winsize</code> structure that contains the current size of the terminal window. When the size of the terminal window changes, the <code>SIGWINCH</code> signal is sent to the foreground process group.</li>
</ul>
</li>
</ul>
<p>The kernel finds the foreground process group of a particular session by following fields of pointers, starting with the <code>session</code> structure:</p>
<ul>
<li>Follow <code>s_ttyp</code> of the <code>session</code> structure to get to the <code>tty</code> structure (controlling terminal).</li>
<li>
<p>Follow <code>t_pgrp</code> of the <code>tty</code> structure to get to the <code>pgrp</code> structure (foreground process group).</p>
</li>
<li>
<p><code>pgrp</code> structure contains the information for a particular process group.</p>
<ul>
<li><code>pg_id</code> is the process group ID.</li>
<li><code>pg_session</code> points to the <code>session</code> structure for the session to which this process group belongs.</li>
<li><code>pg_members</code> is a pointer to the list of <code>proc</code> structures that are members of this process group. The <code>p_pglist</code> structure in that <code>proc</code> structure is a doubly linked list entry that points to both the next process and the previous process in the group. [p311]</li>
</ul>
</li>
<li><code>vnode</code> structureis allocated when the controlling terminal device is opened. All references to <code>/dev/tty</code> in a process go through this <code>vnode</code> structure.</li>
</ul>
<h3 id="summary">Summary<a class="headerlink" href="#summary" title="Permanent link">&para;</a></h3>
<p>This chapter describes relation between groups of processes, sessions, which are made up of process groups. Job control is a feature supported by most UNIX systems. The controlling terminal for a process, <code>/dev/tty</code>, is also involved in these process relationships.</p>
<h3 id="doubts-and-solutions">Doubts and Solutions<a class="headerlink" href="#doubts-and-solutions" title="Permanent link">&para;</a></h3>
<h4 id="verbatim">Verbatim<a class="headerlink" href="#verbatim" title="Permanent link">&para;</a></h4>
<p>p294 on <code>fork</code>'s race condition concerning <code>setpgid</code></p>
<blockquote>
<p>In most job-control shells, this function is called after a <code>fork</code> to have the parent set the process group ID of the child, and to have the child set its own process group ID. One of these calls is redundant, but by doing both, we are guaranteed that the child is placed into its own process group before either process assumes that this has happened.  If we didn’t do this, we would have a race condition, since the child’s process group membership would depend on which process executes first.</p>
</blockquote>
<p>Solution:</p>
<p>The shell (parent) wants and ensures the process to be in the right process group at any time before either of the child and parent continues execution.</p>
<ul>
<li><a href="http://stackoverflow.com/a/6026564/1751342">Stack Overflow</a></li>
<li><a href="http://www.gnu.org/software/libc/manual/html_node/Launching-Jobs.html#Launching-Jobs">Launching Jobs</a> in the GNU C Library</li>
</ul>
            </div>
        </div>

        <footer class="col-md-12">
            
        </footer>

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script>
        <script src="../../js/base.js"></script>
        <script src="../../custom.js"></script>
    </body>
</html>