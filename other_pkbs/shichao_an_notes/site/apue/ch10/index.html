<!DOCTYPE html>
<html lang="en">
    <head>
        <!-- Global Site Tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-59055167-2"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments)};
          gtag('js', new Date());

          gtag('config', 'UA-59055167-2');
        </script>

        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://notes.shichao.io/apue/ch10/">
        <link rel="shortcut icon" href="../../toki_32.png">
        

	<title>Chapter 10. Signals - Shichao's Notes</title>

        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../../css/base.css" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,400italic,500,600" rel="stylesheet">
        <link href="../../custom.css" rel="stylesheet">
        <link href="../../friendly.css" rel="stylesheet">
        <link href="../../theme.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        
<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../..">Shichao's Notes</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">APUE <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../ch1/">Chapter 1. UNIX System Overview</a>
                        </li>
                      
                        <li>
                            <a href="../ch2/">Chapter 2. UNIX Standardization and Implementations</a>
                        </li>
                      
                        <li>
                            <a href="../ch3/">Chapter 3. File I/O</a>
                        </li>
                      
                        <li>
                            <a href="../ch4/">Chapter 4. Files and Directories</a>
                        </li>
                      
                        <li>
                            <a href="../ch5/">Chapter 5. Standard I/O Library</a>
                        </li>
                      
                        <li>
                            <a href="../ch6/">Chapter 6. System Data Files and Information</a>
                        </li>
                      
                        <li>
                            <a href="../ch7/">Chapter 7. Process Environment</a>
                        </li>
                      
                        <li>
                            <a href="../ch8/">Chapter 8. Process Control</a>
                        </li>
                      
                        <li>
                            <a href="../ch9/">Chapter 9. Process Relationships</a>
                        </li>
                      
                        <li class="active">
                            <a href="./">Chapter 10. Signals</a>
                        </li>
                      
                        <li>
                            <a href="../ch11/">Chapter 11. Threads</a>
                        </li>
                      
                        <li>
                            <a href="../ch12/">Chapter 12. Thread Control</a>
                        </li>
                      
                        <li>
                            <a href="../ch13/">Chapter 13. Daemon Processes</a>
                        </li>
                      
                        <li>
                            <a href="../ch14/">Chapter 14. Advanced I/O</a>
                        </li>
                      
                        <li>
                            <a href="../ch15/">Chapter 15. Interprocess Communication</a>
                        </li>
                      
                        <li>
                            <a href="../ch16/">Chapter 16. Network IPC: Sockets</a>
                        </li>
                      
                        <li>
                            <a href="../ch17/">Chapter 17. Advanced IPC</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UNP <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../unp/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch2/">Chapter 2. The Transport Layer: TCP, UDP, and SCTP</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch3/">Chapter 3. Sockets Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch4/">Chapter 4. Elementary TCP Sockets</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch5/">Chapter 5. TCP Client/Server Example</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch6/">Chapter 6. I/O Multiplexing: The select and poll Functions</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch7/">Chapter 7. Socket Options</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch8/">Chapter 8. Elementary UDP Sockets</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">TCPv1 <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../tcpv1/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch2/">Chapter 2. The Internet Address Architecture</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch3/">Chapter 3. Link Layer</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch4/">Chapter 4. ARP: Address Resolution Protocol</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch5/">Chapter 5. The Internet Protocol (IP)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch6/">Chapter 6. System Configuration: DHCP and Autoconfiguration</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch7/">Chapter 7. Firewalls and Network Address Translation (NAT)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch8/">Chapter 8. ICMPv4 and ICMPv6: Internet Control Message Protocol</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch9/">Chapter 9. Broadcasting and Local Multicasting (IGMP and MLD)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch10/">Chapter 10. User Datagram Protocol (UDP) and IP Fragmentation</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch11/">Chapter 11. Name Resolution and the Domain Name System (DNS)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch12/">Chapter 12. TCP: The Transmission Control Protocol (Preliminaries)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch13/">Chapter 13. TCP Connection Management</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch14/">Chapter 14. TCP Timeout and Retransmission</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch15/">Chapter 15. TCP Data Flow and Window Management</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch16/">Chapter 16. TCP Congestion Control</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch17/">Chapter 17. TCP Keepalive</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch18/">Chapter 18. Security: EAP, IPsec, TLS, DNSSEC, and DKIM</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/headers/">Headers</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">GOPL <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../gopl/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch1/">Chapter 1. Tutorial</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch2/">Chapter 2. Program Structure</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch3/">Chapter 3. Basic Data Types</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch4/">Chapter 4. Composite Types</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch5/">Chapter 5. Functions</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch6/">Chapter 6. Methods</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch7/">Chapter 7. Interfaces</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch8/">Chapter 8. Goroutines and Channels</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch9/">Chapter 9. Concurrency with Shared Variables</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch10/">Chapter 10. Packages and the Go Tool</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch11/">Chapter 11. Testing</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch12/">Chapter 12. Reflection</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">CSN <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../csn/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../csn/part1/">Part 1: Language</a>
                        </li>
                      
                        <li>
                            <a href="../../csn/part2/">Part 2: Advanced</a>
                        </li>
                      
                    </ul>
                </li>
            <li>
                    <a href="../../toc/">TOC</a>
                </li>
            </ul>
            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    
                        <a href="https://github.com/shichao-an/notes/blob/master/docs/apue/ch10.md">
                    
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#chapter-10-signals">Chapter 10. Signals</a></li>
        
    
        <li class="main "><a href="#introduction">Introduction</a></li>
        
            <li><a href="#posix-reliable-signals">POSIX reliable signals</a></li>
        
    
        <li class="main "><a href="#signal-concepts">Signal Concepts</a></li>
        
            <li><a href="#signal-dispositions">Signal dispositions</a></li>
        
            <li><a href="#unix-system-signals">UNIX System signals</a></li>
        
            <li><a href="#the-core-file">The core file</a></li>
        
            <li><a href="#detailed-description-of-signals">Detailed description of signals</a></li>
        
    
        <li class="main "><a href="#signal-function">signal Function</a></li>
        
            <li><a href="#program-start-up">Program Start-Up</a></li>
        
            <li><a href="#process-creation">Process Creation</a></li>
        
    
        <li class="main "><a href="#unreliable-signals">Unreliable Signals</a></li>
        
    
        <li class="main "><a href="#interrupted-system-calls">Interrupted System Calls</a></li>
        
            <li><a href="#slow-system-calls">Slow system calls</a></li>
        
            <li><a href="#automatic-restarts-of-interrupted-system-calls">Automatic restarts of interrupted system calls</a></li>
        
    
        <li class="main "><a href="#reentrant-functions">Reentrant Functions</a></li>
        
            <li><a href="#example-of-calling-getpwnam-from-a-signal-handler">Example of calling getpwnam from a signal handler *</a></li>
        
    
        <li class="main "><a href="#sigcld-semantics">SIGCLD Semantics</a></li>
        
    
        <li class="main "><a href="#reliable-signal-terminology-and-semantics">Reliable-Signal Terminology and Semantics</a></li>
        
    
        <li class="main "><a href="#kill-and-raise-functions">kill and raise Functions</a></li>
        
    
        <li class="main "><a href="#alarm-and-pause-functions">alarm and pause Functions</a></li>
        
            <li><a href="#sleep1-example">sleep1 example</a></li>
        
            <li><a href="#sleep2-example-using-setjmp-and-longjmp">sleep2 example: using setjmp and longjmp</a></li>
        
            <li><a href="#sleep2s-interaction-with-other-signals">sleep2's interaction with other signals</a></li>
        
            <li><a href="#implementing-a-timeout-using-alarm">Implementing a timeout using alarm</a></li>
        
            <li><a href="#implementing-a-timeout-with-alarm-and-longjmp">Implementing a timeout with alarm and longjmp</a></li>
        
    
        <li class="main "><a href="#signal-sets">Signal Sets</a></li>
        
            <li><a href="#implementation-of-signal-sets">Implementation of signal sets</a></li>
        
    
        <li class="main "><a href="#sigprocmask-function">sigprocmask Function</a></li>
        
    
        <li class="main "><a href="#sigpending-function">sigpending Function</a></li>
        
            <li><a href="#example-of-sigpending-and-other-signal-features">Example of sigpending and other signal features</a></li>
        
    
        <li class="main "><a href="#sigaction-function">sigaction Function</a></li>
        
            <li><a href="#example-signal-function">Example: signal Function</a></li>
        
            <li><a href="#example-signal_intr-function">Example: signal_intr Function</a></li>
        
    
        <li class="main "><a href="#sigsetjmp-and-siglongjmp-functions">sigsetjmp and siglongjmp Functions</a></li>
        
    
        <li class="main "><a href="#sigsuspend-function">sigsuspend Function</a></li>
        
            <li><a href="#example-of-sigsuspend-to-protect-a-critial-region">Example of sigsuspend to protect a critial region</a></li>
        
            <li><a href="#example-of-sigsuspend-to-wait-for-a-signal-handler-to-set-a-global-variable">Example of sigsuspend to wait for a signal handler to set a global variable</a></li>
        
            <li><a href="#example-of-signals-that-synchronize-a-parent-and-child">Example of signals that synchronize a parent and child</a></li>
        
    
        <li class="main "><a href="#abort-function">abort Function</a></li>
        
    
        <li class="main "><a href="#system-function">system Function</a></li>
        
            <li><a href="#example-of-system-invoking-ed-editor">Example of system invoking ed editor</a></li>
        
            <li><a href="#implementation-of-system-with-signal-handling">Implementation of system with signal handling</a></li>
        
            <li><a href="#return-value-from-system">Return Value from system</a></li>
        
    
        <li class="main "><a href="#sleep-nanosleep-and-clock_nanosleep-functions">sleep, nanosleep, and clock_nanosleep Functions</a></li>
        
    
        <li class="main "><a href="#sigqueue-function">sigqueue Function</a></li>
        
    
        <li class="main "><a href="#job-control-signals">Job-Control Signals</a></li>
        
    
        <li class="main "><a href="#signal-names-and-numbers">Signal Names and Numbers</a></li>
        
    
        <li class="main "><a href="#summary">Summary</a></li>
        
    
        <li class="main "><a href="#doubts-and-solutions">Doubts and Solutions</a></li>
        
            <li><a href="#verbatim">Verbatim</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">
              

<h3 id="chapter-10-signals"><strong>Chapter 10. Signals</strong><a class="headerlink" href="#chapter-10-signals" title="Permanent link">&para;</a></h3>
<h3 id="introduction">Introduction<a class="headerlink" href="#introduction" title="Permanent link">&para;</a></h3>
<p>Signals are software interrupts. They provide a way of handling asynchronous events. Most nontrivial application programs need to deal with signals.</p>
<h4 id="posix-reliable-signals">POSIX reliable signals<a class="headerlink" href="#posix-reliable-signals" title="Permanent link">&para;</a></h4>
<p>Signals have been provided since the early versions of the UNIX System, but the signal model provided with systems such as Version 7 was not reliable. Signals could get lost, and it was difficult for a process to turn off selected signals when executing critical regions of code. Both 4.3BSD and SVR3 made changes to the signal model, adding what are called <strong>reliable signals</strong>. But the changes made by Berkeley and AT&amp;T were incompatible. Fortunately, POSIX.1 standardized the reliable-signal routines, and that is what we describe here.</p>
<p>This chapter starts with an overview of signals and a description of what each signal is normally used for, then discusses problems with earlier implementations, since it is often important to understand what is wrong with an implementation before seeing how to do things correctly. This chapter contains numerous examples that are not entirely correct and a discussion of the defects.</p>
<h3 id="signal-concepts">Signal Concepts<a class="headerlink" href="#signal-concepts" title="Permanent link">&para;</a></h3>
<ul>
<li>
<p>Every signal has a name. They all begin with the three characters <code>SIG</code>. For example:</p>
<ul>
<li><code>SIGABRT</code> is the abort signal that is generated when a process calls the <code>abort</code> function.</li>
<li><code>SIGALRM</code> is the alarm signal that is generated when the timer set by the <code>alarm</code> function goes off.</li>
</ul>
<p>FreeBSD 8.0 supports 32 different signals. Mac OS X 10.6.8 and Linux 3.2.0 each support 31 different signals, whereas Solaris 10 supports 40 different signals. FreeBSD, Linux, and Solaris, support additional application-defined signals introduced to support <strong>real-time applications</strong>.</p>
</li>
<li>
<p>Signal names are all defined by positive integer constants (the signal number) in the header <code>&lt;signal.h&gt;</code>.</p>
<ul>
<li>Implementations actually define the individual signals in a different header file, but this header file is included by <code>&lt;signal.h&gt;</code>.</li>
<li>It bad for the kernel to include header files meant for user-level applications, so if the applications and the kernel both need the same definitions, the information is placed in a kernel header file that is then included by the user-level header file.<ul>
<li><code>&lt;sys/signal.h&gt;</code>: FreeBSD 8.0 and Mac OS X 10.6.8</li>
<li><code>&lt;bits/signum.h&gt;</code>: Linux 3.2.0</li>
<li><code>&lt;sys/iso/signal_iso.h&gt;</code>: Solaris 10</li>
</ul>
</li>
</ul>
</li>
<li>No signal has a signal number of 0. The <code>kill</code> function uses the signal number of 0 for a special case. POSIX.1 calls this value the null signal.</li>
<li>Numerous conditions can generate a signal:<ul>
<li>The terminal-generated signals occur when users press certain terminal keys. Pressing the DELETE key or Control-C on the terminal normally causes the interrupt signal (<code>SIGINT</code>) to be generated.</li>
<li>Hardware exceptions generate signals. For example, divide by 0 and invalid memory reference. These conditions are usually detected by the hardware, and the kernel is notified. The kernel then generates the appropriate signal for the process that was running at the time the condition occurred. For example, <code>SIGSEGV</code> is generated for a process that executes an invalid memory reference.</li>
<li>The <code>kill(2)</code> function allows a process to send any signal to another process or process group, with limitations: we have to be the owner of the process that we’re sending the signal to, or we have to be the superuser.</li>
<li>The <code>kill(1)</code> command allows us to send signals to other processes. This program is just an interface to the <code>kill</code> function. This command is often used to terminate a runaway background process.</li>
<li>Software conditions can generate signals when a process should be notified of various events. For example:<ul>
<li><code>SIGURG</code>: generated when out-of-band data arrives over a network connection),</li>
<li><code>SIGPIPE</code>: generated when a process writes to a pipe that has no reader)</li>
<li><code>SIGALRM</code>: generated when an alarm clock set by the process expires).</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Signals are classic examples of asynchronous events. They occur at random times to the process. The process can’t simply test a variable (such as <code>errno</code>) to see whether a signal has occurred; instead, the process has to tell the kernel "if and when this signal occurs, do the following".</p>
<h4 id="signal-dispositions">Signal dispositions<a class="headerlink" href="#signal-dispositions" title="Permanent link">&para;</a></h4>
<p>We can tell the kernel to do one of three things when a signal occurs. This is called the <strong>disposition of the signal</strong>, or the <strong>action associated with a signal</strong>. (<a href="http://man7.org/linux/man-pages/man7/signal.7.html"><code>signal(7)</code></a>)</p>
<ol>
<li><strong>Ignore the signal</strong>. Most signals can be ignored, but two signals can never be ignored: <code>SIGKILL</code> and <code>SIGSTOP</code>.<ul>
<li>The reason these two signals can’t be ignored is to provide the kernel and the superuser with a surefire way of either killing or stopping any process.</li>
<li>If we ignore some of the signals that are generated by a hardware exception (such as illegal memory reference or divide by 0), the behavior of the process is undefined.</li>
</ul>
</li>
<li><strong>Catch the signal</strong>. To do this, we tell the kernel to call a function of ours whenever the signal occurs. In our function, we can do whatever we want to handle the condition. For example:<ul>
<li>If we’re writing a command interpreter, when the user generates the interrupt signal at the keyboard, we probably want to return to the main loop of the program, terminating whatever command we were executing for the user.</li>
<li>If the <code>SIGCHLD</code> signal is caught, it means that a child process has terminated, so the signal-catching function can call <code>waitpid</code> to fetch the child’s process ID and termination status.</li>
<li>If the process has created temporary files, we may want to write a signal-catching function for the SIGTERM signal (the termination signal that is the default signal sent by the kill command) to clean up the temporary files.</li>
<li>Note that the two signals <code>SIGKILL</code> and <code>SIGSTOP</code> can’t be caught.</li>
</ul>
</li>
<li><strong>Let the default action apply</strong>. Every signal has a default action. The default action for most signals is to terminate the process.</li>
</ol>
<p>The signals <code>SIGKILL</code> and <code>SIGSTOP</code> cannot be caught, blocked, or ignored. (<a href="http://man7.org/linux/man-pages/man7/signal.7.html"><code>signal(7)</code></a>)</p>
<h4 id="unix-system-signals">UNIX System signals<a class="headerlink" href="#unix-system-signals" title="Permanent link">&para;</a></h4>
<p>The following table lists the names of all the signals, an indication of which systems support the signal, and the default action for the signal. The SUS column contains "x" if the signal is defined as part of the base POSIX.1 specification and XSI if it is defined as part of the XSI option. The supported systems are FreeBSD 8.0, Linux 3.2.0, Mac OS X 10.6.8 and Solaris 10.</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
<th>ISO C</th>
<th>SUS</th>
<th>FreeBSD</th>
<th>Linux</th>
<th>Mac OS X</th>
<th>Solaris</th>
<th>Default action</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SIGABRT</code></td>
<td>abnormal termination (<code>abort</code>)</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>terminate+core</td>
</tr>
<tr>
<td><code>SIGALRM</code></td>
<td>timer expired (<code>alarm</code>)</td>
<td></td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>terminate</td>
</tr>
<tr>
<td><code>SIGBUS</code></td>
<td>hardware fault</td>
<td></td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>terminate+core</td>
</tr>
<tr>
<td><code>SIGCANCEL</code></td>
<td>threads library internal use</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>x</td>
<td>ignore</td>
</tr>
<tr>
<td><code>SIGCHLD</code></td>
<td>change in status of child</td>
<td></td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>ignore</td>
</tr>
<tr>
<td><code>SIGCONT</code></td>
<td>continue stopped process</td>
<td></td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>continue/ignore</td>
</tr>
<tr>
<td><code>SIGEMT</code></td>
<td>hardware fault</td>
<td></td>
<td></td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>terminate+core</td>
</tr>
<tr>
<td><code>SIGFPE</code></td>
<td>arithmetic exception</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>terminate+core</td>
</tr>
<tr>
<td><code>SIGFREEZE</code></td>
<td>checkpoint freeze</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>x</td>
<td>ignore</td>
</tr>
<tr>
<td><code>SIGHUP</code></td>
<td>hangup</td>
<td></td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>terminate</td>
</tr>
<tr>
<td><code>SIGILL</code></td>
<td>illegal instruction</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>terminate+core</td>
</tr>
<tr>
<td><code>SIGINFO</code></td>
<td>status request from keyboard</td>
<td></td>
<td></td>
<td>x</td>
<td></td>
<td>x</td>
<td></td>
<td>ignore</td>
</tr>
<tr>
<td><code>SIGINT</code></td>
<td>terminal interrupt character</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>terminate</td>
</tr>
<tr>
<td><code>SIGIO</code></td>
<td>asynchronous I/O</td>
<td></td>
<td></td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>terminate/ignore</td>
</tr>
<tr>
<td><code>SIGIOT</code></td>
<td>hardware fault</td>
<td></td>
<td></td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>terminate+core</td>
</tr>
<tr>
<td><code>SIGJVM1</code></td>
<td>Java virtual machine internal use</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>x</td>
<td>ignore</td>
</tr>
<tr>
<td><code>SIGJVM2</code></td>
<td>Java virtual machine internal use</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>x</td>
<td>ignore</td>
</tr>
<tr>
<td><code>SIGKILL</code></td>
<td>termination</td>
<td></td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>terminate</td>
</tr>
<tr>
<td><code>SIGLOST</code></td>
<td>resource lost</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>x</td>
<td>terminate</td>
</tr>
<tr>
<td><code>SIGLWP</code></td>
<td>threads library internal use</td>
<td></td>
<td></td>
<td>x</td>
<td></td>
<td></td>
<td>x</td>
<td>ignore</td>
</tr>
<tr>
<td><code>SIGPIPE</code></td>
<td>write to pipe with no readers</td>
<td></td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>terminate</td>
</tr>
<tr>
<td><code>SIGPOLL</code></td>
<td>pollable event (<code>poll</code>)</td>
<td></td>
<td></td>
<td></td>
<td>x</td>
<td></td>
<td>x</td>
<td>terminate</td>
</tr>
<tr>
<td><code>SIGPROF</code></td>
<td>profiling time alarm (<code>setitimer</code>)</td>
<td></td>
<td></td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>terminate</td>
</tr>
<tr>
<td><code>SIGPWR</code></td>
<td>power fail/restart</td>
<td></td>
<td></td>
<td></td>
<td>x</td>
<td></td>
<td>x</td>
<td>terminate/ignore</td>
</tr>
<tr>
<td><code>SIGQUIT</code></td>
<td>terminal quit character</td>
<td></td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>terminate+core</td>
</tr>
<tr>
<td><code>SIGSEGV</code></td>
<td>invalid memory reference</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>terminate+core</td>
</tr>
<tr>
<td><code>SIGSTKFLT</code></td>
<td>coprocessor stack fault</td>
<td></td>
<td></td>
<td></td>
<td>x</td>
<td></td>
<td></td>
<td>terminate</td>
</tr>
<tr>
<td><code>SIGSTOP</code></td>
<td>stop</td>
<td></td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>stop process</td>
</tr>
<tr>
<td><code>SIGSYS</code></td>
<td>invalid system call</td>
<td></td>
<td>XSI</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>terminate+core</td>
</tr>
<tr>
<td><code>SIGTERM</code></td>
<td>termination</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>terminate</td>
</tr>
<tr>
<td><code>SIGTHAW</code></td>
<td>checkpoint thaw</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>x</td>
<td>ignore</td>
</tr>
<tr>
<td><code>SIGTHR</code></td>
<td>threads library internal use</td>
<td></td>
<td></td>
<td>x</td>
<td></td>
<td></td>
<td>x</td>
<td>terminate</td>
</tr>
<tr>
<td><code>SIGTRAP</code></td>
<td>hardware fault</td>
<td></td>
<td>XSI</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>terminate+core</td>
</tr>
<tr>
<td><code>SIGTSTP</code></td>
<td>terminal stop character</td>
<td></td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>stop process</td>
</tr>
<tr>
<td><code>SIGTTIN</code></td>
<td>background read from control tty</td>
<td></td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>stop process</td>
</tr>
<tr>
<td><code>SIGTTOU</code></td>
<td>background write to control tty</td>
<td></td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>stop process</td>
</tr>
<tr>
<td><code>SIGURG</code></td>
<td>urgent condition (sockets)</td>
<td></td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>ignore</td>
</tr>
<tr>
<td><code>SIGUSR1</code></td>
<td>user-defined signal</td>
<td></td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>terminate</td>
</tr>
<tr>
<td><code>SIGUSR2</code></td>
<td>user-defined signal</td>
<td></td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>terminate</td>
</tr>
<tr>
<td><code>SIGVTALRM</code></td>
<td>virtual time alarm (<code>setitimer</code>)</td>
<td></td>
<td>XSI</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>terminate</td>
</tr>
<tr>
<td><code>SIGWAITING</code></td>
<td>threads library internal use</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>x</td>
<td>ignore</td>
</tr>
<tr>
<td><code>SIGWINCH</code></td>
<td>terminal window size change</td>
<td></td>
<td></td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>ignore</td>
</tr>
<tr>
<td><code>SIGXCPU</code></td>
<td>CPU limit exceeded (<code>setrlimit</code>)</td>
<td></td>
<td>XSI</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>terminate+core/ignore</td>
</tr>
<tr>
<td><code>SIGXFSZ</code></td>
<td>file size limit exceeded (<code>setrlimit</code>)</td>
<td></td>
<td>XSI</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>terminate+core/ignore</td>
</tr>
<tr>
<td><code>SIGXRES</code></td>
<td>resource control exceeded</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>x</td>
<td>ignore</td>
</tr>
</tbody>
</table>
<h4 id="the-core-file">The core file<a class="headerlink" href="#the-core-file" title="Permanent link">&para;</a></h4>
<p>When the default action (in the table above) is labeled "terminate+core", it means that a memory image of the process is left in the file named <code>core</code> of the current working directory of the process. This file can be used with most UNIX System debuggers to examine the state of the process at the time it terminated.</p>
<p>The name of the <code>core</code> file varies among implementations.  On Mac OS X 10.6.8, the core file is named core.<em>pid</em>, where <em>pid</em> is the ID of the process that received the signal. On Linux 3.2.0, the name is configured through <code>/proc/sys/kernel/core_pattern</code>. (<a href="http://man7.org/linux/man-pages/man5/core.5.html"><code>core(5)</code></a>) [p315]</p>
<p>Most implementations leave the core file in the current working directory of the corresponding process; Mac OS X places all core files in <code>/cores</code> instead.</p>
<p>The core file will not be generated if:</p>
<ul>
<li>the process was set-user-ID and the current user is not the owner of the program file,</li>
<li>the process was set-group-ID and the current user is not the group owner of the file,</li>
<li>the user does not have permission to write in the current working directory,</li>
<li>the file already exists and the user does not have permission to write to it,</li>
<li>the file is too big (see <code>RLIMIT_CORE</code> limit in <a href="../ch7/#getrlimit-and-setrlimit-functions">Section 7.11</a>)</li>
</ul>
<p>The permissions of the core file (assuming that the file doesn’t already exist) are usually user-read and user-write, although Mac OS X sets only user-read.</p>
<p>In the table, the signals with a description of "hardware fault" correspond to implementation-defined hardware faults.</p>
<h4 id="detailed-description-of-signals">Detailed description of signals<a class="headerlink" href="#detailed-description-of-signals" title="Permanent link">&para;</a></h4>
<ul>
<li><code>SIGABRT</code>: generated by calling the <code>abort</code> function.  The process terminates abnormally.</li>
<li><code>SIGALRM</code>:<ul>
<li>This signal is generated when a timer set with the <code>alarm</code> function expires.</li>
<li>This signal is also generated when an interval timer set by the <code>setitimer(2)</code> function expires.</li>
</ul>
</li>
<li><code>SIGBUS</code>: indicates an implementation-defined hardware fault.  Implementations usually generate this signal on certain types of memory faults.</li>
<li><span class="text-muted"><code>SIGCANCEL</code>: used internally by the Solaris threads library. It is not meant for general use.</span></li>
<li><code>SIGCHLD</code>: Whenever a process terminates or stops, the <code>SIGCHLD</code> signal is sent to the parent. By default, this signal is ignored, so the parent must catch this signal if it wants to be notified whenever a child’s status changes. The normal action in the signal-catching function is to call one of the <code>wait</code> functions to fetch the child’s process ID and termination status. [p317]</li>
<li><code>SIGCONT</code>: this job-control signal is sent to a stopped process when it is continued. The default action is to continue a stopped process, but to ignore the signal if the process wasn’t stopped.</li>
<li><code>SIGEMT</code>: indicates an implementation-defined hardware fault. Not all platforms support this signal. [p318]</li>
<li><code>SIGFPE</code>: signals an arithmetic exception, such as divide by 0, floating-point overflow, and so on. The name is derived from "floating-point exception" (<a href="http://www.gnu.org/software/libc/manual/html_node/Program-Error-Signals.html">Program Error Signals</a>).</li>
<li><span class="text-muted"><code>SIGFREEZE</code>: defined only by Solaris. </span> [p318]</li>
<li><code>SIGHUP</code>: this signal is sent to the controlling process (session leader) associated with a controlling terminal if a disconnect is detected by the terminal interface.<ul>
<li>This signal is generated for this condition only if the terminal’s <code>CLOCAL</code> flag is not set. The <code>CLOCAL</code> flag for a terminal is set if the attached terminal is local. The flag tells the terminal driver to ignore all modem status lines.</li>
<li>The session leader that receives this signal may be in the background (<a href="../figure_9.7.png">Figure 9.7</a>). This differs from the normal terminal-generated signals (interrupt, quit, and suspend), which are always delivered to the foreground process group.</li>
<li>This signal is also generated if the session leader terminates. In this case, the signal is sent to each process in the foreground process group.</li>
<li>This signal is commonly used to notify daemon processes (<a href="../ch13/">Chapter 13</a>) to reread their configuration files. The reason <code>SIGHUP</code> is chosen for this task is that a daemon should not have a controlling terminal and would normally never receive this signal.</li>
</ul>
</li>
<li><code>SIGILL</code>: indicates that the process has executed an illegal hardware instruction.<ul>
<li>4.3BSD generated this signal from the abort function. <code>SIGABRT</code> is now used for this purpose.</li>
</ul>
</li>
<li><code>SIGINFO</code>: This BSD signal is generated by the terminal driver when we type the status key (often Control-T). This signal is sent to all processes in the foreground process group (Figure 9.9). This signal normally causes status information on processes in the foreground process group to be displayed on the terminal. Linux doesn’t provide support for <code>SIGINFO</code>.</li>
<li><code>SIGINT</code>: generated by the terminal driver when we press the interrupt key (often DELETE or Control-C). This signal is sent to all processes in the foreground process group (<a href="../figure_9.9.png">Figure 9.9</a>). This signal is often used to terminate a runaway program, especially when it’s generating a lot of unwanted output on the screen.</li>
<li><code>SIGIO</code>: indicates an asynchronous I/O event.</li>
<li><code>SIGIOT</code>: indicates an implementation-defined hardware fault. <code>SIGABRT</code> is now used for this purpose. On FreeBSD 8.0, Linux 3.2.0, Mac OS X 10.6.8, and Solaris 10, <code>SIGIOT</code> is defined to be the same value as <code>SIGABRT</code>.</li>
<li><span class="text-muted"><code>SIGJVM1</code> and <code>SIGJVM2</code>: reserved for use by the Java virtual machine on Solaris.</span></li>
<li><code>SIGKILL</code>: one of the two that can’t be caught or ignored. It provides the system administrator with a sure way to kill any process.</li>
<li><span class="text-muted"><code>SIGLOST</code>: used to notify a process running on a Solaris NFSv4 client system that a lock could not be reacquired during recovery.</span></li>
<li><code>SIGPIPE</code>: If we write to a pipeline but the reader has terminated, <code>SIGPIPE</code> is generated. This signal is also generated when a process writes to a socket of type <code>SOCK_STREAM</code> that is no longer connected.</li>
<li><span class="text-muted"><code>SIGPOLL</code>: This signal is marked obsolescent in SUSv4, so it might be removed in a future version of the standard. It can be generated when a specific event occurs on a pollable device.</span></li>
<li><span class="text-muted"><code>SIGPROF</code>: This signal is marked obsolescent in SUSv4, so it might be removed in a future version of the standard. This signal is generated when a profiling interval timer set by the <code>setitimer(2)</code> function expires.</span></li>
<li><code>SIGPWR</code>: system dependent, mainly used on a system that has an uninterruptible power supply (UPS).<ul>
<li>If power fails, the UPS takes over and the software can usually be notified. Nothing needs to be done at this point, as the system continues running on battery power. But if the battery gets low, the software is usually notified again; at this point, it behooves the system to shut everything down. The process that is notified of the low-battery condition sends the <code>SIGPWR</code> signal to the <code>init</code> process, and <code>init</code> handles the system shutdown.</li>
<li>Solaris 10 and some Linux distributions have entries in the <code>inittab</code> file for this purpose: <code>powerfail</code> and <code>powerwait</code> (or <code>powerokwait</code>).</li>
<li>The default action for <code>SIGPWR</code> as either "terminate" or "ignore", which depends on the system. The default on Linux is to terminate the process. On Solaris, the signal is ignored by default.</li>
</ul>
</li>
<li><code>SIGQUIT</code>: generated by the terminal driver when we press the terminal quit key (often Control-backslash). This signal is sent to all processes in the foreground process group (<a href="../figure_9.9.png">Figure 9.9</a>). This signal not only terminates the foreground process group (as does <code>SIGINT</code>), but also generates a <code>core</code> file.</li>
<li><code>SIGSEGV</code>: indicates that the process has made an invalid memory reference (which is usually a sign that the program has a bug, such as dereferencing an uninitialized pointer). The name SEGV stands for "segmentation violation".</li>
<li><code>SIGSTKFLT</code>: This signal is defined only by Linux. It showed up in the earliest versions of Linux, where it was intended to be used for stack faults taken by the math coprocessor. This signal is not generated by the kernel, but remains for backward compatibility.</li>
<li><code>SIGSTOP</code>: This job-control signal stops a process. It is similar to the interactive stop signal (<code>SIGTSTP</code>), but <code>SIGSTOP</code> cannot be caught or ignored.</li>
<li><code>SIGSYS</code>: indicates an invalid system call. The process executed a machine instruction that the kernel thought was a system call, but the parameter with the instruction that indicates the type of system call was invalid. For example, if you build a program that uses a new system call and you then try to run the same binary on an older version of the operating system where the system call doesn’t exist. [p320]</li>
<li><code>SIGTERM</code>: the termination signal sent by the <code>kill(1)</code> command by default. Because it can be caught by applications, using <code>SIGTERM</code> gives programs a chance to terminate gracefully by cleaning up before exiting (in contrast to <code>SIGKILL</code>, which can’t be caught or ignored).</li>
<li><span class="text-muted"><code>SIGTHAW</code>: defined only by Solaris and used to notify processes that need to take special action when the system resumes operation after being suspended.</span></li>
<li><span class="text-muted"><code>SIGTHR</code>: reserved for use by the thread library on FreeBSD. It is defined to have the same value as <code>SIGLWP</code>.</span></li>
<li><code>SIGTRAP</code>: indicates an implementation-defined hardware fault. The signal name comes from the PDP-11 TRAP instruction. Implementations often use this signal to transfer control to a debugger when a breakpoint instruction is executed.</li>
<li><code>SIGTSTP</code>: This interactive stop signal is generated by the terminal driver when we press the terminal suspend key (often Control-Z). This signal is sent to all processes in the foreground process group (<a href="../figure_9.9.png">Figure 9.9</a>). [p321]</li>
<li><code>SIGTTIN</code>: generated by the terminal driver when a process in a background process group tries to read from its controlling terminal. If either of the following case occurs, the signal is not generated; instead, the read operation fails with errno set to <code>EIO</code>:<ul>
<li>The reading process is ignoring or blocking this signal.</li>
<li>The process group of the reading process is orphaned.</li>
</ul>
</li>
<li>
<p><code>SIGTTOU</code>: generated by the terminal driver when a process in a background process group tries to write to its controlling terminal. Unlike the case with background reads, a process can choose to allow background writes to the controlling terminal. If background writes are not allowed, then like the <code>SIGTTIN</code> signal, the signal is not generated if either of the following cases occurs; instead, the read operation fails with errno set to <code>EIO</code>:</p>
<ul>
<li>The writing process is ignoring or blocking this signal</li>
<li>The process group of the writing process is orphaned</li>
</ul>
<p>Regardless of whether background writes are allowed, certain terminal operations (other than writing), including <code>tcsetattr</code>, <code>tcsendbreak</code>, <code>tcdrain</code>, <code>tcflush</code>, <code>tcflow</code>, and <code>tcsetpgrp</code> can also generate the <code>SIGTTOU</code> signal.</p>
</li>
<li>
<p><code>SIGURG</code>: notifies the process that an urgent condition has occurred. It is optionally generated when <a href="https://en.wikipedia.org/wiki/Out-of-band_data">out-of-band data</a> is received on a network connection.</p>
</li>
<li><code>SIGUSR1</code> and <code>SIGUSR2</code>: user-defined signals, for use in application programs.</li>
<li><code>SIGVTALRM</code>: generated when a virtual interval timer set by the <code>setitimer(2)</code> function expires.</li>
<li><span class="text-muted"><code>SIGWAITING</code>: used internally by the Solaris threads library, and is not available for general use.</span></li>
<li><code>SIGWINCH</code>: The kernel maintains the size of the window associated with each terminal and pseudo terminal. A process can get and set the window size with the <code>ioctl</code> function. If a process changes the window size from its previous value using the <code>ioctl</code> set-window-size command, the kernel generates the <code>SIGWINCH</code> signal for the foreground process group.</li>
<li><code>SIGXCPU</code>: generated if the process exceeds its soft CPU time limit. The default action depends on the operating system. The Single UNIX Specification requires that the default action be to terminate the process abnormally.<ul>
<li>Linux 3.2.0 and Solaris 10 support a default action of terminate with a core file</li>
<li>FreeBSD 8.0 and Mac OS X 10.6.8 support a default action of terminate without generating a core file.</li>
</ul>
</li>
<li><code>SIGXFSZ</code>:  generated if the process exceeds its soft file size limit. The default action depends on the operating system, similar to <code>SIGXCPU</code>.</li>
<li><span class="text-muted"><code>SIGXRES</code>: defined only by Solaris.</span></li>
</ul>
<h3 id="signal-function"><code>signal</code> Function<a class="headerlink" href="#signal-function" title="Permanent link">&para;</a></h3>
<p>The simplest interface to the signal features of the UNIX System is the signal function</p>
<p><small><a href="https://gist.github.com/shichao-an/73f4115f93c26a852349">apue_signal.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp"></span>

<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">signal</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="kt">int</span><span class="p">)))(</span><span class="kt">int</span><span class="p">);</span>

<span class="cm">/* Returns: previous disposition of signal (see following) if OK, SIG_ERR on error */</span>
</pre></div>


<p>Implementations derived from UNIX System V support the <code>signal</code> function, which provides the old unreliable-signal semantics. New applications should not use these unreliable signals. 4.4BSD also provides the <code>signal</code> function, but it is defined in terms of the <code>sigaction</code> function, so using it under 4.4BSD provides the newer reliable-signal semantics. Most current systems follow this strategy except Solaris. [p323]</p>
<p>Because the semantics of signal differ among implementations, we must use the <code>sigaction</code> function instead. We provide an implementation of <code>signal</code> that uses <code>sigaction</code> (later this chapter).</p>
<p>Arguments:</p>
<ul>
<li>The <em>signo</em> argument is the name of the signal from <a href="#unix-system-signals">previous table</a>.</li>
<li>The value of <em>func</em> one of the following:<ul>
<li>the constant <code>SIG_IGN</code>, which tells the system ignore the signal;</li>
<li>the constant <code>SIG_DFL</code>, which sets the action associated with the signal to its default value;</li>
<li>the address of a function to be called when the signal occurs, which arranges to "catch" the signal. This function is called either the <strong>signal handler</strong> or the <strong>signal-catching function</strong>.</li>
</ul>
</li>
</ul>
<p>The prototype for the <code>signal</code> function states that the function requires two arguments and returns a pointer to a function that returns nothing (<code>void</code>):</p>
<ul>
<li>The first argument, <em>signo</em>, is an integer.</li>
<li>The second argument, <em>func</em>, is a pointer to a function that takes a single integer argument and returns nothing.</li>
<li>The returned function (function whose address is returned as the value of <code>signal</code>) takes a single integer argument (the final (<code>int</code>)).</li>
</ul>
<p>In plain English, this declaration says that the signal handler is passed a single integer argument (the signal number) and that it returns nothing. When we call signal to establish the signal handler, the second argument is a pointer to the function.  The return value from <code>signal</code> is the pointer to the previous signal handler.</p>
<p>The <code>signal</code> function prototype can be made much simpler through the use of the following <code>typedef</code>:</p>
<div class="codehilite"><pre><span class="k">typedef</span> <span class="kt">void</span> <span class="nf">Sigfunc</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</pre></div>


<p>Then the prototype becomes:</p>
<div class="codehilite"><pre><span class="n">Sigfunc</span> <span class="o">*</span><span class="nf">signal</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">Sigfunc</span> <span class="o">*</span><span class="p">);</span>
</pre></div>


<p>This <code>typedef</code> is included in <a href="https://github.com/shichao-an/apue.3e/blob/master/include/apue.h#L41">apue.h</a> and is used with the functions in this chapter.</p>
<p>If we examine the system’s header <code>&lt;signal.h&gt;</code>, we will probably find declarations of the form:</p>
<div class="codehilite"><pre><span class="cp">#define SIG_ERR (void (*)())-1</span>
<span class="cp">#define SIG_DFL (void (*)())0</span>
<span class="cp">#define SIG_IGN (void (*)())1</span>
</pre></div>


<p>These constants can be used in place of the "pointer to a function that takes an integer argument and returns nothing", the second argument to <code>signal</code>, and the return value from <code>signal</code>. The three values used for these constants need not be −1, 0, and 1. They must be three values that can never be the address of any declarable function. Most UNIX systems use the values shown. (See <a href="##doubts-and-solutions">Doubts and Solutions</a> for details)</p>
<p>Example:</p>
<p>The following code shows a simple signal handler that catches either of the two user-defined signals and prints the signal number.</p>
<ul>
<li><a href="https://github.com/shichao-an/apue.3e/blob/master/signals/sigusr.c">sigusr.c</a></li>
</ul>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&quot;apue.h&quot;</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sig_usr</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>   <span class="cm">/* one handler for both signals */</span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">signal</span><span class="p">(</span><span class="n">SIGUSR1</span><span class="p">,</span> <span class="n">sig_usr</span><span class="p">)</span> <span class="o">==</span> <span class="n">SIG_ERR</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;can&#39;t catch SIGUSR1&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">signal</span><span class="p">(</span><span class="n">SIGUSR2</span><span class="p">,</span> <span class="n">sig_usr</span><span class="p">)</span> <span class="o">==</span> <span class="n">SIG_ERR</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;can&#39;t catch SIGUSR2&quot;</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="p">;</span> <span class="p">)</span>
        <span class="n">pause</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sig_usr</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">)</span>      <span class="cm">/* argument is signal number */</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">signo</span> <span class="o">==</span> <span class="n">SIGUSR1</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;received SIGUSR1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">signo</span> <span class="o">==</span> <span class="n">SIGUSR2</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;received SIGUSR2</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="n">err_dump</span><span class="p">(</span><span class="s">&quot;received signal %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">signo</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>We invoke the program in the background and use the <code>kill(1)</code> command to send it signals. The term <em>kill</em> in the UNIX System is a misnomer. The <code>kill(1)</code> command and the <code>kill(2)</code> function just send a signal to a process or process group. Whether that signal terminates the process depends on which signal is sent and whether the process has arranged to catch the signal.</p>
<p>Result:</p>
<div class="codehilite"><pre><span class="gp">$</span> ./a.out <span class="p">&amp;</span>                <span class="c1"># start process in background</span>
<span class="go">[1] 7216                   # job-control shell prints job number and process ID</span>
<span class="gp">$</span> <span class="nb">kill</span> -USR1 <span class="m">7216</span>          <span class="c1"># send it SIGUSR1</span>
<span class="go">received SIGUSR1</span>
<span class="gp">$</span> <span class="nb">kill</span> -USR2 <span class="m">7216</span>          <span class="c1"># send it SIGUSR2</span>
<span class="go">received SIGUSR2</span>
<span class="gp">$</span> <span class="nb">kill</span> <span class="m">7216</span>                <span class="c1"># now send it SIGTERM</span>
<span class="go">[1]+ Terminated ./a.out</span>
</pre></div>


<p>When we send the <code>SIGTERM</code> signal, the process is terminated, since it doesn’t catch the signal, and the default action for the signal is termination.</p>
<h4 id="program-start-up">Program Start-Up<a class="headerlink" href="#program-start-up" title="Permanent link">&para;</a></h4>
<p>When a program is executed, the status of all signals is either default or ignore. All signals are set to their default action, unless the process that calls <code>exec</code> is ignoring the signal. The <code>exec</code> functions change the disposition of any signals being caught to their default action and leave the status of all other signals alone. The reason is that a signal that is being caught by a process that calls <code>exec</code> cannot be caught by the same function in the new program, since the address of the signal-catching function in the caller probably has no meaning in the new program file that is executed. [p325]</p>
<p>With a shell that doesn’t support job control, when we execute a process in the background:</p>
<div class="codehilite"><pre>cc main.c <span class="p">&amp;</span>
</pre></div>


<p>The shell automatically sets the disposition of the interrupt and quit signals in the background process to be ignored. This is done so that if we type the interrupt character, it doesn’t affect the background process. If this weren’t done and we typed the interrupt character, it would terminate not only the foreground process, but also all the background processes.</p>
<p>Many interactive programs that catch these two signals have code that looks like:</p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="nf">sig_int</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="n">sig_quit</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">SIG_IGN</span><span class="p">)</span> <span class="o">!=</span> <span class="n">SIG_IGN</span><span class="p">)</span>
    <span class="n">signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">sig_int</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">signal</span><span class="p">(</span><span class="n">SIGQUIT</span><span class="p">,</span> <span class="n">SIG_IGN</span><span class="p">)</span> <span class="o">!=</span> <span class="n">SIG_IGN</span><span class="p">)</span>
    <span class="n">signal</span><span class="p">(</span><span class="n">SIGQUIT</span><span class="p">,</span> <span class="n">sig_quit</span><span class="p">);</span>
</pre></div>


<p><u>Following this approach, the process catches the signal only if the signal is not currently being ignored.</u></p>
<p>The <code>signal</code> function has a limitation: we are not able to determine the current disposition of a signal without changing the disposition. The <code>sigaction</code> function (discussed later in this chapter) allows us to determine a signal’s disposition without changing it.</p>
<h4 id="process-creation">Process Creation<a class="headerlink" href="#process-creation" title="Permanent link">&para;</a></h4>
<p>When a process calls <code>fork</code>, the child inherits the parent’s signal dispositions. Here, since the child starts off with a copy of the parent’s memory image, the address of a signal-catching function has meaning in the child.</p>
<h3 id="unreliable-signals">Unreliable Signals<a class="headerlink" href="#unreliable-signals" title="Permanent link">&para;</a></h3>
<p>In earlier versions of the UNIX System, signals were unreliable, which means that signals could get lost: a signal could occur and the process would never know about it. [p326]</p>
<p>One problem with these early versions was that the action for a signal was reset to its default each time the signal occurred. The code that was described usually looked like:</p>
<div class="codehilite"><pre>    <span class="kt">int</span> <span class="nf">sig_int</span><span class="p">();</span> <span class="cm">/* my signal handling function */</span>
    <span class="p">...</span>
    <span class="n">signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">sig_int</span><span class="p">);</span> <span class="cm">/* establish handler */</span>
    <span class="p">...</span>

<span class="n">sig_int</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">sig_int</span><span class="p">);</span> <span class="cm">/* reestablish handler for next time */</span>
    <span class="p">...</span> <span class="cm">/* process the signal ... */</span> <span class="p">.</span>
<span class="p">}</span>
</pre></div>


<p>The problem with this code fragment is that there is a window of time (after the signal has occurred, but before the call to <code>signal</code> in the signal handler) when the interrupt signal could occur another time. This second signal would cause the default action to occur, which terminates the process. This is one of those conditions that works correctly most of the time, causing us to think that it is correct, when it isn’t.</p>
<p>Another problem with these earlier systems was that the process was unable to turn a signal off when it didn’t want the signal to occur. All the process could do was ignore the signal. There are times when we would like to tell the system "prevent the following signals from interrupting me, but remember if they do occur". The following code catches a signal and sets a flag for the process that indicates that the signal occurred:</p>
<div class="codehilite"><pre><span class="kt">int</span> <span class="nf">sig_int</span><span class="p">();</span> <span class="cm">/* my signal handling function */</span>
<span class="kt">int</span> <span class="n">sig_int_flag</span><span class="p">;</span> <span class="cm">/* set nonzero when signal occurs */</span>

<span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">sig_int</span><span class="p">);</span> <span class="cm">/* establish handler */</span>
    <span class="p">...</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">sig_int_flag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">pause</span><span class="p">();</span> <span class="cm">/* go to sleep, waiting for signal */</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="n">sig_int</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">sig_int</span><span class="p">);</span> <span class="cm">/* reestablish handler for next time */</span>
    <span class="n">sig_int_flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* set flag for main loop to examine */</span>
<span class="p">}</span>
</pre></div>


<p>The process is calling the <code>pause</code> function to put it to sleep until a signal is caught. When the signal is caught, the signal handler just sets the flag <code>sig_int_flag</code> to a nonzero value. The process is automatically awakened by the kernel after the signal handler returns, notices that the flag is nonzero, and does whatever it needs to do. But there is a window of time when things can go wrong. If the signal occurs after the test of <code>sig_int_flag</code> but before the call to pause, the process could go to sleep forever (assuming that the signal is never generated again). This occurrence of the signal is lost.</p>
<h3 id="interrupted-system-calls">Interrupted System Calls<a class="headerlink" href="#interrupted-system-calls" title="Permanent link">&para;</a></h3>
<p>In earlier UNIX systems, if a process caught a signal while the process was blocked in a "slow" system call, the system call was interrupted. The system call returned an error and <code>errno</code> was set to <code>EINTR</code>. This was done under the assumption that since a signal occurred and the process caught it, there is a good chance that something has happened that should wake up the blocked system call.</p>
<h4 id="slow-system-calls">Slow system calls<a class="headerlink" href="#slow-system-calls" title="Permanent link">&para;</a></h4>
<p>The system calls are divided into two categories: the "slow" system calls and all the others. The slow system calls are those that can block forever:</p>
<ul>
<li>Reads that can block the caller forever if data isn’t present with certain file types (pipes, terminal devices, and network devices)</li>
<li>Writes that can block the caller forever if the data can’t be accepted immediately by these same file types</li>
<li>Opens on certain file types that block the caller until some condition occurs (such as a terminal device open waiting until an attached modem answers the phone)</li>
<li>The <code>pause</code> function (which by definition puts the calling process to sleep until a signal is caught) and the <code>wait</code> function</li>
<li>Certain <code>ioctl</code> operations</li>
<li>Some of the interprocess communication functions</li>
</ul>
<p>The notable exception to these slow system calls is anything related to disk I/O. Although a read or a write of a disk file can block the caller temporarily (while the disk driver queues the request and then the request is executed), unless a hardware error occurs, the I/O operation always returns and unblocks the caller quickly.</p>
<p>Historically, POSIX.1 semantics gave implementations a choice of how to deal with <code>read</code>s and <code>write</code>s that have processed partial amounts of data, implementations derived from System V fail the system call, whereas BSD-derived implementations return partial success. With the 2001 version of the POSIX.1 standard, the BSD-style semantics are required. [p328]</p>
<p>The problem with interrupted system calls is that we now have to handle the error return explicitly. Assuming a read operation and assuming that we want to restart the read even if it’s interrupted, the typical code sequence would be:</p>
<div class="codehilite"><pre><span class="nl">again</span><span class="p">:</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">BUFFSIZE</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EINTR</span><span class="p">)</span>
            <span class="k">goto</span> <span class="n">again</span><span class="p">;</span> <span class="cm">/* just an interrupted system call */</span>
        <span class="cm">/* handle other errors */</span>
    <span class="p">}</span>
</pre></div>


<h4 id="automatic-restarts-of-interrupted-system-calls">Automatic restarts of interrupted system calls<a class="headerlink" href="#automatic-restarts-of-interrupted-system-calls" title="Permanent link">&para;</a></h4>
<p>Automatic restarting of certain interrupted system calls were introducted since 4.2BSD to prevent applications from having to handle interrupted system calls. The system calls that were automatically restarted are:</p>
<ul>
<li>Functions that are interrupted by a signal only if they are operating on a slow device:<ul>
<li><code>ioctl</code></li>
<li><code>read</code></li>
<li><code>readv</code></li>
<li><code>write</code></li>
<li><code>writev</code></li>
</ul>
</li>
<li>Functions that are always interrupted when a signal is caught.<ul>
<li><code>wait</code></li>
<li><code>waitpid</code></li>
</ul>
</li>
</ul>
<p>Some applications didn’t want the operation restarted if it was interrupted; 4.3BSD allowed the process to disable this feature on a per-signal basis.</p>
<h5 id="difference-between-the-signal-and-sigaction-functions-on-restarts">Difference between the <code>signal</code> and <code>sigaction</code> functions on restarts<a class="headerlink" href="#difference-between-the-signal-and-sigaction-functions-on-restarts" title="Permanent link">&para;</a></h5>
<p>POSIX.1 requires an implementation to restart system calls only when the <code>SA_RESTART</code> flag is in effect for the interrupting signal. This flag is used with the <code>sigaction</code> function to allow applications to request that interrupted system calls be restarted.</p>
<p>Historically, when using the <code>signal</code> function to establish a signal handler, implementations varied with respect to how interrupted system calls were handled. System V never restarted system calls by default. BSD, in contrast, restarted them if the calls were interrupted by signals. On FreeBSD 8.0, Linux 3.2.0, and Mac OS X 10.6.8, when signal handlers are installed with the <code>signal</code> function, interrupted system calls will be restarted. By using our own implementation of the <code>signal</code> function, we avoid having to deal with these differences. [p329]</p>
<p>One reason 4.2BSD introduced the automatic restart feature is that sometimes we don’t know that the input or output device is a slow device. [p329]</p>
<p>The figure below summarizes the signal functions and their semantics provided by the various implementations.</p>
<p><a href="../figure_10.3.png" title="Figure 10.3 Features provided by various signal implementations"><img alt="Figure 10.3 Features provided by various signal implementations" src="../figure_10.3.png" /></a></p>
<p>Later this chapter, we provide our own version of the <code>signal</code> function that automatically tries to restart interrupted system calls (other than for the <code>SIGALRM</code> signal), and <code>signal_intr</code>, that tries to never do the restart.</p>
<h3 id="reentrant-functions">Reentrant Functions<a class="headerlink" href="#reentrant-functions" title="Permanent link">&para;</a></h3>
<p>When a signal that is being caught is handled by a process, the normal sequence of instructions being executed by the process is temporarily interrupted by the signal handler. The process then continues executing, but the instructions in the signal handler are now executed. If the signal handler returns (instead of calling <code>exit</code> or <code>longjmp</code>), then the normal sequence of instructions that the process was executing when the signal was caught continues executing. This is similar to what happens when a hardware interrupt occurs.</p>
<p>However, in the signal handler, we can’t tell where the process was executing when the signal was caught:</p>
<ul>
<li>What if the process was in the middle of allocating additional memory on its heap using <code>malloc</code>, and we call <code>malloc</code> from the signal handler?<ul>
<li>Havoc can result for the process, since <code>malloc</code> usually maintains a linked list of all its allocated areas, and it may have been in the middle of changing this list.</li>
</ul>
</li>
<li>What if the process was in the middle of a call to a function, such as <code>getpwnam</code> (<a href="../ch6/#password-file">Section 6.2</a>), that stores its result in a static location, and we call the same function from the signal handler?<ul>
<li>The information returned to the normal caller can get overwritten with the information returned to the signal handler.</li>
</ul>
</li>
</ul>
<p>The Single UNIX Specification specifies the functions that are guaranteed to be safe to call from within a signal handler. These functions are reentrant and are called <strong>async-signal safe</strong> by the SUS. Besides being reentrant, they block any signals during operation if delivery of a signal might cause inconsistencies.</p>
<p>The following table lists these async-signal safe functions, which are reentrant functions that may be called from a signal handler.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>abort</code></td>
<td><code>faccessat</code></td>
<td><code>linkat</code></td>
<td><code>select</code></td>
<td><code>socketpair</code></td>
</tr>
<tr>
<td><code>accept</code></td>
<td><code>fchmod</code></td>
<td><code>listen</code></td>
<td><code>sem_post</code></td>
<td><code>stat</code></td>
</tr>
<tr>
<td><code>access</code></td>
<td><code>fchmodat</code></td>
<td><code>lseek</code></td>
<td><code>send</code></td>
<td><code>symlink</code></td>
</tr>
<tr>
<td><code>aio_error</code></td>
<td><code>fchown</code></td>
<td><code>lstat</code></td>
<td><code>sendmsg</code></td>
<td><code>symlinkat</code></td>
</tr>
<tr>
<td><code>aio_return</code></td>
<td><code>fchownat</code></td>
<td><code>mkdir</code></td>
<td><code>sendto</code></td>
<td><code>tcdrain</code></td>
</tr>
<tr>
<td><code>aio_suspend</code></td>
<td><code>fcntl</code></td>
<td><code>mkdirat</code></td>
<td><code>setgid</code></td>
<td><code>tcflow</code></td>
</tr>
<tr>
<td><code>alarm</code></td>
<td><code>fdatasync</code></td>
<td><code>mkfifo</code></td>
<td><code>setpgid</code></td>
<td><code>tcflush</code></td>
</tr>
<tr>
<td><code>bind</code></td>
<td><code>fexecve</code></td>
<td><code>mkfifoat</code></td>
<td><code>setsid</code></td>
<td><code>tcgetattr</code></td>
</tr>
<tr>
<td><code>cfgetispeed</code></td>
<td><code>fork</code></td>
<td><code>mknod</code></td>
<td><code>setsockopt</code></td>
<td><code>tcgetpgrp</code></td>
</tr>
<tr>
<td><code>cfgetospeed</code></td>
<td><code>fstat</code></td>
<td><code>mknodat</code></td>
<td><code>setuid</code></td>
<td><code>tcsendbreak</code></td>
</tr>
<tr>
<td><code>cfsetispeed</code></td>
<td><code>fstatat</code></td>
<td><code>open</code></td>
<td><code>shutdown</code></td>
<td><code>tcsetattr</code></td>
</tr>
<tr>
<td><code>cfsetospeed</code></td>
<td><code>fsync</code></td>
<td><code>openat</code></td>
<td><code>sigaction</code></td>
<td><code>tcsetpgrp</code></td>
</tr>
<tr>
<td><code>chdir</code></td>
<td><code>ftruncate</code></td>
<td><code>pause</code></td>
<td><code>sigaddset</code></td>
<td><code>time</code></td>
</tr>
<tr>
<td><code>chmod</code></td>
<td><code>futimens</code></td>
<td><code>pipe</code></td>
<td><code>sigdelset</code></td>
<td><code>timer_getoverrun</code></td>
</tr>
<tr>
<td><code>chown</code></td>
<td><code>getegid</code></td>
<td><code>poll</code></td>
<td><code>sigemptyset</code></td>
<td><code>timer_gettime</code></td>
</tr>
<tr>
<td><code>clock_gettime</code></td>
<td><code>geteuid</code></td>
<td><code>posix_trace_event</code></td>
<td><code>sigfillset</code></td>
<td><code>timer_settime</code></td>
</tr>
<tr>
<td><code>close</code></td>
<td><code>getgid</code></td>
<td><code>pselect</code></td>
<td><code>sigismember</code></td>
<td><code>times</code></td>
</tr>
<tr>
<td><code>connect</code></td>
<td><code>getgroups</code></td>
<td><code>raise</code></td>
<td><code>signal</code></td>
<td><code>umask</code></td>
</tr>
<tr>
<td><code>creat</code></td>
<td><code>getpeername</code></td>
<td><code>read</code></td>
<td><code>sigpause</code></td>
<td><code>uname</code></td>
</tr>
<tr>
<td><code>dup</code></td>
<td><code>getpgrp</code></td>
<td><code>readlink</code></td>
<td><code>sigpending</code></td>
<td><code>unlink</code></td>
</tr>
<tr>
<td><code>dup2</code></td>
<td><code>getpid</code></td>
<td><code>readlinkat</code></td>
<td><code>sigprocmask</code></td>
<td><code>unlinkat</code></td>
</tr>
<tr>
<td><code>execl</code></td>
<td><code>getppid</code></td>
<td><code>recv</code></td>
<td><code>sigqueue</code></td>
<td><code>utime</code></td>
</tr>
<tr>
<td><code>execle</code></td>
<td><code>getsockname</code></td>
<td><code>recvfrom</code></td>
<td><code>sigset</code></td>
<td><code>utimensat</code></td>
</tr>
<tr>
<td><code>execv</code></td>
<td><code>getsockopt</code></td>
<td><code>recvmsg</code></td>
<td><code>sigsuspend</code></td>
<td><code>utimes</code></td>
</tr>
<tr>
<td><code>execve</code></td>
<td><code>getuid</code></td>
<td><code>rename</code></td>
<td><code>sleep</code></td>
<td><code>wait</code></td>
</tr>
<tr>
<td><code>_Exit</code></td>
<td><code>kill</code></td>
<td><code>renameat</code></td>
<td><code>sockatmark</code></td>
<td><code>waitpid</code></td>
</tr>
<tr>
<td><code>_exit</code></td>
<td><code>link</code></td>
<td><code>rmdir</code></td>
<td><code>socket</code></td>
<td><code>write</code></td>
</tr>
</tbody>
</table>
<p>Most of the functions that are not included in table above are missing because:</p>
<ul>
<li>They are known to use static data structures;</li>
<li>They call <code>malloc</code> or <code>free</code>;</li>
<li>They are part of the standard I/O library.</li>
</ul>
<p>Note when using the functions in the table above:</p>
<ul>
<li>Most implementations of the standard I/O library use global data structures in a nonreentrant way.</li>
<li>
<p>Be aware that even if we call a function listed in the table above from a signal handler, there is only one <code>errno</code> variable per thread (recall the discussion of errno and threads in <a href="../ch1/#error-handling">Section 1.7</a>), and we might potentially modify its value.</p>
<ul>
<li>Consider a signal handler that is invoked right after main has set <code>errno</code>. If the signal handler calls <code>read</code>, for example, this call can change the value of <code>errno</code>, wiping out the value that was just stored in <code>main</code>.</li>
</ul>
<p>Therefore, as a general rule, when calling the functions listed in the table above from a signal handler, we should save and restore <code>errno</code>. Be aware that a commonly caught signal is <code>SIGCHLD</code>, and its signal handler usually calls one of the wait functions. All the <code>wait</code> functions can change <code>errno</code>.</p>
</li>
<li>
<p><code>longjmp</code> (<a href="../ch7/#setjmp-and-longjmp-functions">Section 7.10</a>) and <code>siglongjmp</code> (<a href="#sigsetjmp-and-siglongjmp-functions">Section 10.15</a>) are missing
from the table because the signal may have occurred while the <code>main</code> routine was updating a data structure in a nonreentrant way. This data structure could be left half updated if we call <code>siglongjmp</code> instead of returning from the signal handler. If it is going to do such things as update global data structures, while catching signals that cause <code>sigsetjmp</code> to be executed, an application needs to block the signals while updating the data structures.</p>
</li>
</ul>
<h4 id="example-of-calling-getpwnam-from-a-signal-handler">Example of calling <code>getpwnam</code> from a signal handler *<a class="headerlink" href="#example-of-calling-getpwnam-from-a-signal-handler" title="Permanent link">&para;</a></h4>
<p>The code below shows a program that calls the nonreentrant function <code>getpwnam</code> from a signal handler that is called every second. We use the <code>alarm</code> function (<a href="../alarm-and-pause-functions">Section 10.10</a>) here to generate a <code>SIGALRM</code> signal every second.</p>
<p><small><a href="https://github.com/shichao-an/apue.3e/blob/master/signals/reenter.c">signals/reenter.c</a></small></p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&quot;apue.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;pwd.h&gt;</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">my_alarm</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">passwd</span>   <span class="o">*</span><span class="n">rootptr</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;in signal handler</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">rootptr</span> <span class="o">=</span> <span class="n">getpwnam</span><span class="p">(</span><span class="s">&quot;root&quot;</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;getpwnam(root) error&quot;</span><span class="p">);</span>
    <span class="n">alarm</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">passwd</span>   <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>

    <span class="n">signal</span><span class="p">(</span><span class="n">SIGALRM</span><span class="p">,</span> <span class="n">my_alarm</span><span class="p">);</span>
    <span class="n">alarm</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">getpwnam</span><span class="p">(</span><span class="s">&quot;sar&quot;</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;getpwnam error&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">pw_name</span><span class="p">,</span> <span class="s">&quot;sar&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">&quot;return value corrupted!, pw_name = %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
                    <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">pw_name</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>When this program was run, the results were random. Usually, the program would be terminated by a <code>SIGSEGV</code> signal when the signal handler returned after several iterations. An examination of the <code>core</code> file showed that the main function had called <code>getpwnam</code>, but that when <code>getpwnam</code> called <code>free</code>, the signal handler interrupted it and called <code>getpwnam</code>, which in turn called <code>free</code>. The data structures maintained by <code>malloc</code> and <code>free</code> had been corrupted when the signal handler (indirectly) called <code>free</code> while the main function was also calling <code>free</code>. Occasionally, the program would run for several seconds before crashing with a <code>SIGSEGV</code> error. When the main function did run correctly after the signal had been caught, the return value was sometimes corrupted and sometimes fine.</p>
<h3 id="sigcld-semantics"><code>SIGCLD</code> Semantics<a class="headerlink" href="#sigcld-semantics" title="Permanent link">&para;</a></h3>
<p>Two signals that continually generate confusion are <code>SIGCLD</code> and <code>SIGCHLD</code>. The name <code>SIGCLD</code> (without the <code>H</code>) is from System V, and this signal has different semantics from the BSD signal, named <code>SIGCHLD</code>. The POSIX.1 signal is also named <code>SIGCHLD</code>.</p>
<p>The semantics of the BSD <code>SIGCHLD</code> signal are normal and its semantics are similar to all other signals. When the signal occurs, the status of a child has changed, and we need to call one of the <code>wait</code> functions to determine what has happened.</p>
<p>System V, however, has traditionally handled the <code>SIGCLD</code> signal differently from other signals:</p>
<ol>
<li>If the process specifically sets its disposition to <code>SIG_IGN</code>, children of the calling process will not generate zombie processes. [p333]<ul>
<li>4.4BSD always generates zombies if <code>SIGCHLD</code> is ignored. If we want to avoid zombies, we have to <code>wait</code> for our children.</li>
</ul>
</li>
<li>If we set the disposition of <code>SIGCLD</code> to be caught, the kernel immediately checks whether any child processes are ready to be <code>wait</code>ed for and, if so, calls the <code>SIGCLD</code> handler. [p333-335]<ul>
<li>FreeBSD 8.0 and Mac OS X 10.6.8 don’t exhibit this problem, because BSD-based systems generally don’t support historical System V semantics for SIGCLD.</li>
<li>Linux 3.2.0 also doesn’t exhibit this problem, because it doesn’t call the <code>SIGCHLD</code> signal handler when a process arranges to catch <code>SIGCHLD</code> and child processes are ready to be waited for, even though <code>SIGCLD</code> and <code>SIGCHLD</code> are defined to be the same value.</li>
<li>Solaris avoids this problem by including extra code in the kernel.</li>
</ul>
</li>
</ol>
<p>Of the four platforms described in this text, only Linux 3.2.0 and Solaris 10 define <code>SIGCLD</code>. On these platforms, <code>SIGCLD</code> is equivalent to <code>SIGCHLD</code>.</p>
<h3 id="reliable-signal-terminology-and-semantics">Reliable-Signal Terminology and Semantics<a class="headerlink" href="#reliable-signal-terminology-and-semantics" title="Permanent link">&para;</a></h3>
<p>This section defines some terms used through the discussion of signals.</p>
<ul>
<li>A signal is <em>generated</em> for a process (or sent to a process) when the event that causes the signal occurs. When the signal is generated, the kernel usually sets a flag of some form in the process table. The event could be:<ul>
<li>Hardware exception (e.g., divide by 0),</li>
<li>Software condition (e.g., an alarm timer expiring),</li>
<li>Terminal-generated signal,</li>
<li>A call to the <code>kill</code> function.</li>
</ul>
</li>
<li>A signal is <em>delivered</em> to a process when the action for a signal is taken.</li>
<li>A signal is <em>pending</em> during the time between its generation and delivery.</li>
<li>
<p>A process has the option of <em>blocking</em> the delivery of a signal. If a signal that is blocked is generated for a process, and if the action for that signal is either the default action or to catch the signal, then the signal remains pending for the process until the process either:</p>
<ul>
<li>unblocks the signal, or</li>
<li>changes the action to ignore the signal.</li>
</ul>
<p>The system determines what to do with a blocked signal when the signal is delivered, not when it’s generated. This allows the process to change the action for the signal before it’s delivered. The <code>sigpending</code> function (<a href="#sigpending-function">Section 10.13</a>) can be called by a process to determine which signals are blocked and pending.</p>
</li>
</ul>
<p>POSIX.1 allows the system to deliver the signal either once or more than once in case a blocked signal is generated more than once before the process unblocks the signal. If the system delivers the signal more than once, we say that the signals are <em>queued</em>. Most UNIX systems, however, do not queue signals unless they support the real-time extensions to POSIX.1. Instead, the UNIX kernel simply delivers the signal once. [p336]</p>
<p><a href="#sigqueue-function">Section 10.20</a> discusses queueing signals further.</p>
<p>POSIX.1 does not specify the order in which the signals are delivered to the process. The Rationale for POSIX.1 does suggest, however, that signals related to the current state of the process be delivered before other signals. (<code>SIGSEGV</code> is one such signal.)</p>
<p>Each process has a <strong>signal mask</strong> that defines the set of signals currently blocked from delivery to that process. This mask has one bit for each possible signal. If the bit is on for a given signal, that signal is currently blocked. A process can examine and change its current signal mask by calling <code>sigprocmask</code> (<a href="#sigprocmask-function">Section 10.12</a>). Since it is possible for the number of signals to exceed the number of bits in an integer, POSIX.1 defines a data type, called <code>sigset_t</code>, that holds a <strong>signal set</strong>. The signal mask is stored in one of these signal sets. The five functions that operate on signal sets are described in <a href="#signal-sets">Section 10.11</a>.</p>
<h3 id="kill-and-raise-functions"><code>kill</code> and <code>raise</code> Functions<a class="headerlink" href="#kill-and-raise-functions" title="Permanent link">&para;</a></h3>
<ul>
<li>The <code>kill</code> function sends a signal to a process or a group of processes.</li>
<li>The <code>raise</code> function allows a process to send a signal to itself.<ul>
<li>The <code>raise</code> function was originally defined by ISO C. POSIX.1 includes it to align itself with the ISO C standard, but POSIX.1 extends the specification of raise to deal with threads. Since ISO C does not deal with multiple processes, it could not define a function, such as <code>kill</code>, that requires a process ID argument.</li>
</ul>
</li>
</ul>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">kill</span><span class="p">(</span><span class="kt">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">signo</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">raise</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">);</span>

<span class="cm">/* Both return: 0 if OK, −1 on error */</span>
</pre></div>


<p>The call:</p>
<div class="codehilite"><pre><span class="n">raise</span><span class="p">(</span><span class="n">signo</span><span class="p">);</span>
</pre></div>


<p>is equivalent to the call:</p>
<div class="codehilite"><pre><span class="n">kill</span><span class="p">(</span><span class="n">getpid</span><span class="p">(),</span> <span class="n">signo</span><span class="p">);</span>
</pre></div>


<p>There are four different conditions for the <em>pid</em> argument to kill:</p>
<ul>
<li><code>pid</code> &gt; 0. The signal is sent to the process whose process ID is <code>pid</code>.</li>
<li><code>pid</code> == 0 The signal is sent to all processes whose process group ID equals the process group ID of the sender and for which the sender has permission to send the signal.</li>
<li><code>pid</code> &lt; 0. The signal is sent to all processes whose process group ID equals the absolute value of <code>pid</code> and for which the sender has permission to send the signal.</li>
<li><code>pid</code> == −1. The signal is sent to all processes on the system for which the sender has permission to send the signal.</li>
</ul>
<p>Note that the term <em>all processes</em> in the four conditions above excludes an implementation-defined set of system processes, including kernel processes and <code>init</code> (pid 1).</p>
<p>A process needs permission to send a signal to another process:</p>
<ul>
<li>The superuser can send a signal to any process.</li>
<li>For other users, the real or effective user ID of the sender has to equal the real or effective user ID of the receiver. If the implementation supports <code>_POSIX_SAVED_IDS</code>, the saved set-user-ID of the receiver is checked instead of its effective user ID.</li>
<li>One special case for the permission testing also exists: if the signal being sent is <code>SIGCONT</code>,aprocess can send it to any other process in the same session.</li>
</ul>
<p>Some other notes on the <code>kill</code> function:</p>
<ul>
<li>POSIX.1 defines signal number 0 as the null signal. If the <em>signo</em> argument is 0, then the normal error checking is performed by <code>kill</code>, but no signal is sent. This technique is often used to determine if a specific process still exists. If we send the process the null signal and it doesn’t exist, <code>kill</code> returns −1 and <code>errno</code> is set to <code>ESRCH</code>. Be aware, however, that UNIX systems recycle process IDs after some amount of time, so the existence of a process with a given process ID does not necessarily mean that it’s the process that you think it is.</li>
<li>The test for process existence is not atomic. By the time that <code>kill</code> returns the answer to the caller, the process in question might have exited, so the answer is of limited value.</li>
<li>If the call to <code>kill</code> causes the signal to be generated for the calling process and if the signal is not blocked, either <em>signo</em> or some other pending, unblocked signal is delivered to the process before <code>kill</code> returns. For additional conditions that occur with threads, see <a href="../ch12/#threads-and-signals">Section 12.8</a>.</li>
</ul>
<h3 id="alarm-and-pause-functions"><code>alarm</code> and <code>pause</code> Functions<a class="headerlink" href="#alarm-and-pause-functions" title="Permanent link">&para;</a></h3>
<p>The <code>alarm</code> function sets a timer that will expire at a specified time in the future. When the timer expires, the <code>SIGALRM</code> signal is generated. If we ignore or don’t catch this signal, its default action is to terminate the process.</p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">alarm</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">seconds</span><span class="p">);</span>

<span class="cm">/* Returns: 0 or number of seconds until previously set alarm */</span>
</pre></div>


<ul>
<li>The <em>seconds</em> value is the number of clock seconds in the future when the signal should be generated. When that time occurs, the signal is generated by the kernel, although additional time could elapse before the process gets control to handle the signal, because of processor scheduling delays.</li>
<li>There is only one of these alarm clocks per process. If <code>alarm</code> is called with a previously registered alarm clock not yet expired, then:<ul>
<li>The number of seconds left for previous alarm clock is returned as the value of this function.</li>
<li>The previous alarm clock is replaced by the new value.</li>
</ul>
</li>
<li>If a previously registered alarm clock for the process has not yet expired and if the seconds value is 0, the previous alarm clock is canceled. The number of seconds left for that previous alarm clock is still returned as the value of the function.</li>
</ul>
<p>Although the default action for <code>SIGALRM</code> is to terminate the process, most processes that use an alarm clock catch this signal, which can perform whatever cleanup is required before terminating if the process wants to terminate. <u>If we intend to catch <code>SIGALRM</code>, we need to be careful to install its signal handler before calling <code>alarm</code>. If we call <code>alarm</code> first and are sent <code>SIGALRM</code> before we can install the signal handler, our process will terminate.</u></p>
<p>The <code>pause</code> function suspends the calling process until a signal is caught.</p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">pause</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Returns: −1 with errno set to EINTR */</span>
</pre></div>


<p>The only time <code>pause</code> returns is if a signal handler is executed and that handler returns. In that case, <code>pause</code> returns −1 with <code>errno</code> set to <code>EINTR</code>.</p>
<h4 id="sleep1-example"><code>sleep1</code> example<a class="headerlink" href="#sleep1-example" title="Permanent link">&para;</a></h4>
<p>Using <code>alarm</code> and <code>pause</code>, we can put a process to sleep for a specified amount of time. The following implementation of <code>sleep1</code> is incomplete and has problems:</p>
<p><small><a href="https://github.com/shichao-an/apue.3e/blob/master/signals/sleep1.c">signals/sleep1.c</a></small></p>
<div class="codehilite"><pre><span class="cp">#include</span>    <span class="cpf">&lt;signal.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span>    <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sig_alrm</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* nothing to do, just return to wake up the pause */</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">sleep1</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">seconds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">signal</span><span class="p">(</span><span class="n">SIGALRM</span><span class="p">,</span> <span class="n">sig_alrm</span><span class="p">)</span> <span class="o">==</span> <span class="n">SIG_ERR</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="n">seconds</span><span class="p">);</span>
    <span class="n">alarm</span><span class="p">(</span><span class="n">seconds</span><span class="p">);</span>     <span class="cm">/* start the timer */</span>
    <span class="n">pause</span><span class="p">();</span>            <span class="cm">/* next caught signal wakes us up */</span>
    <span class="k">return</span><span class="p">(</span><span class="n">alarm</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>   <span class="cm">/* turn off timer, return unslept time */</span>
<span class="p">}</span>
</pre></div>


<p>This simple implementation has three problems:</p>
<ol>
<li><strong>If the caller already has an alarm set, that alarm is erased by the first call to <code>alarm</code>.</strong> We can correct this by looking at <code>alarm</code>’s return value:<ul>
<li>If the number of seconds until some previously set alarm is less than the argument, then we should wait only until the existing alarm expires.</li>
<li>If the previously set alarm will go off after ours, then before returning we should reset this alarm to occur at its designated time in the future.</li>
</ul>
</li>
<li><strong>We have modified the disposition for <code>SIGALRM</code>.</strong> If we’re writing a function for others to call, we should save the disposition when our function is called and restore it when we’re done. We can correct this by saving the return value from <code>signal</code> and resetting the disposition before our function returns.</li>
<li><strong>There is a race condition between the first call to <code>alarm</code> and the call to <code>pause</code></strong>.  On a busy system, it’s possible for the alarm to go off and the signal handler to be called before we call pause. If that happens, the caller is suspended forever in the call to <code>pause</code> (assuming that some other signal isn’t caught).</li>
</ol>
<h4 id="sleep2-example-using-setjmp-and-longjmp"><code>sleep2</code> example: using <code>setjmp</code> and <code>longjmp</code><a class="headerlink" href="#sleep2-example-using-setjmp-and-longjmp" title="Permanent link">&para;</a></h4>
<p>The following example corrects problem 3 as described above using <code>setjmp</code>. The problem 3 can also be corrected using <code>sigprocmask</code> and <code>sigsuspend</code>, as described in <a href="#sleep-nanosleep-and-clock_nanosleep-functions">Section 10.19</a>.</p>
<p><small><a href="https://github.com/shichao-an/apue.3e/blob/master/signals/sleep2.c">signals/sleep2.c</a></small></p>
<div class="codehilite"><pre><span class="cp">#include</span>    <span class="cpf">&lt;setjmp.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span>    <span class="cpf">&lt;signal.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span>    <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">jmp_buf</span>  <span class="n">env_alrm</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sig_alrm</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">longjmp</span><span class="p">(</span><span class="n">env_alrm</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">sleep2</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">seconds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">signal</span><span class="p">(</span><span class="n">SIGALRM</span><span class="p">,</span> <span class="n">sig_alrm</span><span class="p">)</span> <span class="o">==</span> <span class="n">SIG_ERR</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="n">seconds</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">setjmp</span><span class="p">(</span><span class="n">env_alrm</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">alarm</span><span class="p">(</span><span class="n">seconds</span><span class="p">);</span>     <span class="cm">/* start the timer */</span>
        <span class="n">pause</span><span class="p">();</span>            <span class="cm">/* next caught signal wakes us up */</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">(</span><span class="n">alarm</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>       <span class="cm">/* turn off timer, return unslept time */</span>
<span class="p">}</span>
</pre></div>


<p>The <code>sleep2</code> function avoids the race condition. Even if the <code>pause</code> is never executed, the <code>sleep2</code> function returns when the <code>SIGALRM</code> occurs.</p>
<h4 id="sleep2s-interaction-with-other-signals"><code>sleep2</code>'s interaction with other signals<a class="headerlink" href="#sleep2s-interaction-with-other-signals" title="Permanent link">&para;</a></h4>
<p>There is another subtle problem with the <code>sleep2</code> function involving its interaction with other signals. If the <code>SIGALRM</code> interrupts some other signal handler, then when we call <code>longjmp</code>, we abort the other signal handler, as shown in the following code:</p>
<p><small><a href="https://github.com/shichao-an/apue.3e/blob/master/signals/tsleep2.c">signals/tsleep2.c</a></small></p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&quot;apue.h&quot;</span><span class="cp"></span>

<span class="kt">unsigned</span> <span class="kt">int</span>    <span class="nf">sleep2</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>     <span class="nf">sig_int</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>    <span class="n">unslept</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">sig_int</span><span class="p">)</span> <span class="o">==</span> <span class="n">SIG_ERR</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;signal(SIGINT) error&quot;</span><span class="p">);</span>
    <span class="n">unslept</span> <span class="o">=</span> <span class="n">sleep2</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sleep2 returned: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">unslept</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sig_int</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span>             <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
    <span class="k">volatile</span> <span class="kt">int</span>    <span class="n">k</span><span class="p">;</span>
<span class="cm">/*</span>
<span class="cm">     * Tune these loops to run for more than 5 seconds</span>
<span class="cm">     * on whatever system this test program is run.</span>
<span class="cm">     */</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">sig_int starting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">300000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">4000</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">j</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sig_int finished</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>The loop in the <code>SIGINT</code> handler was written so that it executes for longer than 5 seconds on one of the systems used by the author. We simply want it to execute longer than the argument to <code>sleep2</code>. The integer <code>k</code> is declared as <code>volatile</code> to prevent an optimizing compiler from discarding the loop.</p>
<p>Run this program and interrupt the sleep by typing the interrupt character:</p>
<div class="codehilite"><pre><span class="gp">$</span> ./a.out
<span class="go">ˆC                 # we type the interrupt character</span>
<span class="go">sig_int starting</span>
<span class="go">sleep2 returned: 0</span>
</pre></div>


<p>The <code>longjmp</code> from the <code>sleep2</code> function aborted the other signal handler, <code>sig_int</code>, even though it wasn’t finished.</p>
<p>The above examples of <code>sleep1</code> and <code>sleep2</code> show the pitfalls in dealing naively with signals. The following sections will show ways around all these problems, so we can handle signals reliably, without interfering with other pieces of code.</p>
<h4 id="implementing-a-timeout-using-alarm">Implementing a timeout using <code>alarm</code><a class="headerlink" href="#implementing-a-timeout-using-alarm" title="Permanent link">&para;</a></h4>
<p>A common use for <code>alarm</code>, in addition to implementing the <code>sleep</code> function, is to put an upper time limit on operations that can block. For example, if we have a <code>read</code> operation on a device that can block (slow device, as described in <a href="#interrupted-system-calls">Section 10.5</a>), we might want the <code>read</code> to time out after some amount of time. The following example reads one line from standard input (with a timeout) and writes it to standard.</p>
<p><small><a href="https://github.com/shichao-an/apue.3e/blob/master/signals/read1.c">signals/read1.c</a></small></p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&quot;apue.h&quot;</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sig_alrm</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span>     <span class="n">n</span><span class="p">;</span>
    <span class="kt">char</span>    <span class="n">line</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">signal</span><span class="p">(</span><span class="n">SIGALRM</span><span class="p">,</span> <span class="n">sig_alrm</span><span class="p">)</span> <span class="o">==</span> <span class="n">SIG_ERR</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;signal(SIGALRM) error&quot;</span><span class="p">);</span>

    <span class="n">alarm</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">STDIN_FILENO</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;read error&quot;</span><span class="p">);</span>
    <span class="n">alarm</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="n">write</span><span class="p">(</span><span class="n">STDOUT_FILENO</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sig_alrm</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* nothing to do, just return to interrupt the read */</span>
<span class="p">}</span>
</pre></div>


<p>Though this code is common in UNIX applications, it has two problems:</p>
<ol>
<li>There is a a race condition between the first call to <code>alarm</code> and the call to <code>read</code>, similar to the first <code>alarm</code> and <code>pause</code> example in <a href="##sleep1-example">early this section</a>. If the kernel blocks the process between these two function calls for longer than the alarm period, the <code>read</code> could block forever, though most operations of this type use a long alarm period (a minute or more) making this unlikely.</li>
<li>If system calls are automatically restarted, the <code>read</code> is not interrupted when the <code>SIGALRM</code> signal handler returns. In this case, the timeout does nothing.</li>
</ol>
<h4 id="implementing-a-timeout-with-alarm-and-longjmp">Implementing a timeout with <code>alarm</code> and <code>longjmp</code><a class="headerlink" href="#implementing-a-timeout-with-alarm-and-longjmp" title="Permanent link">&para;</a></h4>
<p><small><a href="https://github.com/shichao-an/apue.3e/blob/master/signals/read2.c">signals/read2.c</a></small></p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&quot;apue.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;setjmp.h&gt;</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span>     <span class="nf">sig_alrm</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">jmp_buf</span>  <span class="n">env_alrm</span><span class="p">;</span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span>     <span class="n">n</span><span class="p">;</span>
    <span class="kt">char</span>    <span class="n">line</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">signal</span><span class="p">(</span><span class="n">SIGALRM</span><span class="p">,</span> <span class="n">sig_alrm</span><span class="p">)</span> <span class="o">==</span> <span class="n">SIG_ERR</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;signal(SIGALRM) error&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">setjmp</span><span class="p">(</span><span class="n">env_alrm</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_quit</span><span class="p">(</span><span class="s">&quot;read timeout&quot;</span><span class="p">);</span>

    <span class="n">alarm</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">STDIN_FILENO</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;read error&quot;</span><span class="p">);</span>
    <span class="n">alarm</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="n">write</span><span class="p">(</span><span class="n">STDOUT_FILENO</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sig_alrm</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">longjmp</span><span class="p">(</span><span class="n">env_alrm</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>This version works as expected, regardless of whether the system restarts interrupted system calls. However, we still have the problem of interactions with other signal handlers, <a href="#sleep2s-interaction-with-other-signals">as described previously</a>.</p>
<p>If we want to set a time limit on an I/O operation, we need to use <code>longjmp</code>, as shown previously, while recognizing its possible interaction with other signal handlers. Another option is to use the <code>select</code> or <code>poll</code> functions described in <a href="../io-multiplexing">Section 14.4</a>.</p>
<h3 id="signal-sets">Signal Sets<a class="headerlink" href="#signal-sets" title="Permanent link">&para;</a></h3>
<p>A <strong>signal set</strong> is a data type to represent multiple signals. This data type is used with functions like <code>sigprocmask</code> to tell the kernel not to allow any of the signals in the set to occur. As mentioned earlier, the number of different signals can exceed the number of bits in an integer, so in general we can’t use an integer to represent the set with one bit per signal.</p>
<p>POSIX.1 defines the data type <code>sigset_t</code> to contain a signal set and the following five functions to manipulate signal sets.</p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">sigemptyset</span><span class="p">(</span><span class="kt">sigset_t</span> <span class="o">*</span><span class="n">set</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">sigfillset</span><span class="p">(</span><span class="kt">sigset_t</span> <span class="o">*</span><span class="n">set</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">sigaddset</span><span class="p">(</span><span class="kt">sigset_t</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="kt">int</span> <span class="n">signo</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">sigdelset</span><span class="p">(</span><span class="kt">sigset_t</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="kt">int</span> <span class="n">signo</span><span class="p">);</span>

<span class="cm">/* All four return: 0 if OK, −1 on error */</span>

<span class="kt">int</span> <span class="nf">sigismember</span><span class="p">(</span><span class="k">const</span> <span class="kt">sigset_t</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="kt">int</span> <span class="n">signo</span><span class="p">);</span>
<span class="cm">/* Returns: 1 if true, 0 if false, −1 on error */</span>
</pre></div>


<ul>
<li><code>sigemptyset</code> initializes the signal set pointed to by <em>set</em> so that all signals are excluded.</li>
<li><code>sigfillset</code> initializes the signal set so that all signals are included.</li>
<li><code>sigaddset</code> adds a single signal to an existing set.</li>
<li><code>sigdelset</code> removes a single signal from a set.</li>
</ul>
<p>All applications have to call either <code>sigemptyset</code> or <code>sigfillset</code> once for each signal set, before using the signal set, because we cannot assume that the C initialization for external and static variables (0) corresponds to the implementation of signal sets on a given system.</p>
<p>In all the functions that take a signal set as an argument, we always pass the address of the signal set as the argument.</p>
<h4 id="implementation-of-signal-sets">Implementation of signal sets<a class="headerlink" href="#implementation-of-signal-sets" title="Permanent link">&para;</a></h4>
<p>If the implementation has fewer signals than bits in an integer,asignal set can be implemented using one bit per signal. This section assumes that an implementation has 31 signals and 32-bit integers. The <code>sigemptyset</code> function zeros the integer, and the <code>sigfillset</code> function turns on all the bits in the integer. These two functions can be implemented as macros in the <code>&lt;signal.h&gt;</code> header:</p>
<div class="codehilite"><pre><span class="cp">#define sigemptyset(ptr) (*(ptr) = 0)</span>
<span class="cp">#define sigfillset(ptr) (*(ptr) = ~(sigset_t)0, 0)</span>
</pre></div>


<p>Note that <u><code>sigfillset</code> must return 0, in addition to setting all the bits on in the signal set, so we use C’s comma operator, which returns the value after the comma as the value of the expression.</u></p>
<p>Using this implementation, <code>sigaddset</code> turns on a single bit and <code>sigdelset</code> turns off a single bit; <code>sigismember</code> tests a certain bit. Since no signal is ever numbered 0, we subtract 1 from the signal number to obtain the bit to manipulate.</p>
<p><small><a href="https://github.com/shichao-an/apue.3e/blob/master/signals/setops.c">signals/setops.c</a></small></p>
<div class="codehilite"><pre><span class="cp">#include</span>    <span class="cpf">&lt;signal.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span>    <span class="cpf">&lt;errno.h&gt;</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * &lt;signal.h&gt; usually defines NSIG to include signal number 0.</span>
<span class="cm"> */</span>
<span class="cp">#define SIGBAD(signo)   ((signo) &lt;= 0 || (signo) &gt;= NSIG)</span>

<span class="kt">int</span>
<span class="nf">sigaddset</span><span class="p">(</span><span class="kt">sigset_t</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="kt">int</span> <span class="n">signo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">SIGBAD</span><span class="p">(</span><span class="n">signo</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">errno</span> <span class="o">=</span> <span class="n">EINVAL</span><span class="p">;</span>
        <span class="k">return</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="o">*</span><span class="n">set</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">signo</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>       <span class="cm">/* turn bit on */</span>
    <span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">sigdelset</span><span class="p">(</span><span class="kt">sigset_t</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="kt">int</span> <span class="n">signo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">SIGBAD</span><span class="p">(</span><span class="n">signo</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">errno</span> <span class="o">=</span> <span class="n">EINVAL</span><span class="p">;</span>
        <span class="k">return</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="o">*</span><span class="n">set</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">signo</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>    <span class="cm">/* turn bit off */</span>
    <span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">sigismember</span><span class="p">(</span><span class="k">const</span> <span class="kt">sigset_t</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="kt">int</span> <span class="n">signo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">SIGBAD</span><span class="p">(</span><span class="n">signo</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">errno</span> <span class="o">=</span> <span class="n">EINVAL</span><span class="p">;</span>
        <span class="k">return</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">((</span><span class="o">*</span><span class="n">set</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">signo</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<h3 id="sigprocmask-function"><code>sigprocmask</code> Function<a class="headerlink" href="#sigprocmask-function" title="Permanent link">&para;</a></h3>
<p>As discussed in <a href="#reliable-signal-terminology-and-semantics">Section 10.8</a>, the signal mask of a process is the set of signals currently blocked from delivery to that process. A process can examine its signal mask, change its signal mask, or perform both operations in one step by calling the following function.</p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">sigprocmask</span><span class="p">(</span><span class="kt">int</span> <span class="n">how</span><span class="p">,</span> <span class="k">const</span> <span class="kt">sigset_t</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">set</span><span class="p">,</span>
                <span class="kt">sigset_t</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">oset</span><span class="p">);</span>

<span class="cm">/* Returns: 0 if OK, −1 on error */</span>
</pre></div>


<ul>
<li>If <em>oset</em> is a non-null pointer, the current signal mask for the process is returned through <em>oset</em>.</li>
<li>If <em>set</em> is a non-null pointer, the <em>how</em> argument indicates how the current signal mask is modified; if <em>set</em> is a null pointer, the signal mask of the process is not changed, and <em>how</em> is ignored.</li>
<li>
<p>The <em>how</em> argument is one in the following table:</p>
<table>
<thead>
<tr>
<th><em>how</em></th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SIG_BLOCK</code></td>
<td>The new signal mask for the process is the union of its current signal mask and the signal set pointed to by <em>set</em>. That is, <em>set</em> contains the additional signals that we want to block.</td>
</tr>
<tr>
<td><code>SIG_UNBLOCK</code></td>
<td>The new signal mask for the process is the intersection of its current signal mask and the complement of the signal set pointed to by <em>set</em>. That is, <em>set</em> contains the signals that we want to unblock.</td>
</tr>
<tr>
<td><code>SIG_SETMASK</code></td>
<td>The new signal mask for the process is replaced by the value of the signal set pointed to by <em>set</em>.</td>
</tr>
</tbody>
</table>
</li>
</ul>
<p>After calling <code>sigprocmask</code>, if any unblocked signals are pending, at least one of these signals is delivered to the process before <code>sigprocmask</code> returns.</p>
<p>Note that the <code>sigprocmask</code> function is defined only for single-threaded processes. A separate function, discussed in <a href="../ch12/#threads-and-signals">Section 12.8</a> is provided to manipulate a thread’s signal mask in a multithreaded process.</p>
<p>The following example shows a function that prints the names of the signals in the signal mask of the calling process.</p>
<p><small><a href="https://github.com/shichao-an/apue.3e/blob/master/lib/prmask.c">lib/prmask.c</a></small></p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&quot;apue.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;errno.h&gt;</span><span class="cp"></span>

<span class="kt">void</span>
<span class="nf">pr_mask</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">sigset_t</span>    <span class="n">sigset</span><span class="p">;</span>
    <span class="kt">int</span>         <span class="n">errno_save</span><span class="p">;</span>

    <span class="n">errno_save</span> <span class="o">=</span> <span class="n">errno</span><span class="p">;</span>     <span class="cm">/* we can be called by signal handlers */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sigprocmask</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigset</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">err_ret</span><span class="p">(</span><span class="s">&quot;sigprocmask error&quot;</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sigismember</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sigset</span><span class="p">,</span> <span class="n">SIGINT</span><span class="p">))</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">&quot; SIGINT&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sigismember</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sigset</span><span class="p">,</span> <span class="n">SIGQUIT</span><span class="p">))</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">&quot; SIGQUIT&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sigismember</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sigset</span><span class="p">,</span> <span class="n">SIGUSR1</span><span class="p">))</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">&quot; SIGUSR1&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sigismember</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sigset</span><span class="p">,</span> <span class="n">SIGALRM</span><span class="p">))</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">&quot; SIGALRM&quot;</span><span class="p">);</span>

        <span class="cm">/* remaining signals can go here  */</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">errno</span> <span class="o">=</span> <span class="n">errno_save</span><span class="p">;</span>     <span class="cm">/* restore errno */</span>
<span class="p">}</span>
</pre></div>


<h3 id="sigpending-function"><code>sigpending</code> Function<a class="headerlink" href="#sigpending-function" title="Permanent link">&para;</a></h3>
<p>The <code>sigpending</code> function returns the set of signals that are blocked from delivery and currently pending for the calling process. The set of signals is returned through the <em>set</em> argument.</p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">sigpending</span><span class="p">(</span><span class="kt">sigset_t</span> <span class="o">*</span><span class="n">set</span><span class="p">);</span>

<span class="cm">/* Returns: 0 if OK, −1 on error */</span>
</pre></div>


<h4 id="example-of-sigpending-and-other-signal-features">Example of <code>sigpending</code> and other signal features<a class="headerlink" href="#example-of-sigpending-and-other-signal-features" title="Permanent link">&para;</a></h4>
<p>The example below shows many of the signal features that have been described.</p>
<p><small><a href="https://github.com/shichao-an/apue.3e/blob/master/signals/critical.c">signals/critical.c</a></small></p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&quot;apue.h&quot;</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sig_quit</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">sigset_t</span>    <span class="n">newmask</span><span class="p">,</span> <span class="n">oldmask</span><span class="p">,</span> <span class="n">pendmask</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">signal</span><span class="p">(</span><span class="n">SIGQUIT</span><span class="p">,</span> <span class="n">sig_quit</span><span class="p">)</span> <span class="o">==</span> <span class="n">SIG_ERR</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;can&#39;t catch SIGQUIT&quot;</span><span class="p">);</span>

    <span class="cm">/*</span>
<span class="cm">     * Block SIGQUIT and save current signal mask.</span>
<span class="cm">     */</span>
    <span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newmask</span><span class="p">);</span>
    <span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newmask</span><span class="p">,</span> <span class="n">SIGQUIT</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_BLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newmask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldmask</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;SIG_BLOCK error&quot;</span><span class="p">);</span>

    <span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>   <span class="cm">/* SIGQUIT here will remain pending */</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">sigpending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pendmask</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;sigpending error&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sigismember</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pendmask</span><span class="p">,</span> <span class="n">SIGQUIT</span><span class="p">))</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">SIGQUIT pending</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

    <span class="cm">/*</span>
<span class="cm">     * Restore signal mask which unblocks SIGQUIT.</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_SETMASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldmask</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;SIG_SETMASK error&quot;</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;SIGQUIT unblocked</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

    <span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>   <span class="cm">/* SIGQUIT here will terminate with core file */</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sig_quit</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;caught SIGQUIT</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">signal</span><span class="p">(</span><span class="n">SIGQUIT</span><span class="p">,</span> <span class="n">SIG_DFL</span><span class="p">)</span> <span class="o">==</span> <span class="n">SIG_ERR</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;can&#39;t reset SIGQUIT&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>Run this program:</p>
<div class="codehilite"><pre><span class="gp">$</span> ./a.out
<span class="go">ˆ\                    # generate signal once (before 5 seconds are up)</span>
<span class="go">SIGQUIT               # pending after return from sleep</span>
<span class="go">caught SIGQUIT        # in signal handler</span>
<span class="go">SIGQUIT unblocked     # after return from sigprocmask</span>
<span class="go">ˆ\Quit(coredump)      # generate signal again</span>
<span class="gp">$</span> ./a.out
<span class="go">ˆ\ˆ\ˆ\ˆ\ˆ\ˆ\ˆ\ˆ\ˆ\ˆ\  # generate signal 10 times (before 5 seconds are up)</span>
<span class="go">SIGQUIT pending</span>
<span class="go">caught SIGQUIT        # signal is generated only once</span>
<span class="go">SIGQUIT unblocked</span>
<span class="go">ˆ\Quit(coredump)      # generate signal again</span>
</pre></div>


<p>[p349]</p>
<p>Some notes from this example:</p>
<ul>
<li>We saved the old mask when we blocked the signal. To unblock the signal, we did a <code>SIG_SETMASK</code> of the old mask. Alternatively, we could <code>SIG_UNBLOCK</code> only the signal that we had blocked. Be aware, however, if we write a function that can be called by others and if we need to block a signal in our function, we can’t use <code>SIG_UNBLOCK</code> to unblock the signal. In this case, we have to use <code>SIG_SETMASK</code> and restore the signal mask to its prior value, because it’s possible that the caller had specifically blocked this signal before calling our function. We’ll see an example of this in the <code>system</code> function in <a href="#system-function">Section 10.18</a>.</li>
<li>When we run the program the second time, we generate the quit signal ten times while the process is asleep, yet the signal is delivered only once to the process when it’s unblocked. This demonstrates that signals are not queued on this system</li>
</ul>
<h3 id="sigaction-function"><code>sigaction</code> Function<a class="headerlink" href="#sigaction-function" title="Permanent link">&para;</a></h3>
<p>The <code>sigaction</code> function allows us to examine or modify (or both) the action associated with a particular signal. This function supersedes the <code>signal</code> function from earlier releases of the UNIX System. Indeed, at the end of this section, we show an implementation of <code>signal</code> using <code>sigaction</code>.</p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">sigaction</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sigaction</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">act</span><span class="p">,</span>
              <span class="k">struct</span> <span class="n">sigaction</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">oact</span><span class="p">);</span>

<span class="cm">/* Returns: 0 if OK, −1 on error */</span>
</pre></div>


<ul>
<li>The argument <em>signo</em> is the signal number whose action we are examining or modifying.</li>
<li>If the <em>act</em> pointer is non-null, we are modifying the action.</li>
<li>If the <em>oact</em> pointer is non-null, the system returns the previous action for the signal through the <em>oact</em> pointer</li>
</ul>
<p>This function uses the following structure:</p>
<div class="codehilite"><pre><span class="k">struct</span> <span class="n">sigaction</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">sa_handler</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>  <span class="cm">/* addr of signal handler, */</span>
                              <span class="cm">/* or SIG_IGN, or SIG_DFL */</span>
    <span class="kt">sigset_t</span> <span class="n">sa_mask</span><span class="p">;</span>         <span class="cm">/* additional signals to block */</span>
    <span class="kt">int</span> <span class="n">sa_flags</span><span class="p">;</span>             <span class="cm">/* signal options, Figure 10.16 */</span>

    <span class="cm">/* alternate handler */</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">sa_sigaction</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">siginfo_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>


<p>If the <code>sa_handler</code> field contains the address of a signal-catching function (rather than <code>SIG_IGN</code> or <code>SIG_DFL</code>), then the <code>sa_mask</code> field specifies a set of signals that are added to the signal mask of the process before the signal-catching function is called. If and when the signal-catching function returns, the signal mask of the process is reset to its previous value. This enables us to block certain signals whenever a signal handler is invoked. <u>The operating system includes the signal being delivered in the signal mask when the handler is invoked. Hence, we are guaranteed that whenever we are processing a given signal, another occurrence of that same signal is blocked until we’re finished processing the first occurrence.</u> Additional occurrences of the same signal are usually not queued (<a href="#reliable-signal-terminology-and-semantics">Section 10.8</a>). If the signal occurs five times while it is blocked, when we unblock the signal, the signal-handling function for that signal will usually be invoked only one time.</p>
<p>Once we install an action for a given signal, that action remains installed until we explicitly change it by calling <code>sigaction</code>. [p350]</p>
<p>The <code>sa_flags</code> field of the act structure specifies various options for the handling of this signal. The table below details the meaning of these options when set.</p>
<p>The <code>sa_sigaction</code> field is an alternative signal handler used when the <code>SA_SIGINFO</code> flag is used with <code>sigaction</code>. Implementations might use the same storage for both the <code>sa_sigaction</code> field and the <code>sa_handler</code> field, so applications can use only one of these fields at a time.</p>
<p>Option flags (<code>sa_flags</code>) for the handling of each signal:</p>
<table>
<thead>
<tr>
<th>Option</th>
<th>SUS</th>
<th>FreeBSD</th>
<th>Linux</th>
<th>Mac OS X</th>
<th>Solaris</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SA_INTERRUPT</code></td>
<td></td>
<td></td>
<td>x</td>
<td></td>
<td></td>
<td>System calls interrupted by this signal are not automatically restarted (the XSI default for <code>sigaction</code>). See <a href="#interrupted-system-calls">Section 10.5</a>.</td>
</tr>
<tr>
<td><code>SA_NOCLDSTOP</code></td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>If <em>signo</em> is <code>SIGCHLD</code>, do not generate this signal when a child process stops (job control). This signal is still generated, of course, when a child terminates (but see the <code>SA_NOCLDWAIT</code> option below). When the XSI option is supported, <code>SIGCHLD</code> won’t be sent when a stopped child continues if this flag is set.</td>
</tr>
<tr>
<td><code>SA_NOCLDWAIT</code></td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>If <em>signo</em> is <code>SIGCHLD</code>, this option prevents the system from creating zombie processes when children of the calling process terminate. If it subsequently calls <code>wait</code>, the calling process blocks until all its child processes have terminated and then returns −1 with <code>errno</code> set to <code>ECHILD</code>. (<a href="#sigcld-semantics">Section 10.7</a>)</td>
</tr>
<tr>
<td><code>SA_NODEFER</code></td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>When this signal is caught, the signal is not automatically blocked by the system while the signal-catching function executes (unless the signal is also included in <code>sa_mask</code>). Note that this type of operation corresponds to the earlier unreliable signals.</td>
</tr>
<tr>
<td><code>SA_ONSTACK</code></td>
<td>XSI</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>If an alternative stack has been declared with <code>sigaltstack(2)</code>, this signal is delivered to the process on the alternative stack.</td>
</tr>
<tr>
<td><code>SA_RESETHAND</code></td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>The disposition for this signal is reset to <code>SIG_DFL</code>, and the <code>SA_SIGINFO</code> flag is cleared on entry to the signal-catching function. Note that this type of operation corresponds to the earlier unreliable signals. The disposition for the two signals <code>SIGILL</code> and <code>SIGTRAP</code> can’t be reset automatically, however. Setting this flag can optionally cause sigaction to behave as if <code>SA_NODEFER</code> is also set.</td>
</tr>
<tr>
<td><code>SA_RESTART</code></td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>System calls interrupted by this signal are automatically restarted. (<a href="#interrupted-system-calls">Section 10.5</a>)</td>
</tr>
<tr>
<td><code>SA_SIGINFO</code></td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>This option provides additional information to a signal handler: a pointer to a <code>siginfo</code> structure and a pointer to an identifier for the process context.</td>
</tr>
</tbody>
</table>
<p>Normally, the signal handler is called as:</p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="nf">handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">);</span>
</pre></div>


<p>If the <code>SA_SIGINFO</code> flag is set, the signal handler is called as:</p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="nf">handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">,</span> <span class="kt">siginfo_t</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">);</span>
</pre></div>


<p>The <code>siginfo</code> structure contains information about why the signal was generated. All POSIX.1-compliant implementations must include at least the <code>si_signo</code> and <code>si_code</code> members. Additionally, implementations that are XSI compliant contain at least the following fields:</p>
<div class="codehilite"><pre><span class="k">struct</span> <span class="n">siginfo</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">si_signo</span><span class="p">;</span> <span class="cm">/* signal number */</span>
    <span class="kt">int</span> <span class="n">si_errno</span><span class="p">;</span> <span class="cm">/* if nonzero, errno value from errno.h */</span>
    <span class="kt">int</span> <span class="n">si_code</span><span class="p">;</span> <span class="cm">/* additional info (depends on signal) */</span>
    <span class="kt">pid_t</span> <span class="n">si_pid</span><span class="p">;</span> <span class="cm">/* sending process ID */</span>
    <span class="kt">uid_t</span> <span class="n">si_uid</span><span class="p">;</span> <span class="cm">/* sending process real user ID */</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">si_addr</span><span class="p">;</span> <span class="cm">/* address that caused the fault */</span>
    <span class="kt">int</span> <span class="n">si_status</span><span class="p">;</span> <span class="cm">/* exit value or signal number */</span>
    <span class="k">union</span> <span class="n">sigval</span> <span class="n">si_value</span><span class="p">;</span> <span class="cm">/* application-specific value */</span>
    <span class="cm">/* possibly other fields also */</span>
<span class="p">};</span>
</pre></div>


<p>The <code>sigval</code> union contains the following fields:</p>
<div class="codehilite"><pre><span class="kt">int</span> <span class="n">sival_int</span><span class="p">;</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">sival_ptr</span><span class="p">;</span>
</pre></div>


<p>Applications pass an integer value in <code>si_value.sival_int</code> or pass a pointer value in <code>si_value.sival_ptr</code> when delivering signals.</p>
<p>If the signal is <code>SIGCHLD</code>, then the <code>si_pid</code>, <code>si_status</code>, and <code>si_uid</code> fields will be set.
If the signal is <code>SIGBUS</code>, <code>SIGILL</code>, <code>SIGFPE</code>, or <code>SIGSEGV</code>, then the <code>si_addr</code> contains the address responsible for the fault.
The <code>si_errno</code> field contains the error number corresponding to the condition that caused the signal to be generated.</p>
<p>The table shows values of <code>si_code</code> for various signals, as defined by the Single UNIX Specification:</p>
<p><a href="../figure_10.17.png" title="Figure 10.17 siginfo_t code values"><img alt="Figure 10.17 siginfo_t code values" src="../figure_10.17.png" /></a></p>
<p>The <em>context</em> argument to the signal handler is a typeless pointer that can be cast to a <code>ucontext_t</code> structure identifying the process context at the time of signal delivery. This structure contains at least the following fields:</p>
<div class="codehilite"><pre><span class="n">ucontext_t</span> <span class="o">*</span><span class="n">uc_link</span><span class="p">;</span>    <span class="cm">/* pointer to context resumed when */</span>
                        <span class="cm">/* this context returns */</span>
<span class="kt">sigset_t</span> <span class="n">uc_sigmask</span><span class="p">;</span>    <span class="cm">/* signals blocked when this context */</span>
                        <span class="cm">/* is active */</span>
<span class="n">stack_t</span> <span class="n">uc_stack</span><span class="p">;</span>       <span class="cm">/* stack used by this context */</span>
<span class="n">mcontext_t</span> <span class="n">uc_mcontext</span><span class="p">;</span> <span class="cm">/* machine-specific representation of */</span>
                        <span class="cm">/* saved context */</span>
</pre></div>


<p>The <code>uc_stack</code> field describes the stack used by the current context. It contains at least the following members:</p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="o">*</span><span class="n">ss_sp</span><span class="p">;</span> <span class="cm">/* stack base or pointer */</span>
<span class="kt">size_t</span> <span class="n">ss_size</span><span class="p">;</span> <span class="cm">/* stack size */</span>
<span class="kt">int</span> <span class="n">ss_flags</span><span class="p">;</span> <span class="cm">/* flags */</span>
</pre></div>


<p>When an implementation supports the real-time signal extensions, signal handlers established with the <code>SA_SIGINFO</code> flag will result in signals being queued reliably. A separate range of reserved signal numbers is available for real-time application use. Applications can pass information along with the signal by using the sigqueue function (<a href="../sigqueue-function">Section 10.20</a>).</p>
<h4 id="example-signal-function">Example: <code>signal</code> Function<a class="headerlink" href="#example-signal-function" title="Permanent link">&para;</a></h4>
<p>The following is the implementation of the <code>signal</code> function using <code>sigaction</code>. [p354]</p>
<p><small><a href="https://github.com/shichao-an/apue.3e/blob/master/lib/signal.c">lib/signal.c</a></small></p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&quot;apue.h&quot;</span><span class="cp"></span>

<span class="cm">/* Reliable version of signal(), using POSIX sigaction().  */</span>
<span class="n">Sigfunc</span> <span class="o">*</span>
<span class="nf">signal</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">,</span> <span class="n">Sigfunc</span> <span class="o">*</span><span class="n">func</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">sigaction</span>    <span class="n">act</span><span class="p">,</span> <span class="n">oact</span><span class="p">;</span>

    <span class="n">act</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">=</span> <span class="n">func</span><span class="p">;</span>
    <span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">act</span><span class="p">.</span><span class="n">sa_mask</span><span class="p">);</span>
    <span class="n">act</span><span class="p">.</span><span class="n">sa_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">signo</span> <span class="o">==</span> <span class="n">SIGALRM</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef  SA_INTERRUPT</span>
        <span class="n">act</span><span class="p">.</span><span class="n">sa_flags</span> <span class="o">|=</span> <span class="n">SA_INTERRUPT</span><span class="p">;</span>
<span class="cp">#endif</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">act</span><span class="p">.</span><span class="n">sa_flags</span> <span class="o">|=</span> <span class="n">SA_RESTART</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sigaction</span><span class="p">(</span><span class="n">signo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">act</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oact</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="n">SIG_ERR</span><span class="p">);</span>
    <span class="k">return</span><span class="p">(</span><span class="n">oact</span><span class="p">.</span><span class="n">sa_handler</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<ul>
<li>We must use <code>sigemptyset</code> to initialize the <code>sa_mask</code> member of the structure since we’re not guaranteed that <code>act.sa_mask = 0</code> does the same thing.</li>
<li>We intentionally set the <code>SA_RESTART</code> flag for all signals other than <code>SIGALRM</code>, so that any system call interrupted by these other signals will be automatically restarted. The reason we don’t want <code>SIGALRM</code> restarted is to allow us to set a timeout for I/O operations. (<a href="#implementing-a-timeout-using-alarm">Figure 10.10</a>)</li>
<li>Some older systems, such as SunOS, define the <code>SA_INTERRUPT</code> flag. These systems restart interrupted system calls by default, so specifying this flag causes system calls to be interrupted. Linux defines the <code>SA_INTERRUPT</code> flag for compatibility with applications that use it, but by default does not restart system calls when the signal handler is installed with <code>sigaction</code>. The Single UNIX Specification specifies that the <code>sigaction</code> function not restart interrupted system calls unless the <code>SA_RESTART</code> flag is specified.</li>
</ul>
<h4 id="example-signal_intr-function">Example: <code>signal_intr</code> Function<a class="headerlink" href="#example-signal_intr-function" title="Permanent link">&para;</a></h4>
<p>The following code shows a version of the <code>signal</code> function that tries to prevent any interrupted system calls from being restarted.</p>
<p><small><a href="https://github.com/shichao-an/apue.3e/blob/master/lib/signalintr.c">lib/signalintr.c</a></small></p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&quot;apue.h&quot;</span><span class="cp"></span>

<span class="n">Sigfunc</span> <span class="o">*</span>
<span class="nf">signal_intr</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">,</span> <span class="n">Sigfunc</span> <span class="o">*</span><span class="n">func</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">sigaction</span>    <span class="n">act</span><span class="p">,</span> <span class="n">oact</span><span class="p">;</span>

    <span class="n">act</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">=</span> <span class="n">func</span><span class="p">;</span>
    <span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">act</span><span class="p">.</span><span class="n">sa_mask</span><span class="p">);</span>
    <span class="n">act</span><span class="p">.</span><span class="n">sa_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#ifdef  SA_INTERRUPT</span>
    <span class="n">act</span><span class="p">.</span><span class="n">sa_flags</span> <span class="o">|=</span> <span class="n">SA_INTERRUPT</span><span class="p">;</span>
<span class="cp">#endif</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sigaction</span><span class="p">(</span><span class="n">signo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">act</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oact</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="n">SIG_ERR</span><span class="p">);</span>
    <span class="k">return</span><span class="p">(</span><span class="n">oact</span><span class="p">.</span><span class="n">sa_handler</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>For improved portability, we specify the <code>SA_INTERRUPT</code> flag, if defined by the system, to prevent interrupted system calls from being restarted.</p>
<h3 id="sigsetjmp-and-siglongjmp-functions"><code>sigsetjmp</code> and <code>siglongjmp</code> Functions<a class="headerlink" href="#sigsetjmp-and-siglongjmp-functions" title="Permanent link">&para;</a></h3>
<p><code>setjmp</code> and <code>longjmp</code> functions (<a href="../ch7/#setjmp-and-longjmp-functions">Section 7.10</a>) can be used for nonlocal branching. The <code>longjmp</code> function is often called from a signal handler to return to the main loop of a program, instead of returning from the handler. (<a href="#sleep2-example-using-setjmp-and-longjmp">Figure 10.8</a> and <a href="#implementing-a-timeout-with-alarm-and-longjmp">Figure 10.11</a>).</p>
<p>However, there is a problem in calling <code>longjmp</code>. When a signal is caught, the signal-catching function is entered, with the current signal automatically being added to the signal mask of the process. This prevents subsequent occurrences of that signal from interrupting the signal handler. If we <code>longjmp</code> out of the signal handler, what happens to the signal mask for the process depends on the platform:</p>
<ul>
<li>Under FreeBSD 8.0 and Mac OS X 10.6.8, <code>setjmp</code> and <code>longjmp</code> save and restore the signal mask.</li>
<li>Linux 3.2.0 and Solaris 10, however, do not save and restore the signal mask, although Linux supports an option to provide BSD behavior.</li>
<li>FreeBSD and Mac OS X provide the functions <code>_setjmp</code> and <code>_longjmp</code>, which do not save and restore the signal mask.</li>
</ul>
<p>To allow either form of behavior, POSIX.1 does not specify the effect of <code>setjmp</code> and <code>longjmp</code> on signal masks. Instead, two new functions, <code>sigsetjmp</code> and <code>siglongjmp</code>, are defined by POSIX.1. These two functions should always be used when branching from a signal handler.</p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&lt;setjmp.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">sigsetjmp</span><span class="p">(</span><span class="n">sigjmp_buf</span> <span class="n">env</span><span class="p">,</span> <span class="kt">int</span> <span class="n">savemask</span><span class="p">);</span>
<span class="cm">/* Returns: 0 if called directly, nonzero if returning from a call to siglongjmp */</span>

<span class="kt">void</span> <span class="nf">siglongjmp</span><span class="p">(</span><span class="n">sigjmp_buf</span> <span class="n">env</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">);</span>
</pre></div>


<p>The only difference between these functions and the <code>setjmp</code> and <code>longjmp</code> functions is that <code>sigsetjmp</code> has an additional argument. If <em>savemask</em> is nonzero, then <code>sigsetjmp</code> also saves the current signal mask of the process in <em>env</em>. When <code>siglongjmp</code> is called, if the <em>env</em> argument was saved by a call to <code>sigsetjmp</code> with a nonzero <em>savemask</em>, then <code>siglongjmp</code> restores the saved signal mask.</p>
<p><small><a href="https://github.com/shichao-an/apue.3e/blob/master/signals/mask.c">signals/mask.c</a></small></p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&quot;apue.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;setjmp.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;time.h&gt;</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span>                     <span class="nf">sig_usr1</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>                     <span class="nf">sig_alrm</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="k">static</span> <span class="n">sigjmp_buf</span>               <span class="n">jmpbuf</span><span class="p">;</span>
<span class="k">static</span> <span class="k">volatile</span> <span class="kt">sig_atomic_t</span>    <span class="n">canjump</span><span class="p">;</span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">signal</span><span class="p">(</span><span class="n">SIGUSR1</span><span class="p">,</span> <span class="n">sig_usr1</span><span class="p">)</span> <span class="o">==</span> <span class="n">SIG_ERR</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;signal(SIGUSR1) error&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">signal</span><span class="p">(</span><span class="n">SIGALRM</span><span class="p">,</span> <span class="n">sig_alrm</span><span class="p">)</span> <span class="o">==</span> <span class="n">SIG_ERR</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;signal(SIGALRM) error&quot;</span><span class="p">);</span>

    <span class="n">pr_mask</span><span class="p">(</span><span class="s">&quot;starting main: &quot;</span><span class="p">);</span>     <span class="cm">/* {Prog prmask} */</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">sigsetjmp</span><span class="p">(</span><span class="n">jmpbuf</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>

        <span class="n">pr_mask</span><span class="p">(</span><span class="s">&quot;ending main: &quot;</span><span class="p">);</span>

        <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">canjump</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>    <span class="cm">/* now sigsetjmp() is OK */</span>

    <span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="p">;</span> <span class="p">)</span>
        <span class="n">pause</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sig_usr1</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">time_t</span>  <span class="n">starttime</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">canjump</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>     <span class="cm">/* unexpected signal, ignore */</span>

    <span class="n">pr_mask</span><span class="p">(</span><span class="s">&quot;starting sig_usr1: &quot;</span><span class="p">);</span>

    <span class="n">alarm</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>               <span class="cm">/* SIGALRM in 3 seconds */</span>
    <span class="n">starttime</span> <span class="o">=</span> <span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="p">;</span> <span class="p">)</span>             <span class="cm">/* busy wait for 5 seconds */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">starttime</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>

    <span class="n">pr_mask</span><span class="p">(</span><span class="s">&quot;finishing sig_usr1: &quot;</span><span class="p">);</span>

    <span class="n">canjump</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">siglongjmp</span><span class="p">(</span><span class="n">jmpbuf</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>  <span class="cm">/* jump back to main, don&#39;t return */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sig_alrm</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">pr_mask</span><span class="p">(</span><span class="s">&quot;in sig_alrm: &quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<ul>
<li>We set the variable <code>canjump</code> to a nonzero value only after we’ve called <code>sigsetjmp</code>. This variable is examined in the signal handler, and <code>siglongjmp</code> is called only if the flag <code>canjump</code> is nonzero. This technique provides protection against the signal handler being called at some earlier or later time, when the jump buffer hasn’t been initialized by <code>sigsetjmp</code>. This technique should be used whenever <code>siglongjmp</code> is called from a signal handler, but is not required with longjmp in normal C code. Since a signal can occur at any time, therefore we need the added protection in a signal handler.</li>
<li>We use the data type <code>sig_atomic_t</code>, which is defined by the ISO C standard to be the type of variable that can be written without being interrupted.<ul>
<li>This means that a variable of type <code>sig_atomic_t</code> should not extend across page boundaries on a system with virtual memory and can be accessed with a single machine instruction, for example.</li>
<li>We always include the ISO type qualifier <code>volatile</code> for these data types as well, since the variable is being accessed by two different threads of control: the <code>main</code> function and the asynchronously executing signal handler.</li>
</ul>
</li>
</ul>
<p>We can divide the following figure into three parts:</p>
<ul>
<li>Left part (corresponding to <code>main</code>)</li>
<li>Center part (<code>sig_usr1</code>)</li>
<li>Right part (<code>sig_alrm</code>).</li>
</ul>
<p>While the process is executing in the left part, its signal mask is 0 (no signals are blocked). While executing in the center part, its signal mask is <code>SIGUSR1</code>. While executing in the right part, its signal mask is <code>SIGUSR1</code>|<code>SIGALRM</code>.</p>
<p><a href="../figure_10.21.png" title="Figure 10.21 Timeline for example program handling two signals"><img alt="Figure 10.21 Timeline for example program handling two signals" src="../figure_10.21_600.png" /></a></p>
<p>The output of the program:</p>
<div class="codehilite"><pre><span class="gp">$</span> ./a.out <span class="p">&amp;</span>             <span class="c1"># start process in background</span>
<span class="go">starting main:</span>
<span class="go">[1] 531                 # the job-control shell prints its process ID</span>
<span class="gp">$</span> <span class="nb">kill</span> -USR1 <span class="m">531</span>        <span class="c1"># send the process SIGUSR1</span>
<span class="go">starting sig_usr1: SIGUSR1</span>
<span class="gp">$</span> in sig_alrm: SIGUSR1 SIGALRM
<span class="go">finishing sig_usr1: SIGUSR1</span>
<span class="go">ending main:</span>
<span class="gp">                        #</span> just press RETURN
<span class="go">[1] + Done ./a.out &amp;</span>
</pre></div>


<p>The output is what we expect: when a signal handler is invoked, the signal being caught is added to the current signal mask of the process. The original mask is restored when the signal handler returns. Also, <code>siglongjmp</code> restores the signal mask that was saved by <code>sigsetjmp</code>.</p>
<h3 id="sigsuspend-function"><code>sigsuspend</code> Function<a class="headerlink" href="#sigsuspend-function" title="Permanent link">&para;</a></h3>
<p>We have seen how we can change the signal mask for a process to block and unblock selected signals. We can use this technique to protect critical regions of code that we don’t want interrupted by a signal. But what if we want to unblock a signal and then <code>pause</code>, waiting for the previously blocked signal to occur? Assuming that the signal is <code>SIGINT</code>, the incorrect way to do this is:</p>
<div class="codehilite"><pre>  <span class="kt">sigset_t</span> <span class="n">newmask</span><span class="p">,</span> <span class="n">oldmask</span><span class="p">;</span>

  <span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newmask</span><span class="p">);</span>
  <span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newmask</span><span class="p">,</span> <span class="n">SIGINT</span><span class="p">);</span>

  <span class="cm">/* block SIGINT and save current signal mask */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_BLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newmask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldmask</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
      <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;SIG_BLOCK error&quot;</span><span class="p">);</span>

  <span class="cm">/* critical region of code */</span>

  <span class="cm">/* restore signal mask, which unblocks SIGINT */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_SETMASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldmask</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
      <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;SIG_SETMASK error&quot;</span><span class="p">);</span>

  <span class="cm">/* window is open */</span>
  <span class="n">pause</span><span class="p">();</span> <span class="cm">/* wait for signal to occur */</span>

  <span class="cm">/* continue processing */</span>
</pre></div>


<p>If the signal is sent to the process while it is blocked, the signal delivery will be deferred until the signal is unblocked. To the application, this can look as if the signal occurs between the unblocking and the <code>pause</code> (depending on how the kernel implements signals). If this happens, or if the signal does occur between the unblocking and the <code>pause</code>, we have a problem. Any occurrence of the signal in this window of time is lost, in the sense that we might not see the signal again, in which case the <code>pause</code> will block indefinitely. This is another problem with the earlier unreliable signals.</p>
<p>To correct this problem, we need a way to both restore the signal mask and put the process to sleep in a single atomic operation. This feature is provided by the <code>sigsuspend</code> function.</p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">sigsuspend</span><span class="p">(</span><span class="k">const</span> <span class="kt">sigset_t</span> <span class="o">*</span><span class="n">sigmask</span><span class="p">);</span>

<span class="cm">/* Returns: −1 with errno set to EINTR */</span>
</pre></div>


<p>The signal mask of the process is set to the value pointed to by <em>sigmask</em>. Then the process is suspended until a signal is caught or until a signal occurs that terminates the process. If a signal is caught and if the signal handler returns, then <code>sigsuspend</code> returns, and the signal mask of the process is set to its value before the call to <code>sigsuspend</code>.</p>
<h4 id="example-of-sigsuspend-to-protect-a-critial-region">Example of <code>sigsuspend</code> to protect a critial region<a class="headerlink" href="#example-of-sigsuspend-to-protect-a-critial-region" title="Permanent link">&para;</a></h4>
<p>The following code shows the correct way to protect a critical region of code from a specific signal.</p>
<p><small><a href="https://github.com/shichao-an/apue.3e/blob/master/signals/suspend1.c">signals/suspend1.c</a></small></p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&quot;apue.h&quot;</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sig_int</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">sigset_t</span>    <span class="n">newmask</span><span class="p">,</span> <span class="n">oldmask</span><span class="p">,</span> <span class="n">waitmask</span><span class="p">;</span>

    <span class="n">pr_mask</span><span class="p">(</span><span class="s">&quot;program start: &quot;</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">sig_int</span><span class="p">)</span> <span class="o">==</span> <span class="n">SIG_ERR</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;signal(SIGINT) error&quot;</span><span class="p">);</span>
    <span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waitmask</span><span class="p">);</span>
    <span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waitmask</span><span class="p">,</span> <span class="n">SIGUSR1</span><span class="p">);</span>
    <span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newmask</span><span class="p">);</span>
    <span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newmask</span><span class="p">,</span> <span class="n">SIGINT</span><span class="p">);</span>

    <span class="cm">/*</span>
<span class="cm">     * Block SIGINT and save current signal mask.</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_BLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newmask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldmask</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;SIG_BLOCK error&quot;</span><span class="p">);</span>

    <span class="cm">/*</span>
<span class="cm">     * Critical region of code.</span>
<span class="cm">     */</span>
    <span class="n">pr_mask</span><span class="p">(</span><span class="s">&quot;in critical region: &quot;</span><span class="p">);</span>

    <span class="cm">/*</span>
<span class="cm">     * Pause, allowing all signals except SIGUSR1.</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sigsuspend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waitmask</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;sigsuspend error&quot;</span><span class="p">);</span>

    <span class="n">pr_mask</span><span class="p">(</span><span class="s">&quot;after return from sigsuspend: &quot;</span><span class="p">);</span>

    <span class="cm">/*</span>
<span class="cm">     * Reset signal mask which unblocks SIGINT.</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_SETMASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldmask</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;SIG_SETMASK error&quot;</span><span class="p">);</span>

    <span class="cm">/*</span>
<span class="cm">     * And continue processing ...</span>
<span class="cm">     */</span>
    <span class="n">pr_mask</span><span class="p">(</span><span class="s">&quot;program exit: &quot;</span><span class="p">);</span>

    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sig_int</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">pr_mask</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">in sig_int: &quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>When <code>sigsuspend</code> returns, it sets the signal mask to its value before the cal SIGINT signal will be blocked, so we restore the signal mask to the value
that we saved earlier (oldmask).</p>
<p>Running the program produces the following output:</p>
<div class="codehilite"><pre><span class="gp">$</span> ./a.out
<span class="go">program start:</span>
<span class="go">in critical region: SIGINT</span>
<span class="go">ˆC                          # type the interrupt character</span>
<span class="go">in sig_int: SIGINT SIGUSR1</span>
<span class="go">after return from sigsuspend: SIGINT</span>
<span class="go">program exit:</span>
</pre></div>


<h4 id="example-of-sigsuspend-to-wait-for-a-signal-handler-to-set-a-global-variable">Example of <code>sigsuspend</code> to wait for a signal handler to set a global variable<a class="headerlink" href="#example-of-sigsuspend-to-wait-for-a-signal-handler-to-set-a-global-variable" title="Permanent link">&para;</a></h4>
<p>In the following program, we catch both the interrupt signal and the quit signal, but want to wake up the main routine only when the quit signal is caught.</p>
<p><small><a href="https://github.com/shichao-an/apue.3e/blob/master/signals/suspend2.c">signals/suspend2.c</a></small></p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&quot;apue.h&quot;</span><span class="cp"></span>

<span class="k">volatile</span> <span class="kt">sig_atomic_t</span>   <span class="n">quitflag</span><span class="p">;</span>   <span class="cm">/* set nonzero by signal handler */</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sig_int</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">)</span>  <span class="cm">/* one signal handler for SIGINT and SIGQUIT */</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">signo</span> <span class="o">==</span> <span class="n">SIGINT</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">interrupt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">signo</span> <span class="o">==</span> <span class="n">SIGQUIT</span><span class="p">)</span>
        <span class="n">quitflag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>   <span class="cm">/* set flag for main loop */</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">sigset_t</span>    <span class="n">newmask</span><span class="p">,</span> <span class="n">oldmask</span><span class="p">,</span> <span class="n">zeromask</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">sig_int</span><span class="p">)</span> <span class="o">==</span> <span class="n">SIG_ERR</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;signal(SIGINT) error&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">signal</span><span class="p">(</span><span class="n">SIGQUIT</span><span class="p">,</span> <span class="n">sig_int</span><span class="p">)</span> <span class="o">==</span> <span class="n">SIG_ERR</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;signal(SIGQUIT) error&quot;</span><span class="p">);</span>

    <span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zeromask</span><span class="p">);</span>
    <span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newmask</span><span class="p">);</span>
    <span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newmask</span><span class="p">,</span> <span class="n">SIGQUIT</span><span class="p">);</span>

    <span class="cm">/*</span>
<span class="cm">     * Block SIGQUIT and save current signal mask.</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_BLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newmask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldmask</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;SIG_BLOCK error&quot;</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">quitflag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">sigsuspend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zeromask</span><span class="p">);</span>

    <span class="cm">/*</span>
<span class="cm">     * SIGQUIT has been caught and is now blocked; do whatever.</span>
<span class="cm">     */</span>
    <span class="n">quitflag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/*</span>
<span class="cm">     * Reset signal mask which unblocks SIGQUIT.</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_SETMASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldmask</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;SIG_SETMASK error&quot;</span><span class="p">);</span>

    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>Sample output from this program is:</p>
<div class="codehilite"><pre><span class="gp">$</span> ./a.out
<span class="go">ˆC           # type the interrupt character</span>
<span class="go">interrupt</span>
<span class="go">ˆC           # type the interrupt character again</span>
<span class="go">interrupt</span>
<span class="go">ˆC           # and again</span>
<span class="go">interrupt</span>
<span class="go">ˆ\ $         # now terminate with the quit character</span>
</pre></div>


<h4 id="example-of-signals-that-synchronize-a-parent-and-child">Example of signals that synchronize a parent and child<a class="headerlink" href="#example-of-signals-that-synchronize-a-parent-and-child" title="Permanent link">&para;</a></h4>
<p>This example shows how signals can be used to synchronize a parent and child. The following example shows implementations of the five routines <code>TELL_WAIT</code>, <code>TELL_PARENT</code>, <code>TELL_CHILD</code>, <code>WAIT_PARENT</code>, and <code>WAIT_CHILD</code> from <a href="../ch8/#race-conditions">Section 8.9</a>.</p>
<p><small><a href="https://github.com/shichao-an/apue.3e/blob/master/lib/tellwait.c">lib/tellwait.c</a></small></p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&quot;apue.h&quot;</span><span class="cp"></span>

<span class="k">static</span> <span class="k">volatile</span> <span class="kt">sig_atomic_t</span> <span class="n">sigflag</span><span class="p">;</span> <span class="cm">/* set nonzero by sig handler */</span>
<span class="k">static</span> <span class="kt">sigset_t</span> <span class="n">newmask</span><span class="p">,</span> <span class="n">oldmask</span><span class="p">,</span> <span class="n">zeromask</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sig_usr</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">)</span>  <span class="cm">/* one signal handler for SIGUSR1 and SIGUSR2 */</span>
<span class="p">{</span>
    <span class="n">sigflag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">TELL_WAIT</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">signal</span><span class="p">(</span><span class="n">SIGUSR1</span><span class="p">,</span> <span class="n">sig_usr</span><span class="p">)</span> <span class="o">==</span> <span class="n">SIG_ERR</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;signal(SIGUSR1) error&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">signal</span><span class="p">(</span><span class="n">SIGUSR2</span><span class="p">,</span> <span class="n">sig_usr</span><span class="p">)</span> <span class="o">==</span> <span class="n">SIG_ERR</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;signal(SIGUSR2) error&quot;</span><span class="p">);</span>
    <span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zeromask</span><span class="p">);</span>
    <span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newmask</span><span class="p">);</span>
    <span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newmask</span><span class="p">,</span> <span class="n">SIGUSR1</span><span class="p">);</span>
    <span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newmask</span><span class="p">,</span> <span class="n">SIGUSR2</span><span class="p">);</span>

    <span class="cm">/* Block SIGUSR1 and SIGUSR2, and save current signal mask */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_BLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newmask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldmask</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;SIG_BLOCK error&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">TELL_PARENT</span><span class="p">(</span><span class="kt">pid_t</span> <span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">kill</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">SIGUSR2</span><span class="p">);</span>     <span class="cm">/* tell parent we&#39;re done */</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">WAIT_PARENT</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">sigflag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">sigsuspend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zeromask</span><span class="p">);</span>  <span class="cm">/* and wait for parent */</span>
    <span class="n">sigflag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/* Reset signal mask to original value */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_SETMASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldmask</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;SIG_SETMASK error&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">TELL_CHILD</span><span class="p">(</span><span class="kt">pid_t</span> <span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">kill</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">SIGUSR1</span><span class="p">);</span>         <span class="cm">/* tell child we&#39;re done */</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">WAIT_CHILD</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">sigflag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">sigsuspend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zeromask</span><span class="p">);</span>  <span class="cm">/* and wait for child */</span>
    <span class="n">sigflag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/* Reset signal mask to original value */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_SETMASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldmask</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;SIG_SETMASK error&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>In the example, two user-defined signals are used: <code>SIGUSR1</code> is sent by the parent to the child, and <code>SIGUSR2</code> is sent by the child to the parent.</p>
<p>The <code>sigsuspend</code> function is fine if we want to go to sleep while we’re waiting for a signal to occur. If we want to call other system functions while we’re waiting, the only solution is to use multiple threads and dedicate a separate thread to handling signals (<a href="../ch12/#threads-and-signals">Section 12.8</a>).</p>
<p>Without using threads, the best we can do is to set a global variable in the signal handler when the signal occurs. For example, if we catch both <code>SIGINT</code> and <code>SIGALRM</code> and install the signal handlers using the <a href="#example-signal_intr-function"><code>signal_intr</code> function</a>, the signals will interrupt any slow system call that is blocked. The signals are most likely to occur when we’re blocked in a call to the <code>read</code> function waiting for input from a slow device.  (This is especially true for <code>SIGALRM</code>, since we set the alarm clock to prevent us from waiting forever for input.) The code to handle this looks similar to the following:</p>
<div class="codehilite"><pre>    <span class="k">if</span> <span class="p">(</span><span class="n">intr_flag</span><span class="p">)</span>      <span class="cm">/* flag set by our SIGINT handler */</span>
        <span class="n">handle_intr</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">alrm_flag</span><span class="p">)</span>      <span class="cm">/* flag set by our SIGALRM handler */</span>
        <span class="n">handle_alrm</span><span class="p">();</span>

    <span class="cm">/* signals occurring in here are lost */</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">read</span><span class="p">(</span> <span class="p">...</span> <span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EINTR</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">alrm_flag</span><span class="p">)</span>
                <span class="n">handle_alrm</span><span class="p">();</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">intr_flag</span><span class="p">)</span>
                <span class="n">handle_intr</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="cm">/* some other error */</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* end of file */</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="cm">/* process input */</span>
    <span class="p">}</span>
</pre></div>


<p>We test each of the global flags before calling <code>read</code> and again if <code>read</code> returns an interrupted system call error. The problem occurs if either signal is caught between the first two if statements and the subsequent call to read. Signals occurring in here are lost, as indicated by the code comment. The signal handlers are called, and they set the appropriate global variable, but the <code>read</code> never returns (unless some data is ready to be read).</p>
<p>What we would like to be able to do is the following sequence of steps, in order.</p>
<ol>
<li>Block <code>SIGINT</code> and <code>SIGALRM</code>.</li>
<li>Test the two global variables to see whether either signal has occurred and, if so, handle the condition.</li>
<li>Call <code>read</code> (or any other system function) and unblock the two signals, as an atomic operation.</li>
</ol>
<p>The <code>sigsuspend</code> function helps us only if step 3 is a <code>pause</code> operation.</p>
<h3 id="abort-function"><code>abort</code> Function<a class="headerlink" href="#abort-function" title="Permanent link">&para;</a></h3>
<p>The <code>abort</code> function causes abnormal program termination.</p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">abort</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* This function never returns */</span>
</pre></div>


<p>The <code>abort</code> function sends the <code>SIGABRT</code> signal to the caller. Processes should not ignore this signal. ISO C states that calling abort will deliver an unsuccessful termination notification to the host environment by calling <code>raise(SIGABRT)</code>.</p>
<p>[p365]</p>
<p>ISO C:</p>
<ul>
<li>If the signal is caught and the signal handler returns, <code>abort</code> still doesn’t return to its caller. If this signal is caught, the only way the signal handler can’t return is if it calls <code>exit</code>, <code>_exit</code>, <code>_Exit</code>, <code>longjmp</code>, or <code>siglongjmp</code>.</li>
<li>It is up to the implementation as to whether output streams are flushed and whether temporary files (<a href="../ch5/#temporary-files">Section 5.13</a>) are deleted.</li>
</ul>
<p>POSIX.1:</p>
<ul>
<li><code>abort</code> overrides the blocking or ignoring of the signal by the process.</li>
<li>The intent of letting the process catch the <code>SIGABRT</code> is to allow it to perform any cleanup that it wants to do before the process terminates.</li>
<li>If the process doesn’t terminate itself from this signal handler, when the signal handler returns, <code>abort</code> terminates the process.</li>
<li>An implementation is allowed to call <code>fclose</code> on open standard I/O streams before terminating if the call to abort terminates the process.</li>
</ul>
<p>Since most UNIX System implementations of <code>tmpfile</code> call <code>unlink</code> immediately after creating the file, the ISO C warning about temporary files does not usually concern us. [p366]</p>
<p>The following is an implementation of the <code>abort</code> function as specified by POSIX.1:</p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>

<span class="kt">void</span>
<span class="nf">abort</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>         <span class="cm">/* POSIX-style abort() function */</span>
<span class="p">{</span>
    <span class="kt">sigset_t</span>            <span class="n">mask</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">sigaction</span>    <span class="n">action</span><span class="p">;</span>

    <span class="cm">/* Caller can&#39;t ignore SIGABRT, if so reset to default */</span>
    <span class="n">sigaction</span><span class="p">(</span><span class="n">SIGABRT</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">action</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">action</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">==</span> <span class="n">SIG_IGN</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">action</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">=</span> <span class="n">SIG_DFL</span><span class="p">;</span>
        <span class="n">sigaction</span><span class="p">(</span><span class="n">SIGABRT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">action</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">action</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">==</span> <span class="n">SIG_DFL</span><span class="p">)</span>
        <span class="n">fflush</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>           <span class="cm">/* flush all open stdio streams */</span>

    <span class="cm">/* Caller can&#39;t block SIGABRT; make sure it&#39;s unblocked */</span>
    <span class="n">sigfillset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mask</span><span class="p">);</span>
    <span class="n">sigdelset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mask</span><span class="p">,</span> <span class="n">SIGABRT</span><span class="p">);</span>  <span class="cm">/* mask has only SIGABRT turned off */</span>
    <span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_SETMASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mask</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">kill</span><span class="p">(</span><span class="n">getpid</span><span class="p">(),</span> <span class="n">SIGABRT</span><span class="p">);</span>    <span class="cm">/* send the signal */</span>

    <span class="cm">/* If we&#39;re here, process caught SIGABRT and returned */</span>
    <span class="n">fflush</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>               <span class="cm">/* flush all open stdio streams */</span>
    <span class="n">action</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">=</span> <span class="n">SIG_DFL</span><span class="p">;</span>
    <span class="n">sigaction</span><span class="p">(</span><span class="n">SIGABRT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">action</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>  <span class="cm">/* reset to default */</span>
    <span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_SETMASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mask</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>  <span class="cm">/* just in case ... */</span>
    <span class="n">kill</span><span class="p">(</span><span class="n">getpid</span><span class="p">(),</span> <span class="n">SIGABRT</span><span class="p">);</span>                <span class="cm">/* and one more time */</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>    <span class="cm">/* this should never be executed ... */</span>
<span class="p">}</span>
</pre></div>


<ul>
<li>This implementation of <code>abort</code> first check whether the default action will occur; if so, it flush all the standard I/O streams. This is not equivalent to calling <code>fclose</code> on all the open streams (since it just flushes them and doesn’t close them), but when the process terminates, the system closes all open files.</li>
<li>If the process catches the signal and returns, we flush all the streams again, since the process could have generated more output.</li>
<li>The only condition we don’t handle is the case where the process catches the signal and calls <code>_exit</code> or <code>_Exit</code>. In this case, any unflushed standard I/O buffers in memory are discarded. (We assume that a caller that does this doesn’t want the buffers flushed.)</li>
<li>As mentioned in <a href="#kill-and-raise-functions">Section 10.9</a>, if calling <code>kill</code> causes the signal to be generated for the caller, and if the signal is not blocked, then the signal (or some other pending, unlocked signal) is delivered to the process before <code>kill</code> returns. We block all signals except <code>SIGABRT</code>, so we know that if the call to <code>kill</code> returns, the process caught the signal and the signal handler returned.</li>
</ul>
<h3 id="system-function"><code>system</code> Function<a class="headerlink" href="#system-function" title="Permanent link">&para;</a></h3>
<p><a href="../ch8/##system-function">Section 8.13</a> showed an implementation of the <code>system</code> function, which did not do any signal handling. POSIX.1 requires that system ignore <code>SIGINT</code> and <code>SIGQUIT</code> and block <code>SIGCHLD</code>. Before showing a version that handles these signals correctly, let’s see why we need to worry about signal handling.</p>
<h4 id="example-of-system-invoking-ed-editor">Example of <code>system</code> invoking <code>ed</code> editor<a class="headerlink" href="#example-of-system-invoking-ed-editor" title="Permanent link">&para;</a></h4>
<p>The program (Figure 10.26) shown below uses the <code>system</code> function from <a href="../ch8/##system-function">Section 8.13</a> to invoke the <code>ed(1)</code> editor. It is an interactive program that catches the interrupt and quit signals. If <code>ed</code> is invoked from a shell and type the interrupt character, it catches the interrupt signal and prints a question mark. The <code>ed</code> program also sets the disposition of the quit signal so that it is ignored.</p>
<p><small><a href="https://github.com/shichao-an/apue.3e/blob/master/signals/systest2.c">signals/systest2.c</a></small></p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&quot;apue.h&quot;</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sig_int</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;caught SIGINT</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sig_chld</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;caught SIGCHLD</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">sig_int</span><span class="p">)</span> <span class="o">==</span> <span class="n">SIG_ERR</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;signal(SIGINT) error&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">signal</span><span class="p">(</span><span class="n">SIGCHLD</span><span class="p">,</span> <span class="n">sig_chld</span><span class="p">)</span> <span class="o">==</span> <span class="n">SIG_ERR</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;signal(SIGCHLD) error&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">system</span><span class="p">(</span><span class="s">&quot;/bin/ed&quot;</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;system() error&quot;</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>This program catches both <code>SIGINT</code> and <code>SIGCHLD</code>. If we invoke the program, we get:</p>
<div class="codehilite"><pre><span class="gp">$</span> ./a.out
<span class="go">a                         # append text to the editor’s buffer</span>
<span class="go">Here is one line of text</span>
<span class="go">.                         # period on a line by itself stops append mode</span>
<span class="go">1,$p                      # print first through last lines of buffer to see what’s there</span>
<span class="go">Here is one line of text</span>
<span class="go">w temp.foo                # write the buffer to a file</span>
<span class="go">25                        # editor says it wrote 25 bytes</span>
<span class="go">q                         # and leave the editor</span>
<span class="go">caught SIGCHLD</span>
</pre></div>


<ul>
<li>When the editor terminates, the kernel sends the <code>SIGCHLD</code> signal to the parent (the <code>a.out</code> process) and it is caught and returned from the signal handler. The parent should be catching the <code>SIGCHLD</code> signal because it has created its own children, so that it knows when its children have terminated.</li>
<li><u>The delivery of the <code>SIGCHLD</code> signal in the parent should be blocked while the <code>system</code> function is executing</u>, as specified by POSIX.1. Otherwise, when the child created by <code>system</code> terminates, it would fool the caller of <code>system</code> into thinking that one of its own children terminated. The caller would then use one of the <code>wait</code> functions to get the termination status of the child, thereby preventing the <code>system</code> function from being able to obtain the child’s termination status for its return value.</li>
</ul>
<p>If we run the program again, this time sending the editor an interrupt signal, we get</p>
<div class="codehilite"><pre><span class="gp">$</span> ./a.out
<span class="go">a                # append text to the editor’s buffer</span>
<span class="go">hello, world</span>
<span class="go">.                # period on a line by itself stops append mode</span>
<span class="go">1,$p             # print first through last lines to see what’s there</span>
<span class="go">hello, world</span>
<span class="go">w temp.foo       # write the buffer to a file</span>
<span class="go">13               # editor says it wrote 13 bytes</span>
<span class="go">ˆC               # type the interrupt character</span>
<span class="go">?                # editor catches signal, prints question mark</span>
<span class="go">caught SIGINT    # and so does the parent process</span>
<span class="go">q                # leave editor</span>
<span class="go">caught SIGCHLD</span>
</pre></div>


<p>As mentioned in <a href="../ch9/#controlling-terminal">Section 9.6</a>, typing the interrupt character causes the interrupt signal to be sent to all the processes in the foreground process group. The following figure shows the arrangement of the processes when the editor is running.</p>
<p><a href="../figure_10.27.png" title="Figure 10.27 Foreground and background process groups for Figure 10.26"><img alt="Figure 10.27 Foreground and background process groups for Figure 10.26" src="../figure_10.27.png" /></a></p>
<p>In this example:</p>
<p><code>SIGINT</code> is sent to all three foreground processes (the shell ignores it) and both the <code>a.out</code> process and the editor catch the signal. When running another program with the <code>system</code> function, we shouldn’t have both the parent and the child catching the two terminal-generated signals: interrupt and quit. Instead, these two signals should be sent to the program that is running: the child. Since the command that is executed by system can be an interactive command (the <code>ed</code> program in this example) and since the caller of <code>system</code> gives up control while the program executes, waiting for it to finish, <u>the caller of <code>system</code> should not be receiving these two terminal-generated signals.</u> For this reason, POSIX.1 specifies that <u>the <code>system</code> function should ignore the <code>SIGINT</code> and <code>SIGQUIT</code> signals while waiting for the command to complete.</u></p>
<h4 id="implementation-of-system-with-signal-handling">Implementation of <code>system</code> with signal handling<a class="headerlink" href="#implementation-of-system-with-signal-handling" title="Permanent link">&para;</a></h4>
<p>The program below shows an implementation of the system function with the required signal handling.</p>
<p><small><a href="https://github.com/shichao-an/apue.3e/blob/master/signals/system.c">signals/system.c</a></small></p>
<div class="codehilite"><pre><span class="cp">#include</span>    <span class="cpf">&lt;sys/wait.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span>    <span class="cpf">&lt;errno.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span>    <span class="cpf">&lt;signal.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span>    <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>

<span class="kt">int</span>
<span class="nf">system</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cmdstring</span><span class="p">)</span>   <span class="cm">/* with appropriate signal handling */</span>
<span class="p">{</span>
    <span class="kt">pid_t</span>               <span class="n">pid</span><span class="p">;</span>
    <span class="kt">int</span>                 <span class="n">status</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">sigaction</span>    <span class="n">ignore</span><span class="p">,</span> <span class="n">saveintr</span><span class="p">,</span> <span class="n">savequit</span><span class="p">;</span>
    <span class="kt">sigset_t</span>            <span class="n">chldmask</span><span class="p">,</span> <span class="n">savemask</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">cmdstring</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>      <span class="cm">/* always a command processor with UNIX */</span>

    <span class="n">ignore</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">=</span> <span class="n">SIG_IGN</span><span class="p">;</span>    <span class="cm">/* ignore SIGINT and SIGQUIT */</span>
    <span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ignore</span><span class="p">.</span><span class="n">sa_mask</span><span class="p">);</span>
    <span class="n">ignore</span><span class="p">.</span><span class="n">sa_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sigaction</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ignore</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">saveintr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sigaction</span><span class="p">(</span><span class="n">SIGQUIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ignore</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">savequit</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chldmask</span><span class="p">);</span>         <span class="cm">/* now block SIGCHLD */</span>
    <span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chldmask</span><span class="p">,</span> <span class="n">SIGCHLD</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_BLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chldmask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">savemask</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>    <span class="cm">/* probably out of processes */</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>          <span class="cm">/* child */</span>
        <span class="cm">/* restore previous signal actions &amp; reset signal mask */</span>
        <span class="n">sigaction</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">saveintr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">sigaction</span><span class="p">(</span><span class="n">SIGQUIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">savequit</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_SETMASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">savemask</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

        <span class="n">execl</span><span class="p">(</span><span class="s">&quot;/bin/sh&quot;</span><span class="p">,</span> <span class="s">&quot;sh&quot;</span><span class="p">,</span> <span class="s">&quot;-c&quot;</span><span class="p">,</span> <span class="n">cmdstring</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
        <span class="n">_exit</span><span class="p">(</span><span class="mi">127</span><span class="p">);</span>     <span class="cm">/* exec error */</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>                        <span class="cm">/* parent */</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">waitpid</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">!=</span> <span class="n">EINTR</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* error other than EINTR from waitpid() */</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/* restore previous signal actions &amp; reset signal mask */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sigaction</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">saveintr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sigaction</span><span class="p">(</span><span class="n">SIGQUIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">savequit</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_SETMASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">savemask</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

    <span class="k">return</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>This implementation of <code>system</code> differs from the previous flawed one in the following ways:</p>
<ol>
<li>No signal is sent to the calling process when we type the interrupt or quit character.</li>
<li>When the <code>ed</code> command exits, <code>SIGCHLD</code> is not sent to the calling process. Instead, it is blocked until we unblock it in the last call to <code>sigprocmask</code>, after the <code>system</code> function retrieves the child’s termination status by calling <code>waitpid</code>.</li>
</ol>
<p>POSIX.1 states that if <code>wait</code> or <code>waitpid</code> returns the status of a child process while <code>SIGCHLD</code> is pending, then <code>SIGCHLD</code> should not be delivered to the process unless the status of another child process is also available. FreeBSD 8.0, Mac OS X 10.6.8, and Solaris 10 all implement this semantic, while Linux 3.2.0 doesn’t. In Linux, <code>SIGCHLD</code> remains pending after the <code>system</code> function calls <code>waitpid</code>; when the signal is unblocked, it is delivered to the caller. If we called <code>wait</code> in the <code>sig_chld</code> function in <a href="#example-of-system-invoking-ed-editor">Figure 10.26</a>, a Linux system would return −1 with <code>errno</code> set to <code>ECHILD</code>, since the <code>system</code> function already retrieved the termination status of the child.</p>
<p>Many older texts show the ignoring of the interrupt and quit signals as follows:</p>
<div class="codehilite"><pre>  <span class="k">if</span> <span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;fork error&quot;</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* child */</span>
    <span class="n">execl</span><span class="p">(...);</span>
    <span class="n">_exit</span><span class="p">(</span><span class="mi">127</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="cm">/* parent */</span>
  <span class="n">old_intr</span> <span class="o">=</span> <span class="n">signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">SIG_IGN</span><span class="p">);</span>
  <span class="n">old_quit</span> <span class="o">=</span> <span class="n">signal</span><span class="p">(</span><span class="n">SIGQUIT</span><span class="p">,</span> <span class="n">SIG_IGN</span><span class="p">);</span>
  <span class="n">waitpid</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">old_intr</span><span class="p">);</span>
  <span class="n">signal</span><span class="p">(</span><span class="n">SIGQUIT</span><span class="p">,</span> <span class="n">old_quit</span><span class="p">);</span>
</pre></div>


<p>The problem with this sequence of code is that we have no guarantee after the <code>fork</code> regarding whether the parent or child runs first. If the child runs first and the parent doesn’t run for some time after, an interrupt signal might be generated before the parent is able to change its disposition to be ignored. For this reason, in the implementation of <code>system</code>, we change the disposition of the signals before the <code>fork</code>.</p>
<p>Note that we have to reset the dispositions of these two signals in the child before the call to <code>execl</code>. This allows execl to change their dispositions to the default, based on the caller’s dispositions, as described in <a href="../ch8/#exec-functions">Section 8.10</a>.</p>
<h4 id="return-value-from-system">Return Value from <code>system</code><a class="headerlink" href="#return-value-from-system" title="Permanent link">&para;</a></h4>
<p>The return value from <code>system</code> is the termination status of the shell, which isn’t always the termination status of the command string. [p371]</p>
<p>Run the program in <a href="https://github.com/shichao-an/apue.3e/blob/master/proc/systest3.c">Figure 8.24</a> and send some signals to the command that’s executing:</p>
<div class="codehilite"><pre><span class="gp">$</span> tsys <span class="s2">&quot;sleep 30&quot;</span>
<span class="go">ˆCnormal termination, exit status = 130  # we press the interrupt key</span>
<span class="gp">$</span> tsys <span class="s2">&quot;sleep 30&quot;</span>
<span class="go">ˆ\sh: 946                                # Quit we press the quit key</span>
<span class="go">normal termination, exit status = 131</span>
</pre></div>


<p>When we terminate the <code>sleep</code> call with the interrupt signal, the <code>pr_exit</code> function (Figure 8.5) thinks that it terminated normally. The same thing happens when we kill the <code>sleep</code> call with the quit key. This is because the Bourne shell has a poorly documented feature in which its termination status is 128 plus the signal number, when the command it was executing is terminated by a signal. [p372]</p>
<p>Try a similar example, but this time we’ll send a signal directly to the shell and see what is returned by system:</p>
<div class="codehilite"><pre><span class="gp">$</span> tsys <span class="s2">&quot;sleep 30&quot;</span> <span class="p">&amp;</span>      <span class="c1"># start it in background this time</span>
<span class="go">9257</span>
<span class="gp">$</span> ps -f                  <span class="c1"># look at the process IDs</span>
<span class="go">UID PID PPID TTY TIME CMD</span>
<span class="go">sar 9260 949 pts/5 0:00 ps -f</span>
<span class="go">sar 9258 9257 pts/5 0:00 sh -c sleep 30</span>
<span class="go">sar 949 947 pts/5 0:01 /bin/sh</span>
<span class="go">sar 9257 949 pts/5 0:00 tsys sleep 30</span>
<span class="go">sar 9259 9258 pts/5 0:00 sleep 30</span>
<span class="gp">$</span> <span class="nb">kill</span> -KILL <span class="m">9258</span>        <span class="c1"># kill the shell itself</span>
<span class="go">abnormal termination, signal number = 9</span>
</pre></div>


<p>We can see that the return value from system reports an abnormal termination only when the shell itself terminates abnormally.</p>
<p>Other shells behave differently when handling terminal-generated signals, such as <code>SIGINT</code> and <code>SIGQUIT</code>. With <code>bash</code> and <code>dash</code>, for example, pressing the interrupt or quit key will result in an exit status indicating abnormal termination with the corresponding signal number. However, if we find our process executing <code>sleep</code> and send it a signal directly, so that the signal goes only to the individual process instead of the entire foreground process group, we will find that these shells behave like the Bourne shell and exit with a normal termination status of 128 plus the signal number.</p>
<p>When writing programs that use the <code>system</code> function, be sure to interpret the return value correctly. If you call <code>fork</code>, <code>exec</code>, and <code>wait</code> yourself, the termination status is not the same as if you call system.</p>
<h3 id="sleep-nanosleep-and-clock_nanosleep-functions"><code>sleep</code>, <code>nanosleep</code>, and <code>clock_nanosleep</code> Functions<a class="headerlink" href="#sleep-nanosleep-and-clock_nanosleep-functions" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">sleep</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">seconds</span><span class="p">);</span>

<span class="cm">/* Returns: 0 or number of unslept seconds */</span>
</pre></div>


<p>The <code>sleep</code> function causes the calling process to be suspended until either:</p>
<ol>
<li>The amount of wall clock time specified by seconds has elapsed. In this case, the return value is 0.</li>
<li>A signal is caught by the process and the signal handler returns. In this case the return value is the number of unslept seconds (the requested time minus the actual time slept).</li>
</ol>
<p>As with an <code>alarm</code> signal, the actual return may occur at a time later than requested because of other system activity.</p>
<p>Although sleep can be implemented with the <code>alarm</code> function (<a href="#alarm-and-pause-functions">Section 10.10</a>), this isn’t required. If <code>alarm</code> is used, there can be interactions between the two functions. The POSIX.1 standard leaves all these interactions unspecified.</p>
<p>FreeBSD 8.0, Linux 3.2.0, Mac OS X 10.6.8, and Solaris 10 implement <code>sleep</code> using the <code>nanosleep</code> function, which allows the implementation to be independent of signals and the alarm timer.</p>
<p>The follow example shows an implementation of the POSIX.1 <code>sleep</code> function. This function is a modification of <a href="#sleep1-example">Figure 10.7</a>, which handles signals reliably, avoiding the race condition in the earlier implementation, but does not handle any interactions with previously set alarms.</p>
<p><small><a href="https://github.com/shichao-an/apue.3e/blob/master/lib/sleep.c">lib/sleep.c</a></small></p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&quot;apue.h&quot;</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sig_alrm</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* nothing to do, just returning wakes up sigsuspend() */</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">sleep</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">seconds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">sigaction</span>    <span class="n">newact</span><span class="p">,</span> <span class="n">oldact</span><span class="p">;</span>
    <span class="kt">sigset_t</span>            <span class="n">newmask</span><span class="p">,</span> <span class="n">oldmask</span><span class="p">,</span> <span class="n">suspmask</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>        <span class="n">unslept</span><span class="p">;</span>

    <span class="cm">/* set our handler, save previous information */</span>
    <span class="n">newact</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">=</span> <span class="n">sig_alrm</span><span class="p">;</span>
    <span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newact</span><span class="p">.</span><span class="n">sa_mask</span><span class="p">);</span>
    <span class="n">newact</span><span class="p">.</span><span class="n">sa_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">sigaction</span><span class="p">(</span><span class="n">SIGALRM</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newact</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldact</span><span class="p">);</span>

    <span class="cm">/* block SIGALRM and save current signal mask */</span>
    <span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newmask</span><span class="p">);</span>
    <span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newmask</span><span class="p">,</span> <span class="n">SIGALRM</span><span class="p">);</span>
    <span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_BLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newmask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldmask</span><span class="p">);</span>

    <span class="n">alarm</span><span class="p">(</span><span class="n">seconds</span><span class="p">);</span>
    <span class="n">suspmask</span> <span class="o">=</span> <span class="n">oldmask</span><span class="p">;</span>

    <span class="cm">/* make sure SIGALRM isn&#39;t blocked */</span>
    <span class="n">sigdelset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">suspmask</span><span class="p">,</span> <span class="n">SIGALRM</span><span class="p">);</span>

    <span class="cm">/* wait for any signal to be caught */</span>
    <span class="n">sigsuspend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">suspmask</span><span class="p">);</span>

    <span class="cm">/* some signal has been caught, SIGALRM is now blocked */</span>

    <span class="n">unslept</span> <span class="o">=</span> <span class="n">alarm</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="cm">/* reset previous action */</span>
    <span class="n">sigaction</span><span class="p">(</span><span class="n">SIGALRM</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldact</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="cm">/* reset signal mask, which unblocks SIGALRM */</span>
    <span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_SETMASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldmask</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">return</span><span class="p">(</span><span class="n">unslept</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>This code doesn't use any form of nonlocal branching (as in <a href="#sleep2-example-using-setjmp-and-longjmp">Figure 10.8</a> to avoid the race condition between alarm and pause), so there is no effect on other signal handlers that may be executing when the <code>SIGALRM</code> is handled.</p>
<p>The <code>nanosleep</code> function is similar to the <code>sleep</code> function, but provides nanosecond-level granularity.</p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&lt;time.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">nanosleep</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">reqtp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">remtp</span><span class="p">);</span>

<span class="cm">/* Returns: 0 if slept for requested time or −1 on error */</span>
</pre></div>


<p>This function suspends the calling process until either the requested time has elapsed or the function is interrupted by a signal.</p>
<p>Arguments:</p>
<ul>
<li>The <em>reqtp</em> parameter specifies the amount of time to sleep in seconds and nanoseconds.</li>
<li>The <em>remtp</em> parameter. If the sleep interval is interrupted by a signal and the process doesn’t terminate, the <code>timespec</code> structure pointed to by the <em>remtp</em> parameter will be set to the amount of time left in the sleep interval. We can set this parameter to NULL if we are uninterested in the time unslept.</li>
</ul>
<p>Notes on <code>nanosleep</code>:</p>
<ul>
<li>If the system doesn’t support nanosecond granularity, the requested time is rounded up.</li>
<li>Because the nanosleep function doesn’t involve the generation of any signals, we can use it without worrying about interactions with other functions.</li>
</ul>
<p>The <code>clock_nanosleep</code> function provides the capability to suspend the calling thread using a delay time relative to a particular clock, using multiple system clocks (<a href="../ch6/#time-and-date-routines">Section 6.10</a>)</p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&lt;time.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">clock_nanosleep</span><span class="p">(</span><span class="kt">clockid_t</span> <span class="n">clock_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
                    <span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">reqtp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">remtp</span><span class="p">);</span>

<span class="cm">/* Returns: 0 if slept for requested time or error number on failure */</span>
</pre></div>


<p>Arguments:</p>
<ul>
<li>The <em>clock_id</em> argument specifies the clock against which the time delay is evaluated. Identifiers for clocks are listed in <a href="#clock-type-identifiers">Figure 6.8</a>.</li>
<li>The <em>flags</em> argument is used to control whether the delay is absolute or relative.<ul>
<li>When flags is set to 0, the sleep time is relative (how long we want to sleep).</li>
<li>When it is set to <code>TIMER_ABSTIME</code>, the sleep time is absolute (we want to sleep until the clock reaches the specified time).</li>
</ul>
</li>
<li>The <em>reqtp</em> and <em>remtp</em> arguments are the same as in the <code>nanosleep</code> function. However:<ul>
<li>When we use an absolute time, the <em>remtp</em> argument is unused, because it isn’t needed.</li>
<li>We can reuse the same value for the <em>reqtp</em> argument for additional calls to <code>clock_nanosleep</code> until the clock reaches the specified absolute time value.</li>
</ul>
</li>
</ul>
<p>Except for error returns, the call:</p>
<div class="codehilite"><pre><span class="n">clock_nanosleep</span><span class="p">(</span><span class="n">CLOCK_REALTIME</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">reqtp</span><span class="p">,</span> <span class="n">remtp</span><span class="p">);</span>
</pre></div>


<p>has the same effect as the call:</p>
<div class="codehilite"><pre><span class="n">nanosleep</span><span class="p">(</span><span class="n">reqtp</span><span class="p">,</span> <span class="n">remtp</span><span class="p">);</span>
</pre></div>


<p>Some applications require precision with how long they sleep, and a relative sleep time can lead to sleeping longer than desired. Using an absolute time improves the precision, even though a time-sharing process scheduler makes no guarantee that our task will execute immediately after our sleep time has ended. [p375]</p>
<h3 id="sigqueue-function"><code>sigqueue</code> Function<a class="headerlink" href="#sigqueue-function" title="Permanent link">&para;</a></h3>
<p>As discussed in <a href="#reliable-signal-terminology-and-semantics">Section 10.8</a>, most UNIX systems don’t queue signals. With the real-time extensions to POSIX.1, some systems began adding support for queueing signals. With SUSv4, the queued signal functionality has moved from the real-time extensions to the base specification.</p>
<p>These extensions allow applications to pass more information along with the delivery (<a href="#sigaction-function">Section 10.14</a>). This information is embedded in a <code>siginfo</code> structure.</p>
<p>To use queued signals we have to do the following:</p>
<ol>
<li>Specify the <code>SA_SIGINFO</code> flag when we install a signal handler using the <code>sigaction</code> function. Without this flag, it is left up to the implementation whether the signal is queued.</li>
<li>Provide a signal handler in the <code>sa_sigaction</code> member of the <code>sigaction</code> structure instead of using the usual <code>sa_handler</code> field. Implementations might allow us to use the <code>sa_handler</code> field, but we won’t be able to obtain the extra information sent with the <code>sigqueue</code> function.</li>
<li>Use the <code>sigqueue</code> function to send signals.</li>
</ol>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="n">sigqueue</span><span class="p">(</span><span class="kt">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">signo</span><span class="p">,</span> <span class="k">const</span> <span class="k">union</span> <span class="n">sigval</span> <span class="n">value</span><span class="p">)</span>

<span class="cm">/* Returns: 0 if OK, −1 on error */</span>
</pre></div>


<p>The <code>sigqueue</code> function is similar to the <code>kill</code> function, except that:</p>
<ul>
<li>We can only direct signals to a single process</li>
<li>We can use the <em>value</em> argument to transmit either an integer or a pointer value to the signal handler.</li>
</ul>
<p>Signals can’t be queued infinitely. When the SIGQUEUE_MAX limit (<a href="../ch2/#posix-limits">POSIX Limits</a>) is reached, <code>sigqueue</code> can fail with <code>errno</code> set to
<code>EAGAIN</code>.</p>
<p>With the real-time signal enhancements, other signal numbers between <code>SIGRTMIN</code> and <code>SIGRTMAX</code> inclusive can be queued, and the  default action for these signals is to terminate the process. [p376]</p>
<p>The table below summarizes behavior of queued signals on various platforms:</p>
<table>
<thead>
<tr>
<th>Behavior</th>
<th>SUS</th>
<th>FreeBSD</th>
<th>Linux</th>
<th>Mac OS X</th>
<th>Solaris</th>
</tr>
</thead>
<tbody>
<tr>
<td>supports <code>sigqueue</code></td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
</tr>
<tr>
<td>queues other signals besides SIGRTMIN to SIGRTMAX</td>
<td>optional</td>
<td>x</td>
<td></td>
<td></td>
<td>x</td>
</tr>
<tr>
<td>queues signals even if the caller doesn’t use the <code>SA_SIGINFO</code></td>
<td>optional</td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="job-control-signals">Job-Control Signals<a class="headerlink" href="#job-control-signals" title="Permanent link">&para;</a></h3>
<p>POSIX.1 considers six to be job-control signals:</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SIGCHLD</code></td>
<td>Child process has stopped or terminated.</td>
</tr>
<tr>
<td><code>SIGCONT</code></td>
<td>Continue process, if stopped.</td>
</tr>
<tr>
<td><code>SIGSTOP</code></td>
<td>Stop signal (can’t be caught or ignored).</td>
</tr>
<tr>
<td><code>SIGTSTP</code></td>
<td>Interactive stop signal.</td>
</tr>
<tr>
<td><code>SIGTTIN</code></td>
<td>Read from controlling terminal by background process group member.</td>
</tr>
<tr>
<td><code>SIGTTOU</code></td>
<td>Write to controlling terminal by a background process group member.</td>
</tr>
</tbody>
</table>
<p>The following program demonstrates the normal sequence of code used when a program handles job control.</p>
<p><small><a href="https://github.com/shichao-an/apue.3e/blob/master/signals/sigtstp.c">signals/sigtstp.c</a></small></p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&quot;apue.h&quot;</span><span class="cp"></span>

<span class="cp">#define BUFFSIZE    1024</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sig_tstp</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">)</span> <span class="cm">/* signal handler for SIGTSTP */</span>
<span class="p">{</span>
    <span class="kt">sigset_t</span>    <span class="n">mask</span><span class="p">;</span>

    <span class="cm">/* ... move cursor to lower left corner, reset tty mode ... */</span>

    <span class="cm">/*</span>
<span class="cm">     * Unblock SIGTSTP, since it&#39;s blocked while we&#39;re handling it.</span>
<span class="cm">     */</span>
    <span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mask</span><span class="p">);</span>
    <span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mask</span><span class="p">,</span> <span class="n">SIGTSTP</span><span class="p">);</span>
    <span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_UNBLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mask</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="n">signal</span><span class="p">(</span><span class="n">SIGTSTP</span><span class="p">,</span> <span class="n">SIG_DFL</span><span class="p">);</span>   <span class="cm">/* reset disposition to default */</span>

    <span class="n">kill</span><span class="p">(</span><span class="n">getpid</span><span class="p">(),</span> <span class="n">SIGTSTP</span><span class="p">);</span>    <span class="cm">/* and send the signal to ourself */</span>

    <span class="cm">/* we won&#39;t return from the kill until we&#39;re continued */</span>

    <span class="n">signal</span><span class="p">(</span><span class="n">SIGTSTP</span><span class="p">,</span> <span class="n">sig_tstp</span><span class="p">);</span>  <span class="cm">/* reestablish signal handler */</span>

    <span class="cm">/* ... reset tty mode, redraw screen ... */</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span>     <span class="n">n</span><span class="p">;</span>
    <span class="kt">char</span>    <span class="n">buf</span><span class="p">[</span><span class="n">BUFFSIZE</span><span class="p">];</span>

    <span class="cm">/*</span>
<span class="cm">     * Only catch SIGTSTP if we&#39;re running with a job-control shell.</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">signal</span><span class="p">(</span><span class="n">SIGTSTP</span><span class="p">,</span> <span class="n">SIG_IGN</span><span class="p">)</span> <span class="o">==</span> <span class="n">SIG_DFL</span><span class="p">)</span>
        <span class="n">signal</span><span class="p">(</span><span class="n">SIGTSTP</span><span class="p">,</span> <span class="n">sig_tstp</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">STDIN_FILENO</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">BUFFSIZE</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">STDOUT_FILENO</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;write error&quot;</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;read error&quot;</span><span class="p">);</span>

    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>This program does the following:</p>
<ul>
<li>When the program starts, it arranges to catch the <code>SIGTSTP</code> signal only if the signal’s disposition is <code>SIG_DFL</code>. The reason is that <u>when the program is started by a shell that doesn’t support job control (<code>/bin/sh</code>, for example), the signal’s disposition should be set to <code>SIG_IGN</code>. In fact, the shell doesn’t explicitly ignore this signal; <code>init</code> sets the disposition of the three job-control signals (<code>SIGTSTP</code>, <code>SIGTTIN</code>, and <code>SIGTTOU</code>) to <code>SIG_IGN</code>. This disposition is then inherited by all login shells. Only a job-control shell should reset the disposition of these three signals to <code>SIG_DFL</code>.</u></li>
<li>When we type the suspend character, the process receives the <code>SIGTSTP</code> signal and the signal handler is invoked. At this point, we would do any terminal-related processing: move the cursor to the lower-left corner, restore the terminal mode, etc.</li>
<li>After resetting the disposition of <code>SIGSTOP</code> to its default (stop the process) and unblocking it, we send ourself the <code>SIGSTOP</code> signal (<code>kill(getpid(), SIGTSTP);</code>). We have to unblock it since we’re currently handling that same signal, and the system blocks it automatically while it’s being caught.</li>
<li>At this point, the system stops the process. It is continued only when it receives (usually from the job-control shell, in response to an interactive <code>fg</code> command) a <code>SIGCONT</code> signal.</li>
<li>We don’t catch <code>SIGCONT</code> since its default disposition is to continue the stopped process; when this happens, the program continues as though it returned from the <code>kill</code> function. When the program is continued, we reset the disposition for the <code>SIGTSTP</code> signal and do any terminal processing (as indicated in the comments).</li>
</ul>
<h3 id="signal-names-and-numbers">Signal Names and Numbers<a class="headerlink" href="#signal-names-and-numbers" title="Permanent link">&para;</a></h3>
<p>This section discusses how to map between signal numbers and names. Some systems provide the array:</p>
<div class="codehilite"><pre><span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sys_siglist</span><span class="p">[];</span>
</pre></div>


<p>The array index is the signal number, giving a pointer to the character string name of the signal. [p379]</p>
<p>To print the signal's character string in a portable manner, use the <code>psignal</code> function:</p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">psignal</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">);</span>
</pre></div>


<p>The string <em>msg</em> (which normally includes the name of the program) is output to the standard error, followed by a colon and a space, followed by a description of the signal, followed by a newline. If <em>msg</em> is <code>NULL</code>, then only the description is written to the standard error. This function is similar to <code>perror</code> (<a href="../ch1/#error-handling">Section 1.7</a>).</p>
<p>If you have a <code>siginfo</code> structure from an alternative <code>sigaction</code> signal handler, you can print the signal information with the <code>psiginfo</code> function.</p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">psiginfo</span><span class="p">(</span><span class="k">const</span> <span class="kt">siginfo_t</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">);</span>
</pre></div>


<p>You can use the <code>strsignal</code> function if you only need the string description of the signal. This function is similar to <code>strerror</code> (<a href="../ch1/#error-handling">Section 1.7</a>).</p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>

<span class="kt">char</span> <span class="o">*</span><span class="nf">strsignal</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">);</span>

<span class="cm">/* Returns: a pointer to a string describing the signal */</span>
</pre></div>


<h3 id="summary">Summary<a class="headerlink" href="#summary" title="Permanent link">&para;</a></h3>
<p>An understanding of signal handling is essential to advanced UNIX System programming. This chapter has taken a long and thorough look at UNIX System signals, from previous implementations to the POSIX.1 reliable-signal concept and all the related functions, followed by POSIX.1 <code>abort</code>, <code>system</code>, and <code>sleep</code> functions.</p>
<h3 id="doubts-and-solutions">Doubts and Solutions<a class="headerlink" href="#doubts-and-solutions" title="Permanent link">&para;</a></h3>
<h4 id="verbatim">Verbatim<a class="headerlink" href="#verbatim" title="Permanent link">&para;</a></h4>
<h5 id="p324-on-some-macro-constants-in-signalh"><strong>p324 on some macro constants in <code>&lt;signal.h&gt;</code></strong><a class="headerlink" href="#p324-on-some-macro-constants-in-signalh" title="Permanent link">&para;</a></h5>
<blockquote>
<p>These constants can be used in place of the "pointer to a function that takes an integer argument and returns nothing", the second argument to <code>signal</code>, and the return value from <code>signal</code>. The three values used for these constants need not be −1, 0, and 1. They must be three values that can never be the address of any declarable function. Most UNIX systems use the values shown.</p>
</blockquote>
<p><span class="text-danger">Question</span>: Why is the macro in the form <code>SIG_ERR (void (*)())-1</code> and the like?</p>
<p><span class="text-info">Solution</span>: They are integer that cast into an address which means the "pointer to a function that takes an integer argument and returns nothing". <code>void (*)()</code> tells the compiler to ignore type-checking for the parameters. See:</p>
<ul>
<li><a href="http://stackoverflow.com/questions/22344303">Stack Overflow</a></li>
</ul>
<h5 id="p359-on-unblocking-signals"><strong>p359 on unblocking signals</strong><a class="headerlink" href="#p359-on-unblocking-signals" title="Permanent link">&para;</a></h5>
<blockquote>
<p>If the signal is sent to the process while it is blocked, the signal delivery will be deferred until the signal is unblocked. To the application, this can look as if the signal occurs between the unblocking and the <code>pause</code> (depending on how the kernel implements signals). If this happens, or if the signal does occur between the unblocking and the <code>pause</code>, we have a problem. Any occurrence of the signal in this window of time is lost, in the sense that we might not see the signal again, in which case the <code>pause</code> will block indefinitely. This is another problem with the earlier unreliable signals.</p>
</blockquote>
<p><span class="text-danger">Question</span>: What is exactly the window? Shouldn't be the unblocked signals delivered to the process? Not fully understood.</p>
            </div>
        </div>

        <footer class="col-md-12">
            
        </footer>

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script>
        <script src="../../js/base.js"></script>
        <script src="../../custom.js"></script>
    </body>
</html>