<!DOCTYPE html>
<html lang="en">
    <head>
        <!-- Global Site Tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-59055167-2"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments)};
          gtag('js', new Date());

          gtag('config', 'UA-59055167-2');
        </script>

        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://notes.shichao.io/csn/part1/">
        <link rel="shortcut icon" href="../../toki_32.png">
        

	<title>Part 1: Language - Shichao's Notes</title>

        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../../css/base.css" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,400italic,500,600" rel="stylesheet">
        <link href="../../custom.css" rel="stylesheet">
        <link href="../../friendly.css" rel="stylesheet">
        <link href="../../theme.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        
<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../..">Shichao's Notes</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">APUE <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../apue/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch1/">Chapter 1. UNIX System Overview</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch2/">Chapter 2. UNIX Standardization and Implementations</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch3/">Chapter 3. File I/O</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch4/">Chapter 4. Files and Directories</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch5/">Chapter 5. Standard I/O Library</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch6/">Chapter 6. System Data Files and Information</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch7/">Chapter 7. Process Environment</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch8/">Chapter 8. Process Control</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch9/">Chapter 9. Process Relationships</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch10/">Chapter 10. Signals</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch11/">Chapter 11. Threads</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch12/">Chapter 12. Thread Control</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch13/">Chapter 13. Daemon Processes</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch14/">Chapter 14. Advanced I/O</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch15/">Chapter 15. Interprocess Communication</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch16/">Chapter 16. Network IPC: Sockets</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch17/">Chapter 17. Advanced IPC</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UNP <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../unp/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch2/">Chapter 2. The Transport Layer: TCP, UDP, and SCTP</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch3/">Chapter 3. Sockets Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch4/">Chapter 4. Elementary TCP Sockets</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch5/">Chapter 5. TCP Client/Server Example</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch6/">Chapter 6. I/O Multiplexing: The select and poll Functions</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch7/">Chapter 7. Socket Options</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch8/">Chapter 8. Elementary UDP Sockets</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">TCPv1 <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../tcpv1/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch2/">Chapter 2. The Internet Address Architecture</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch3/">Chapter 3. Link Layer</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch4/">Chapter 4. ARP: Address Resolution Protocol</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch5/">Chapter 5. The Internet Protocol (IP)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch6/">Chapter 6. System Configuration: DHCP and Autoconfiguration</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch7/">Chapter 7. Firewalls and Network Address Translation (NAT)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch8/">Chapter 8. ICMPv4 and ICMPv6: Internet Control Message Protocol</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch9/">Chapter 9. Broadcasting and Local Multicasting (IGMP and MLD)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch10/">Chapter 10. User Datagram Protocol (UDP) and IP Fragmentation</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch11/">Chapter 11. Name Resolution and the Domain Name System (DNS)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch12/">Chapter 12. TCP: The Transmission Control Protocol (Preliminaries)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch13/">Chapter 13. TCP Connection Management</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch14/">Chapter 14. TCP Timeout and Retransmission</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch15/">Chapter 15. TCP Data Flow and Window Management</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch16/">Chapter 16. TCP Congestion Control</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch17/">Chapter 17. TCP Keepalive</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch18/">Chapter 18. Security: EAP, IPsec, TLS, DNSSEC, and DKIM</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/headers/">Headers</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">GOPL <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../gopl/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch1/">Chapter 1. Tutorial</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch2/">Chapter 2. Program Structure</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch3/">Chapter 3. Basic Data Types</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch4/">Chapter 4. Composite Types</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch5/">Chapter 5. Functions</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch6/">Chapter 6. Methods</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch7/">Chapter 7. Interfaces</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch8/">Chapter 8. Goroutines and Channels</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch9/">Chapter 9. Concurrency with Shared Variables</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch10/">Chapter 10. Packages and the Go Tool</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch11/">Chapter 11. Testing</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch12/">Chapter 12. Reflection</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">CSN <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../">Contents</a>
                        </li>
                      
                        <li class="active">
                            <a href="./">Part 1: Language</a>
                        </li>
                      
                        <li>
                            <a href="../part2/">Part 2: Advanced</a>
                        </li>
                      
                    </ul>
                </li>
            <li>
                    <a href="../../toc/">TOC</a>
                </li>
            </ul>
            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    
                        <a href="https://github.com/shichao-an/notes/blob/master/docs/csn/part1.md">
                    
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#part-1-language">Part 1: Language</a></li>
        
    
        <li class="main "><a href="#data-types">Data Types</a></li>
        
            <li><a href="#integers">Integers</a></li>
        
            <li><a href="#floating-point-numbers">Floating-Point Numbers</a></li>
        
            <li><a href="#enumerations">Enumerations</a></li>
        
    
        <li class="main "><a href="#literals">Literals</a></li>
        
            <li><a href="#integer-constants">Integer Constants</a></li>
        
            <li><a href="#floating-constants">Floating Constants</a></li>
        
            <li><a href="#character-constants_1">Character Constants</a></li>
        
            <li><a href="#string-literals">String Literals</a></li>
        
    
        <li class="main "><a href="#type-conversions">Type Conversions</a></li>
        
            <li><a href="#arithmetic-conversions">Arithmetic conversions</a></li>
        
            <li><a href="#non-arithmetic-conversions">Non-arithmetic conversions</a></li>
        
    
        <li class="main "><a href="#operators">Operators</a></li>
        
            <li><a href="#compound-literals">Compound Literals</a></li>
        
            <li><a href="#sizeof">sizeof</a></li>
        
            <li><a href="#comma-operator">Comma Operator</a></li>
        
            <li><a href="#precedence">Precedence</a></li>
        
    
        <li class="main "><a href="#statements">Statements</a></li>
        
            <li><a href="#statement-blocks">Statement Blocks</a></li>
        
            <li><a href="#loop-statements">Loop Statements</a></li>
        
            <li><a href="#selection-statements">Selection Statements</a></li>
        
            <li><a href="#jump-statements">Jump Statements</a></li>
        
    
        <li class="main "><a href="#functions">Functions</a></li>
        
            <li><a href="#nested-functions">Nested Functions</a></li>
        
            <li><a href="#function-types">Function Types</a></li>
        
            <li><a href="#function-calls">Function Calls</a></li>
        
            <li><a href="#storage-class-specifiers">Storage-class Specifiers</a></li>
        
            <li><a href="#variadic-arguments">Variadic Arguments</a></li>
        
    
        <li class="main "><a href="#arrays">Arrays</a></li>
        
            <li><a href="#variable-length-arrays">Variable-Length Arrays</a></li>
        
            <li><a href="#subscripts">Subscripts</a></li>
        
            <li><a href="#initialization">Initialization</a></li>
        
            <li><a href="#strings">Strings</a></li>
        
            <li><a href="#multidimensional-arrays">Multidimensional Arrays</a></li>
        
            <li><a href="#array-arguments">Array Arguments</a></li>
        
    
        <li class="main "><a href="#pointers">Pointers</a></li>
        
            <li><a href="#void-pointers">void Pointers</a></li>
        
            <li><a href="#initializing-pointers">Initializing Pointers</a></li>
        
            <li><a href="#pointer-operations">Pointer Operations</a></li>
        
            <li><a href="#qualifiers">Qualifiers</a></li>
        
            <li><a href="#pointer-to-array">Pointer to Array</a></li>
        
            <li><a href="#array-of-pointers">Array of Pointers</a></li>
        
    
        <li class="main "><a href="#structs">Structs</a></li>
        
            <li><a href="#incomplete-structs">Incomplete Structs</a></li>
        
            <li><a href="#anonymous-stucts">Anonymous Stucts</a></li>
        
            <li><a href="#member-offsets">Member Offsets</a></li>
        
            <li><a href="#struct-definitions">Struct Definitions</a></li>
        
            <li><a href="#struct-initialization">Struct Initialization</a></li>
        
            <li><a href="#flexible-array-member">Flexible Array Member</a></li>
        
    
        <li class="main "><a href="#union">Union</a></li>
        
    
        <li class="main "><a href="#bit-fields">Bit Fields</a></li>
        
    
        <li class="main "><a href="#declarations">Declarations</a></li>
        
            <li><a href="#type-qualifiers">Type Qualifiers</a></li>
        
            <li><a href="#linkage">Linkage</a></li>
        
            <li><a href="#implicit-initialization">Implicit Initialization</a></li>
        
    
        <li class="main "><a href="#preprocessor">Preprocessor</a></li>
        
            <li><a href="#constants">Constants</a></li>
        
            <li><a href="#macro-functions">Macro Functions</a></li>
        
            <li><a href="#variadic-macros">Variadic Macros</a></li>
        
            <li><a href="#stringification-operator">Stringification Operator</a></li>
        
            <li><a href="#token-pasting-operator">Token-pasting Operator</a></li>
        
            <li><a href="#conditional-compilation">Conditional Compilation</a></li>
        
            <li><a href="#typeof">typeof</a></li>
        
            <li><a href="#others">Others</a></li>
        
    
        <li class="main "><a href="#debugging">Debugging</a></li>
        
    
        <li class="main "><a href="#doubts-and-solutions">Doubts and Solutions</a></li>
        
            <li><a href="#verbatim">Verbatim</a></li>
        
    
        <li class="main "><a href="#references">References</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">
              

<h3 id="part-1-language"><strong>Part 1: Language</strong><a class="headerlink" href="#part-1-language" title="Permanent link">&para;</a></h3>
<ul>
<li><a href="https://en.wikipedia.org/wiki/C99">C99</a> is discussed.</li>
<li>The examples are based on 32-bit GCC.</li>
</ul>
<h3 id="data-types">Data Types<a class="headerlink" href="#data-types" title="Permanent link">&para;</a></h3>
<h4 id="integers">Integers<a class="headerlink" href="#integers" title="Permanent link">&para;</a></h4>
<p>The following are basic integer keywords:</p>
<ul>
<li><code>char</code>: signed 8-bit integer.</li>
<li><code>short</code>: signed 16-bit integer.</li>
<li><code>int</code>: signed 32-bit integer.</li>
<li><code>long</code>: 32-bit integer on the 32-bit system (<code>long int</code>), and 64-bit integer on the 64-bit system.</li>
<li><code>long long</code>: signed 64-bit integer (<code>long long int</code>).</li>
<li><code>bool</code>: <code>_Bool</code> type, 8-bit integer. The macros <code>bool</code>, <code>true</code> and <code>false</code> are defined in <code>stdbool.h</code>.</li>
</ul>
<p>Since on different systems <code>char</code> may represent a signed or unsigned 8-bit integer, it's recommended to use <code>unsigned char</code> or <code>signed char</code> to represent an exact type.</p>
<p>In <code>stdint.h</code>, more specific integer types are defined:</p>
<p><small><a href="https://github.com/shichao-an/glibc-2.21/blob/master/sysdeps/generic/stdint.h">stdint.h</a></small></p>
<div class="codehilite"><pre><span class="k">typedef</span> <span class="kt">signed</span> <span class="kt">char</span>                <span class="kt">int8_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">short</span> <span class="kt">int</span>                  <span class="kt">int16_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">int</span>                        <span class="kt">int32_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">char</span>              <span class="kt">uint8_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="kt">int</span>         <span class="kt">uint16_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span>               <span class="kt">uint32_t</span><span class="p">;</span>

<span class="cp">#if __WORDSIZE == 64</span>
    <span class="k">typedef</span> <span class="kt">long</span> <span class="kt">int</span>               <span class="kt">int64_t</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">int</span>      <span class="kt">uint64_t</span><span class="p">;</span>
<span class="cp">#else</span>
    <span class="n">__extension__</span>
    <span class="k">typedef</span> <span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span>          <span class="kt">int64_t</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span> <span class="kt">uint64_t</span><span class="p">;</span>
<span class="cp">#endif</span>
</pre></div>


<p>There are also size limits of these integer types:</p>
<div class="codehilite"><pre><span class="cp"># define INT8_MIN (-128)</span>
<span class="cp"># define INT16_MIN (-32767-1)</span>
<span class="cp"># define INT32_MIN (-2147483647-1)</span>
<span class="cp"># define INT64_MIN (-__INT64_C(9223372036854775807)-1)</span>

<span class="cp"># define INT8_MAX (127)</span>
<span class="cp"># define INT16_MAX (32767)</span>
<span class="cp"># define INT32_MAX (2147483647)</span>
<span class="cp"># define INT64_MAX (__INT64_C(9223372036854775807))</span>

<span class="cp"># define UINT8_MAX (255)</span>
<span class="cp"># define UINT16_MAX (65535)</span>
<span class="cp"># define UINT32_MAX (4294967295U)</span>
<span class="cp"># define UINT64_MAX (__UINT64_C(18446744073709551615))</span>
</pre></div>


<h5 id="character-constants"><strong>Character Constants</strong> *<a class="headerlink" href="#character-constants" title="Permanent link">&para;</a></h5>
<p>A <a href="http://en.cppreference.com/w/c/language/character_constant">character constant</a> by default is an integer of type <code>int</code>. However, the compiler determines whether to interpret it into <code>char</code> or <code>int</code>.</p>
<p>The following code:</p>
<div class="codehilite"><pre><span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%c, size(char)=%d, size(&#39;a&#39;)=%d;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">));</span>
</pre></div>


<p>will output:</p>
<div class="codehilite"><pre>a, size(char)=1, size(&#39;a&#39;)=4;
</pre></div>


<h5 id="the-type-of-a-pointer"><strong>The Type of a Pointer</strong> *<a class="headerlink" href="#the-type-of-a-pointer" title="Permanent link">&para;</a></h5>
<p>A pointer is a special-purpose integer, whose type is also defined in <code>stdint.h</code>.</p>
<div class="codehilite"><pre><span class="cm">/* Types for `void *&#39; pointers. */</span>
<span class="cp">#if __WORDSIZE == 64</span>
    <span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">int</span> <span class="kt">uintptr_t</span><span class="p">;</span>
<span class="cp">#else</span>
    <span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="kt">uintptr_t</span><span class="p">;</span>
<span class="cp">#endif</span>
</pre></div>


<p>But in the code we usually use the expression <code>sizeof(char*)</code> to save the trouble of differentiating 32-bit and 64-bit.</p>
<h5 id="representing-integer-constants"><strong>Representing Integer Constants</strong> *<a class="headerlink" href="#representing-integer-constants" title="Permanent link">&para;</a></h5>
<p>We can use different suffixes to represent <a href="http://en.cppreference.com/w/c/language/integer_constant">integer constants</a>. The following code:</p>
<div class="codehilite"><pre><span class="n">printf</span><span class="p">(</span><span class="s">&quot;int size=%d;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;unsigned int size=%d;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="mi">1U</span><span class="p">));</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;long size=%d;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="mi">1L</span><span class="p">));</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;unsigned long size=%d;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="mi">1UL</span><span class="p">));</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;long long size=%d;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="mi">1LL</span><span class="p">));</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;unsigned long long size=%d;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="mi">1ULL</span><span class="p">));</span>
</pre></div>


<p>will output:</p>
<div class="codehilite"><pre>int size=4;
unsigned int size=4;
long size=4;
unsigned long size=4;
long long size=8;
unsigned long long size=8;
</pre></div>


<h5 id="helper-macros-__int64_c-and-__uint64_c"><strong>Helper Macros: <code>__INT64_C</code> and <code>__UINT64_C</code></strong> *<a class="headerlink" href="#helper-macros-__int64_c-and-__uint64_c" title="Permanent link">&para;</a></h5>
<p>Some helper macros are defined in <code>stdint.h</code>.</p>
<div class="codehilite"><pre><span class="cp"># if __WORDSIZE == 64</span>
<span class="cp"># define __INT64_C(c) c ## L</span>
<span class="cp"># define __UINT64_C(c) c ## UL</span>
<span class="cp"># else</span>
<span class="cp"># define __INT64_C(c) c ## LL</span>
<span class="cp"># define __UINT64_C(c) c ## ULL</span>
<span class="cp"># endif</span>
</pre></div>


<p>Note that the <code>##</code> operator in the macro means combining the left and right operands together as a symbol.</p>
<h4 id="floating-point-numbers">Floating-Point Numbers<a class="headerlink" href="#floating-point-numbers" title="Permanent link">&para;</a></h4>
<h5 id="real-floating-types"><strong>Real floating types</strong> *<a class="headerlink" href="#real-floating-types" title="Permanent link">&para;</a></h5>
<p>C has three types of different precisions for representing <a href="http://en.cppreference.com/w/c/language/arithmetic_types#Real_floating_types">real floating-point</a> values:</p>
<ul>
<li><code>float</code>: 32-bit, 4-byte floating-point number, which has a precision (number of significant decimal digits) of 6 (<code>FLT_DIG</code>, defined in <code>&lt;float.h&gt;</code>).</li>
<li><code>double</code>: 64-bit, 8-byte floating-point number, which has a precision of 15 (<code>DBL_DIG</code>).</li>
<li><code>long double</code>: 80-bit, 10-byte floating-point number, which has a precision of 19 (<code>LDBL_DIG</code>).</li>
</ul>
<p>The default floating type is <code>double</code>. Suffix <code>F</code> represents <code>float</code> and <code>L</code> represents <code>long double</code>.</p>
<p>The following code:</p>
<div class="codehilite"><pre><span class="n">printf</span><span class="p">(</span><span class="s">&quot;float %f size=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mf">1.F</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="mf">1.F</span><span class="p">));</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;double %f size=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mf">.123</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="mf">.123</span><span class="p">));</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;long double %Lf size=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mf">1.234</span><span class="n">L</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="mf">1.234</span><span class="n">L</span><span class="p">));</span>
</pre></div>


<p>will output:</p>
<div class="codehilite"><pre>float 1.000000 size=4
double 0.123000 size=8
long double 1.234000 size=12
</pre></div>


<h5 id="complex-floating-types"><strong>Complex floating types</strong> *<a class="headerlink" href="#complex-floating-types" title="Permanent link">&para;</a></h5>
<p>C99 supports complex numbers, by using two same-type floating-point number to represent real and imaginary number of the complex number.</p>
<p>To represent complex types, simply append <code>_Complex</code> to <code>float</code>, <code>double</code> and <code>long double</code>:</p>
<ul>
<li><code>float _Complex</code></li>
<li><code>double _Complex</code></li>
<li><code>long double _Complex</code></li>
</ul>
<p>If <code>&lt;complex.h&gt;</code> is included, they are also available as:</p>
<ul>
<li><code>float complex</code></li>
<li><code>double complex</code></li>
<li><code>long double complex</code></li>
</ul>
<p>The following code:</p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&lt;complex.h&gt;</span><span class="cp"></span>

<span class="n">printf</span><span class="p">(</span><span class="s">&quot;float complex size=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">((</span><span class="kt">float</span> <span class="n">complex</span><span class="p">)</span><span class="mf">1.0</span><span class="p">));</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;double complex size=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">((</span><span class="kt">double</span> <span class="n">complex</span><span class="p">)</span><span class="mf">1.0</span><span class="p">));</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;long double complex size=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">((</span><span class="kt">long</span> <span class="kt">double</span> <span class="n">complex</span><span class="p">)</span><span class="mf">1.0</span><span class="p">));</span>
</pre></div>


<p>will output:</p>
<div class="codehilite"><pre>float complex size=8
double complex size=16
long double complex size=24
</pre></div>


<h4 id="enumerations">Enumerations<a class="headerlink" href="#enumerations" title="Permanent link">&para;</a></h4>
<p>An <a href="http://en.cppreference.com/w/c/language/enum">enumerated type</a> (<code>enum</code>) is a distinct type whose value is restricted to one of several enumeration constants. It is declared with the following syntax:</p>
<div class="codehilite"><pre><span class="k">enum</span> <span class="n">identifier</span> <span class="p">{</span> <span class="n">enumerator</span><span class="o">-</span><span class="n">list</span> <span class="p">}</span>
</pre></div>


<ul>
<li>Each enumerator in the body of an enumeration specifier becomes an integer constant with type <code>int</code> and can be used whenever integer constants are required.</li>
<li>If enumerator is followed by <code>= constant-expression</code>, its value is the value of that constant expression.</li>
<li>If enumerator is not followed by <code>= constant-expression</code>, its value is the value one greater than the value of the previous enumerator in the same enumeration.</li>
<li>The value of the first enumerator (if it does not use <code>= constant-expression</code>) is zero.</li>
</ul>
<p>The following code:</p>
<div class="codehilite"><pre><span class="k">enum</span> <span class="n">color</span> <span class="p">{</span> <span class="n">black</span><span class="p">,</span> <span class="n">red</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">yellow</span> <span class="p">};</span>

<span class="k">enum</span> <span class="n">color</span> <span class="n">b</span> <span class="o">=</span> <span class="n">black</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;black = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">color</span> <span class="n">r</span> <span class="o">=</span> <span class="n">red</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;red = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">color</span> <span class="n">g</span> <span class="o">=</span> <span class="n">green</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;green = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">color</span> <span class="n">y</span> <span class="o">=</span> <span class="n">yellow</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;yellow = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
</pre></div>


<p>will output:</p>
<div class="codehilite"><pre>black = 0
red = 5
green = 6
yellow = 7
</pre></div>


<p>The values of enumerators can be the same:</p>
<p>The following code:</p>
<div class="codehilite"><pre><span class="k">enum</span> <span class="n">color</span> <span class="p">{</span> <span class="n">black</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">red</span><span class="p">,</span> <span class="n">green</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">yellow</span> <span class="p">};</span>
</pre></div>


<p>will output:</p>
<div class="codehilite"><pre>black = 1
red = 2
green = 1
yellow = 2
</pre></div>


<p>Usually, the identifier can be omitted, so that enumerators can be used to avoid defining constants macros.</p>
<div class="codehilite"><pre><span class="k">enum</span> <span class="p">{</span> <span class="n">BLACK</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">RED</span><span class="p">,</span> <span class="n">GREEN</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">YELLOW</span> <span class="p">};</span>

<span class="n">printf</span><span class="p">(</span><span class="s">&quot;black = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">BLACK</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;red = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">RED</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;green = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">GREEN</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;yellow = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">YELLOW</span><span class="p">);</span>
</pre></div>


<h3 id="literals">Literals<a class="headerlink" href="#literals" title="Permanent link">&para;</a></h3>
<p>A <a href="http://en.cppreference.com/w/c/language/expressions#Constants_and_literals">literal</a> in the source code is a token to represent a specific value, which can be an integer, a floating-point number, a character, or a string.</p>
<h4 id="integer-constants">Integer Constants<a class="headerlink" href="#integer-constants" title="Permanent link">&para;</a></h4>
<p>Besides the common decimal expression, octal (beginning with <code>0</code>) and hexadecimal (beginning with <code>0x</code> or <code>0X</code>) expressions can be used.</p>
<p>The following code:</p>
<div class="codehilite"><pre><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mo">010</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mh">0x0A</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;x = %d, y = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
</pre></div>


<p>will output:</p>
<div class="codehilite"><pre>x = 8, y = 10
</pre></div>


<p>Constant types is important. They can be differentiated using suffixes.</p>
<div class="codehilite"><pre>0x200    -&gt; int
200U     -&gt; unsigned int
0L       -&gt; long
0xf0f0UL -&gt; unsigned long
0777LL   -&gt; long long
0xFFULL  -&gt; unsigned long long
</pre></div>


<h4 id="floating-constants">Floating Constants<a class="headerlink" href="#floating-constants" title="Permanent link">&para;</a></h4>
<p>A <a href="http://en.cppreference.com/w/c/language/floating_constant">floating constant</a> can be represented using decimal and hexadecimal expressions.</p>
<p>The default type of floating constants is <code>double</code>. The <code>F</code> suffix represents <code>float</code>, and the <code>L</code> suffix represents <code>long double</code>.</p>
<h4 id="character-constants_1">Character Constants<a class="headerlink" href="#character-constants_1" title="Permanent link">&para;</a></h4>
<p>The default type for character constants is <code>int</code>, unless <code>L</code> is preposed to represent wide character constant of <code>wchar_t</code> type.</p>
<p>The following code:</p>
<div class="codehilite"><pre><span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="mh">0x61</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">c2</span> <span class="o">=</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">c3</span> <span class="o">=</span> <span class="sc">&#39;\x61&#39;</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%c, %c, %c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">c3</span><span class="p">);</span>
</pre></div>


<p>will output:</p>
<div class="codehilite"><pre>a, a, a
</pre></div>


<p>In Linux, the default <a href="https://en.wikipedia.org/wiki/Character_encoding">character encoding</a> is <a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a>. Conversion can be done using the <a href="http://en.cppreference.com/w/c/string/multibyte/wctomb"><code>wctomb</code></a> functions and the like.</p>
<p><code>wchar_t</code> is 4 bytes in size by default, so it can hold any UCS-4 Unicode character.</p>
<div class="codehilite"><pre><span class="n">setlocale</span><span class="p">(</span><span class="n">LC_CTYPE</span><span class="p">,</span> <span class="s">&quot;en_US.UTF-8&quot;</span><span class="p">);</span>

<span class="kt">wchar_t</span> <span class="n">wc</span> <span class="o">=</span> <span class="sc">L&#39;中&#39;</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span> <span class="o">=</span> <span class="p">{};</span>

<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">wctomb</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">wc</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;0x%02X &quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>


<p>will output:</p>
<div class="codehilite"><pre>3
0xE4 0xB8 0xAD
</pre></div>


<h4 id="string-literals">String Literals<a class="headerlink" href="#string-literals" title="Permanent link">&para;</a></h4>
<p>In C, a string is a <code>char</code> array ending with <code>NULL</code> (<code>\0</code>).</p>
<p>An empty string takes up 1 byte in the memory, which includes a <code>NULL</code> character. This means, a string that has a length of 1 requires at least 2 bytes (what <a href="http://en.cppreference.com/w/c/string/byte/strlen"><code>strlen</code></a> and <a href="http://en.cppreference.com/w/c/language/sizeof"><code>sizeof</code></a> means are different).</p>
<div class="codehilite"><pre><span class="kt">char</span> <span class="n">s</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;Hello, World!&quot;</span><span class="p">;</span>
<span class="kt">char</span><span class="o">*</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">&quot;Hello, C!&quot;</span><span class="p">;</span>
</pre></div>


<p>As with character contants, the prefixing <code>L</code> declares a wide string literal.</p>
<p>The following code:</p>
<div class="codehilite"><pre><span class="n">setlocale</span><span class="p">(</span><span class="n">LC_CTYPE</span><span class="p">,</span> <span class="s">&quot;en_US.UTF-8&quot;</span><span class="p">);</span>

<span class="kt">wchar_t</span><span class="o">*</span> <span class="n">ws</span> <span class="o">=</span> <span class="s">L&quot;中国⼈&quot;</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%ls</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ws</span><span class="p">);</span>

<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">255</span><span class="p">]</span> <span class="o">=</span> <span class="p">{};</span>
<span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">wcstombs</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">ws</span><span class="p">,</span> <span class="mi">255</span><span class="p">);</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;0x%02X &quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>


<p>will output:</p>
<div class="codehilite"><pre>中国⼈
0xE4 0xB8 0xAD 0xE5 0x9B 0xBD 0xE4 0xBA&quot;;
</pre></div>


<p>Similar to a <code>char</code> string, a <code>wchar_t</code> string ends with a 4-byte <code>NULL</code>.</p>
<p>The following code:</p>
<div class="codehilite"><pre><span class="kt">wchar_t</span> <span class="n">ws</span><span class="p">[]</span> <span class="o">=</span> <span class="s">L&quot;中国⼈&quot;</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;len %d, size %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">wcslen</span><span class="p">(</span><span class="n">ws</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ws</span><span class="p">));</span>

<span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">ws</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ws</span><span class="p">);</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
 <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%02X &quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>


<p>will output:</p>
<div class="codehilite"><pre>len 3, size 16
2D 4E 00 00 FD 56 00 00 BA 4E 00 00 00 00 00 00
</pre></div>


<p>The compiler will automatically concatenate adjacent strings. This is helpful for better dealing with strings in the macros or the code.</p>
<div class="codehilite"><pre><span class="cp">#define WORLD &quot;world!&quot;</span>
<span class="kt">char</span><span class="o">*</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;Hello&quot;</span> <span class="s">&quot; &quot;</span> <span class="n">WORLD</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</pre></div>


<p>For very long strings in the source code, other than concatenating them, <code>\</code> in the end of a line can be used.</p>
<div class="codehilite"><pre><span class="kt">char</span><span class="o">*</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">&quot;Hello&quot;</span>
 <span class="s">&quot; World!&quot;</span><span class="p">;</span>
<span class="kt">char</span><span class="o">*</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">&quot;Hello \</span>
<span class="s">World!&quot;</span><span class="p">;</span>
</pre></div>


<p>Note that the spaces to the right of <code>\</code> will treated as part of the string.</p>
<h3 id="type-conversions">Type Conversions<a class="headerlink" href="#type-conversions" title="Permanent link">&para;</a></h3>
<p>When the operands for an operator has different types, conversion is required. Usually, the compiler performs <a href="http://en.cppreference.com/w/c/language/conversion">implicit conversions</a>, on the premise that information is not lost, to convert the "narrow" bit-width operand into the "wide" one.</p>
<h4 id="arithmetic-conversions">Arithmetic conversions<a class="headerlink" href="#arithmetic-conversions" title="Permanent link">&para;</a></h4>
<p>The compiler's default implicit conversion ranks:</p>
<div class="codehilite"><pre>long double &gt; doulbe &gt; float &gt; long long &gt; long &gt; int &gt; char &gt; _Bool
</pre></div>


<p>The conversion rank of floating-point types is greater than that of any integers. Signed integers have the same conversion rank as their unsigned equivalence.</p>
<p>In expressions, <code>char</code> and <code>short</code> may be by default converted to <code>int</code> (<code>unsigned int</code>) operands, but <code>float</code> will not be converted to <code>double</code> by default.</p>
<p>The following code:</p>
<div class="codehilite"><pre><span class="kt">char</span> <span class="n">a</span> <span class="o">=</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="sc">&#39;c&#39;</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="n">a</span><span class="p">));</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="mf">1.5F</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
</pre></div>


<p>will output:</p>
<div class="codehilite"><pre>4
4
</pre></div>


<p><u>When dealing with unsigned operands, beware of checking whether the promoted type is able to hold all values of the unsigned type.</u></p>
<div class="codehilite"><pre><span class="kt">long</span> <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1L</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="o">?</span> <span class="nl">a</span> <span class="p">:</span> <span class="n">b</span><span class="p">);</span>
</pre></div>


<p>will output:</p>
<div class="codehilite"><pre>-1
</pre></div>


<p>This output is incomprehensible. Even if <code>long</code> has a greater rank than <code>unsigned int</code>, they are both 32-bit integers in 32-bit systems, and <code>long</code> is unable to hold all values of <code>unsigned int</code>. Therefore, the compiler will convert both operands to <code>unsigned long</code>, which is the unsigned greater rank. For this reason the result of <code>(unsigned long)a</code> turns into a very big integer.</p>
<blockquote>
<p>If the signedness is different and the signed operand's rank is greater than unsigned operand's rank. In this case, if the signed type can represent all values of the unsigned type, then the operand with the unsigned type is implicitly converted to the type of the signed operand. Otherwise, both operands undergo implicit conversion to the unsigned type counterpart of the signed operand's type.
<small><a href="http://en.cppreference.com/w/c/language/conversion#Usual_arithmetic_conversions">Usual arithmetic conversions: 4)</a></small></p>
</blockquote>
<p>The following code:</p>
<div class="codehilite"><pre><span class="kt">long</span> <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1L</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">a</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="o">?</span> <span class="nl">a</span> <span class="p">:</span> <span class="n">b</span><span class="p">);</span>
</pre></div>


<p>will output:</p>
<div class="codehilite"><pre>4294967295
-1
</pre></div>


<p>Other implicit conversions are:</p>
<ul>
<li>In assignment and initialization, the type of the right operator is always converted to that of the left one.</li>
<li>In a function call, the type of the actual parameter is always converted to that of the formal parameter.</li>
<li>The type of the <code>return</code> expression result is converted to that of the function's return type.</li>
<li>0 value of any type and the <code>NULL</code> pointer is deemed <code>_Bool false</code>; otherwise, it is <code>true</code>.</li>
</ul>
<p>When converting a "wide" type to a "narrow" type, the compiler will try to discard significant bits, to use rounding, or other techniques to return a approximate value.</p>
<h4 id="non-arithmetic-conversions">Non-arithmetic conversions<a class="headerlink" href="#non-arithmetic-conversions" title="Permanent link">&para;</a></h4>
<ol>
<li>The name or expression of an array is usually referred to as a pointer to its first element, unless:<ul>
<li>It is used as the operand of <code>sizeof</code>.</li>
<li>The <code>&amp;</code> operator is used on it to return a "array pointer".</li>
<li>It is a <a href="#string-literals">string constant</a> are used to initialize a <code>char</code> or <code>wchar_t</code> array.</li>
</ul>
</li>
<li>
<p>A pointer can be explicitly converted to a pointer of any other types.</p>
<div class="codehilite"><pre>int x = 123, *p = &amp;x;
char* c = (char*)x;
</pre></div>


</li>
<li>
<p>Any pointer can be implicitly converted to a <code>void</code> pointer and vice versa.</p>
</li>
<li>
<p>Any pointer can be implicitly converted to a pointer of a more specific type (including qualifiers such as <code>const</code>, <code>volatile</code> and <code>restrict</code>).</p>
<div class="codehilite"><pre>int x = 123, *p = &amp;x;
const int* p2 = p;
</pre></div>


</li>
<li>
<p><code>NULL</code> can be converted to a pointer of any type.</p>
</li>
<li>
<p>A pointer can be explicitly converted to an integer and vice versa.</p>
<p>The following code:</p>
<div class="codehilite"><pre>int x = 123, *p = &amp;x;
int px = (int)p;

printf(&quot;%p, %x, %d\n&quot;, p, px, *(int*)px);
</pre></div>


<p>will output:</p>
<div class="codehilite"><pre>0xbfc1389c, bfc1389c, 123
</pre></div>


</li>
</ol>
<h3 id="operators">Operators<a class="headerlink" href="#operators" title="Permanent link">&para;</a></h3>
<p>Other than basic expressions and operator usages, let's document something special.</p>
<h4 id="compound-literals">Compound Literals<a class="headerlink" href="#compound-literals" title="Permanent link">&para;</a></h4>
<p>Since C99, we can use the following syntax to declare a structure or array pointer.</p>
<div class="codehilite"><pre>( type ) { initializer-list }
</pre></div>


<p>For example,</p>
<div class="codehilite"><pre><span class="kt">int</span><span class="o">*</span> <span class="n">i</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="kt">int</span><span class="p">){</span> <span class="mi">123</span> <span class="p">};</span>                              <span class="c1">// integer variable, pointer</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">[]){</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">};</span>                      <span class="c1">// array, pointer</span>
<span class="k">struct</span> <span class="n">data_t</span><span class="o">*</span> <span class="n">data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="k">struct</span> <span class="n">data_t</span><span class="p">){</span> <span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">123</span> <span class="p">};</span>  <span class="c1">// structure, pointer</span>
<span class="n">func</span><span class="p">(</span><span class="mi">123</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="k">struct</span> <span class="n">data_t</span><span class="p">){</span> <span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">123</span> <span class="p">});</span>             <span class="c1">// function argument, structure pointer</span>
</pre></div>


<p>For static or global variables, the initializer list must be compile-time constants.</p>
<h4 id="sizeof"><code>sizeof</code><a class="headerlink" href="#sizeof" title="Permanent link">&para;</a></h4>
<p><code>sizeof</code> returns the memory storage size of the operator in bytes. The return type is <code>size_t</code> and the operator can be a type or a variable.</p>
<div class="codehilite"><pre><span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span> <span class="n">x</span><span class="p">;</span>
<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>
<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>
</pre></div>


<p>Do not use <code>int</code> in place of <code>size_t</code>, because <code>size_t</code> has different sizes on 32-bit and 64-bit platforms.</p>
<h4 id="comma-operator">Comma Operator<a class="headerlink" href="#comma-operator" title="Permanent link">&para;</a></h4>
<p>The <a href="http://en.cppreference.com/w/c/language/operator_other#Comma_operator">comma operator</a> is a binary operator, which guarantees that the operands are evaluated from left to right and returns the value and type of the right operand.</p>
<div class="codehilite"><pre><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">long</span> <span class="kt">long</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">i</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%lld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
</pre></div>


<h4 id="precedence">Precedence<a class="headerlink" href="#precedence" title="Permanent link">&para;</a></h4>
<p>The precedence is C is a big trouble. Do not refrain from using "()".</p>
<p>The following table is the precedence list (from high to low):</p>
<table>
<thead>
<tr>
<th>Kind</th>
<th>Operator</th>
<th>Associativity</th>
</tr>
</thead>
<tbody>
<tr>
<td>Postfix operator</td>
<td><code>++</code>, <code>--</code>, <code>[]</code>, <code>func()</code>, <code>.</code>, <code>-&gt;</code>, <code>(type){init}</code></td>
<td>Left-to-right</td>
</tr>
<tr>
<td>Unary operator</td>
<td><code>++</code>, <code>--</code>, <code>!</code>, <code>~</code>, <code>+</code>, <code>-</code>, <code>*</code>, <code>&amp;</code>, <code>sizeof</code></td>
<td>Right-to-left</td>
</tr>
<tr>
<td>Cast operator</td>
<td><code>(type name)</code></td>
<td>Right-to-left</td>
</tr>
<tr>
<td>Multiplication and division operator</td>
<td><code>*</code>, <code>/</code>, <code>%</code></td>
<td>Left-to-right</td>
</tr>
<tr>
<td>Addition and subtraction operator</td>
<td><code>+</code>, <code>-</code></td>
<td>Left-to-right</td>
</tr>
<tr>
<td>Bitwise shift operator</td>
<td><code>&lt;&lt;</code>, <code>&gt;&gt;</code></td>
<td>Left-to-right</td>
</tr>
<tr>
<td>Relational operator</td>
<td><code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code></td>
<td>Left-to-right</td>
</tr>
<tr>
<td>Equation operator</td>
<td><code>==</code>, <code>!=</code></td>
<td>Left-to-right</td>
</tr>
<tr>
<td>Bitwise operator</td>
<td><code>&amp;</code></td>
<td>Left-to-right</td>
</tr>
<tr>
<td>Bitwise operator</td>
<td><code>^</code></td>
<td>Left-to-right</td>
</tr>
<tr>
<td>Bitwise operator</td>
<td><code>&#124;</code></td>
<td>Left-to-right</td>
</tr>
<tr>
<td>Logical operator</td>
<td><code>&amp;&amp;</code></td>
<td>Left-to-right</td>
</tr>
<tr>
<td>Logical operator</td>
<td><code>&#124;&#124;</code></td>
<td>Left-to-right</td>
</tr>
<tr>
<td>Conditional operator</td>
<td><code>?:</code></td>
<td>Right-to-left</td>
</tr>
<tr>
<td>Assignment operator</td>
<td><code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>&amp;=</code>, <code>^=</code>, <code>&#124;=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code></td>
<td>Right-to-left</td>
</tr>
<tr>
<td>Comma operator</td>
<td><code>,</code></td>
<td>Left-to-right</td>
</tr>
</tbody>
</table>
<p>If multiple operators in an expression have the same precedence, then their associativity determines how they are combined (left-to-right or right-to-left). For example, in <code>a = b = c</code>, the two <code>=</code> have the same precedence. According to its associativity, the expression is decomposed into <code>a = (b = c)</code>.</p>
<p>The following are some confusing operator precedence.</p>
<ol>
<li>
<p><code>.</code> is higher than <code>*</code>.</p>
<div class="codehilite"><pre>Original: *p.f
Erroneous: (*p).f
Correct: *(p.f)
</pre></div>


</li>
<li>
<p><code>[]</code> is higher than <code>*</code>.</p>
<div class="codehilite"><pre><span class="n">Original</span><span class="o">:</span> <span class="n">int</span> <span class="o">*</span><span class="n">ap</span><span class="o">[]</span>
<span class="n">Erroneous</span><span class="o">:</span> <span class="n">int</span> <span class="o">(*</span><span class="n">ap</span><span class="o">)[]</span>
<span class="n">Correct</span><span class="o">:</span> <span class="n">int</span> <span class="o">*(</span><span class="n">ap</span><span class="o">[])</span>
</pre></div>


</li>
<li>
<p><code>==</code> and <code>!=</code> are higher than bitwise operators.</p>
<div class="codehilite"><pre><span class="n">Original</span><span class="o">:</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="n">mask</span> <span class="o">!=</span> <span class="mi">0</span>
<span class="n">Erroneous</span><span class="o">:</span> <span class="o">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="o">)</span> <span class="o">!=</span> <span class="mi">0</span>
<span class="n">Correct</span><span class="o">:</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
</pre></div>


</li>
<li>
<p><code>==</code> and <code>!=</code> are higher than assignment operators.</p>
<div class="codehilite"><pre><span class="n">Original</span><span class="o">:</span> <span class="n">c</span> <span class="o">=</span> <span class="n">getchar</span><span class="o">()</span> <span class="o">!=</span> <span class="n">EOF</span>
<span class="n">Erroneous</span><span class="o">:</span> <span class="o">(</span><span class="n">c</span> <span class="o">=</span> <span class="n">getchar</span><span class="o">())</span> <span class="o">!=</span> <span class="n">EOF</span>
<span class="n">Correct</span><span class="o">:</span> <span class="n">c</span> <span class="o">=</span> <span class="o">(</span><span class="n">getchar</span><span class="o">()</span> <span class="o">!=</span> <span class="n">EOF</span><span class="o">)</span>
</pre></div>


</li>
<li>
<p>Arithmetic operators are higher than bitwise shift operators.</p>
<div class="codehilite"><pre><span class="n">Original</span><span class="o">:</span> <span class="n">msb</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">lsb</span>
<span class="n">Erroneous</span><span class="o">:</span> <span class="o">(</span><span class="n">msb</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="o">)</span> <span class="o">+</span> <span class="n">lsb</span>
<span class="n">Correct</span><span class="o">:</span> <span class="n">msb</span> <span class="o">&lt;&lt;</span> <span class="o">(</span><span class="mi">4</span> <span class="o">+</span> <span class="n">lsb</span><span class="o">)</span>
</pre></div>


</li>
<li>
<p>The comma operator has the lowest precedence.</p>
<div class="codehilite"><pre><span class="n">Original</span><span class="o">:</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span>
<span class="n">Erroneous</span><span class="o">:</span> <span class="n">i</span> <span class="o">=</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">Correct</span><span class="o">:</span> <span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">),</span> <span class="mi">2</span>
</pre></div>


</li>
</ol>
<h3 id="statements">Statements<a class="headerlink" href="#statements" title="Permanent link">&para;</a></h3>
<h4 id="statement-blocks">Statement Blocks<a class="headerlink" href="#statement-blocks" title="Permanent link">&para;</a></h4>
<p>A block represents a <a href="http://en.cppreference.com/w/c/language/scope">scope</a>; the automatic variables declared inside the block will be released if beyond the scope. Apart from <code>{...}</code> which represents a regular block, it can also be used in complex assignments. This is often used in macros.</p>
<p>In the following code:</p>
<div class="codehilite"><pre><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="p">({</span> <span class="kt">char</span> <span class="n">a</span> <span class="o">=</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span> <span class="n">a</span><span class="o">++</span><span class="p">;</span> <span class="n">a</span><span class="p">;</span> <span class="p">});</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
</pre></div>


<p>The last expression can be treated as the return value of a block. The equivalent macro version of this code is:</p>
<div class="codehilite"><pre><span class="cp">#define test() ({ \</span>
<span class="cp"> char _a = &#39;a&#39;; \</span>
<span class="cp"> _a++; \</span>
<span class="cp"> _a; })</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">test</span><span class="p">();</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
</pre></div>


<p>In macros, the underline prefixes are usually used to avoid name conflicts with the upper block.</p>
<h4 id="loop-statements">Loop Statements<a class="headerlink" href="#loop-statements" title="Permanent link">&para;</a></h4>
<p>C supports <code>while</code>, <code>for</code> and <code>do...while</code> loop statements (or iteration statements).</p>
<p>Note that in the following example, the loop causes the <code>get_len</code> function to be executed multiple times.</p>
<div class="codehilite"><pre><span class="kt">size_t</span> <span class="nf">get_len</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="s">&quot;abcde&quot;</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">get_len</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h4 id="selection-statements">Selection Statements<a class="headerlink" href="#selection-statements" title="Permanent link">&para;</a></h4>
<p>Selection statements include <code>if...else if...else...</code> and <code>switch { case ... }</code>.</p>
<p>GCC supports the <code>switch</code> <a href="https://gcc.gnu.org/onlinedocs/gcc/Case-Ranges.html">case range</a> extension.</p>
<div class="codehilite"><pre><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">switch</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">case</span> <span class="mi">0</span> <span class="p">...</span> <span class="mi">9</span><span class="o">:</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;0..9</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="mi">10</span> <span class="p">...</span> <span class="mi">99</span><span class="o">:</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;10..99</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">default</span><span class="o">:</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;default</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="sc">&#39;C&#39;</span><span class="p">;</span>
<span class="k">switch</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
     <span class="k">case</span> <span class="sc">&#39;a&#39;</span> <span class="p">...</span> <span class="sc">&#39;z&#39;</span><span class="o">:</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;a..z</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
     <span class="k">case</span> <span class="sc">&#39;A&#39;</span> <span class="p">...</span> <span class="sc">&#39;Z&#39;</span><span class="o">:</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;A..Z</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
     <span class="k">case</span> <span class="sc">&#39;0&#39;</span> <span class="p">...</span> <span class="sc">&#39;9&#39;</span><span class="o">:</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;0..9</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
     <span class="k">default</span><span class="o">:</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;default</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h4 id="jump-statements">Jump Statements<a class="headerlink" href="#jump-statements" title="Permanent link">&para;</a></h4>
<p>The <a href="http://en.cppreference.com/w/c/language/statements#Jump_statements">jump statements</a> unconditionally transfer flow control.</p>
<ul>
<li><code>break</code></li>
<li><code>continue</code></li>
<li><a href="http://en.cppreference.com/w/c/language/goto"><code>goto</code></a></li>
<li><code>return</code></li>
</ul>
<p><code>goto</code> only causes a jump within the function, which is commonly used to jump out of the nested loops. To jump out of the function, use <a href="http://en.cppreference.com/w/c/program/longjmp"><code>longjmp</code></a>.</p>
<p><a href="http://en.cppreference.com/w/c/program/setjmp"><code>setjmp</code></a> saves the current execution context into a variable <code>env</code> of type <code>jmp_buf</code> and returns 0. When the subsequent code calls <code>longjmp</code> to jump, a status code is required. The code execution will return to the call site of <code>setjmp</code>, and returns the status code passed to <code>longjmp</code>.</p>
<p>The following code:</p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdbool.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;setjmp.h&gt;</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">test</span><span class="p">(</span><span class="kt">jmp_buf</span> <span class="o">*</span><span class="n">env</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;1....</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">longjmp</span><span class="p">(</span><span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">jmp_buf</span> <span class="n">env</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">setjmp</span><span class="p">(</span><span class="n">env</span><span class="p">);</span> <span class="c1">// calling `longjmp` goes to here,</span>
                           <span class="c1">// and `ret` is the value passed to `longjmp`</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">env</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;2....(%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>will output:</p>
<div class="codehilite"><pre>1....
2....(10)
</pre></div>


<h3 id="functions">Functions<a class="headerlink" href="#functions" title="Permanent link">&para;</a></h3>
<p>A function can be defined once, but can be declared and called multiple times.</p>
<h4 id="nested-functions">Nested Functions<a class="headerlink" href="#nested-functions" title="Permanent link">&para;</a></h4>
<p>The GCC supports the <a href="https://gcc.gnu.org/onlinedocs/gcc/Nested-Functions.html">nested functions</a> extension.</p>
<div class="codehilite"><pre><span class="k">typedef</span> <span class="nf">void</span><span class="p">(</span><span class="o">*</span><span class="n">func_t</span><span class="p">)();</span>

<span class="n">func_t</span> <span class="nf">test</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">func1</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="k">return</span> <span class="n">func1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">test</span><span class="p">()();</span>
    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>The inner function can "read and write" the parameters and variables from the outer function; the outer variables have to be defined before the nested function.</p>
<p>The following code:</p>
<div class="codehilite"><pre><span class="cp">#define pp() ({ \</span>
<span class="cp">    printf(&quot;%s: x = %d(%p), y = %d(%p), s = %s(%p);\n&quot;, __func__, x, &amp;x, y, &amp;y, s, s); \</span>
<span class="cp">})</span>

<span class="kt">void</span> <span class="nf">test2</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">88</span><span class="p">;</span>
    <span class="n">pp</span><span class="p">();</span>

    <span class="kt">void</span> <span class="n">func1</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">y</span><span class="o">++</span><span class="p">;</span>
        <span class="n">x</span><span class="o">++</span><span class="p">;</span>
        <span class="n">pp</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">func1</span><span class="p">();</span>

    <span class="n">x</span><span class="o">++</span><span class="p">;</span>
    <span class="n">func1</span><span class="p">();</span>
    <span class="n">pp</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">test2</span><span class="p">(</span><span class="mi">1234</span><span class="p">,</span> <span class="s">&quot;abc&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>will output:</p>
<div class="codehilite"><pre>test2: x = 1234(0xbffff7d4), y = 88(0xbffff7d8), s = abc(0x4ad3);
func1: x = 1235(0xbffff7d4), y = 89(0xbffff7d8), s = abc(0x4ad3);
func1: x = 1237(0xbffff7d4), y = 90(0xbffff7d8), s = abc(0x4ad3);
test2: x = 1237(0xbffff7d4), y = 90(0xbffff7d8), s = abc(0x4ad3);
</pre></div>


<h4 id="function-types">Function Types<a class="headerlink" href="#function-types" title="Permanent link">&para;</a></h4>
<p>Do not confuse "function type" and "<a href="../part2/#pointer-to-function">function pointer</a> type". The name of a function is a pointer to that function.</p>
<div class="codehilite"><pre><span class="k">typedef</span> <span class="nf">void</span><span class="p">(</span><span class="n">func_t</span><span class="p">)();</span>      <span class="c1">// function type</span>
<span class="k">typedef</span> <span class="nf">void</span><span class="p">(</span><span class="o">*</span><span class="n">func_ptr_t</span><span class="p">)();</span> <span class="c1">// function pointer type</span>

<span class="kt">void</span> <span class="nf">test</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">func_t</span><span class="o">*</span> <span class="n">func</span> <span class="o">=</span> <span class="n">test</span><span class="p">;</span>     <span class="c1">// delcare a pointer</span>
    <span class="n">func_ptr_t</span> <span class="n">func2</span> <span class="o">=</span> <span class="n">test</span><span class="p">;</span> <span class="c1">// already a pointer type</span>

    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func3</span><span class="p">)();</span>         <span class="c1">// declare a function pointer variable, which</span>
                             <span class="c1">// includes a function prototype</span>
    <span class="n">func3</span> <span class="o">=</span> <span class="n">test</span><span class="p">;</span>

    <span class="n">func</span><span class="p">();</span>
    <span class="n">func2</span><span class="p">();</span>
    <span class="n">func3</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h4 id="function-calls">Function Calls<a class="headerlink" href="#function-calls" title="Permanent link">&para;</a></h4>
<p>By default, C uses the <a href="https://en.wikipedia.org/wiki/X86_calling_conventions#cdecl">cdecl</a> calling convention. The arguments are pushed on the stack in the right-to-left order. It is the caller that pushes arguments on the stack and cleans arguments from the stack.</p>
<p>The following code:</p>
<div class="codehilite"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;a</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">char</span><span class="o">*</span> <span class="n">s</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="s">&quot;abc&quot;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;call: %d, %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">(),</span> <span class="n">s</span><span class="p">());</span>
    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>will output:</p>
<div class="codehilite"><pre>s
a
call: 1, abc
</pre></div>


<p>Every <a href="http://en.cppreference.com/w/c/language/object">object</a> in C, including the pointer, is passed in a "<a href="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_value">call by value</a>" (pass by value) way. We can pass a "pointer to the pointer" as the argument.</p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="nf">test</span><span class="p">(</span><span class="kt">int</span><span class="o">**</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
    <span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>
    <span class="n">test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Note: do not return the stack variable in <code>test</code>.</p>
<h4 id="storage-class-specifiers">Storage-class Specifiers<a class="headerlink" href="#storage-class-specifiers" title="Permanent link">&para;</a></h4>
<p>C99 has the following storage-class specifiers:</p>
<ul>
<li><code>extern</code>: default specifier.<ul>
<li>On functions: used to specify that a function has external linkage. These functions can be used in any program files.</li>
<li>On variables: used to specify that a variable is defined in other <a href="https://en.wikipedia.org/wiki/Translation_unit_(programming)">translation units</a>.</li>
</ul>
</li>
<li><code>static</code>: used to specify that a function is available only in its translation unit (source code file). It can also be used to represent static variables.</li>
<li><a href="http://en.cppreference.com/w/c/language/inline"><code>inline</code></a>: used to recommend the compiler to inline the body the function to the <a href="https://en.wikipedia.org/wiki/Call_site">call site</a>, but the complier decides whether to perform inlining. Normally, the functions that contain loops and recursive functions cannot be defined as an inline function.</li>
</ul>
<p>Some notes about <a href="https://gcc.gnu.org/onlinedocs/gcc/Inline.html">GNU inline</a>:</p>
<ul>
<li><code>static inline</code>: internal linkage function. Inlining is performed within the current translation unit. When <code>-O0</code> is specified, the function is still called.</li>
<li><code>inline</code>: external linkage function. Inlining is performed within the current translation unit. In other translation unit, it is a normal external linkage function. (the <code>inline</code> keyword cannot be specified to the header files)</li>
</ul>
<p>The <code>inline</code> keyword can only used in function definitions.</p>
<h4 id="variadic-arguments">Variadic Arguments<a class="headerlink" href="#variadic-arguments" title="Permanent link">&para;</a></h4>
<p>Variadic arguments are used to implement <a href="https://en.wikipedia.org/wiki/Variadic_function">variadic functions</a>:</p>
<ul>
<li><code>va_start</code>: initialize the argument pointer of type <code>va_list</code> with the argument preceding the variadic arguments.</li>
<li><code>va_arg</code>: access the current variadic argument and modify the argument pointer to point to the next argument.</li>
<li><code>va_end</code>: perform cleanup so that the argument pointer is no longer usable.</li>
<li><code>va_copy</code>: use the existing argument pointer (<code>va_list</code>) to initialize another pointer.</li>
</ul>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&lt;stdarg.h&gt;</span><span class="cp"></span>
<span class="cm">/* specify number of variadic arguments */</span>

<span class="kt">void</span> <span class="nf">test</span><span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
    <span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
    <span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* end by NULL */</span>
<span class="kt">void</span> <span class="nf">test2</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>

    <span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
    <span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>

    <span class="kt">char</span><span class="o">*</span> <span class="n">value</span><span class="p">;</span>
    <span class="k">do</span>
    <span class="p">{</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">value</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* directly pass va_list to the other variadic function */</span>
<span class="kt">void</span> <span class="nf">test3</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">format</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
    <span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
    <span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">format</span><span class="p">);</span>
    <span class="n">vprintf</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
    <span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">test</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">33</span><span class="p">);</span>
    <span class="n">test2</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">,</span> <span class="s">&quot;aa&quot;</span><span class="p">,</span> <span class="s">&quot;bb&quot;</span><span class="p">,</span> <span class="s">&quot;cc&quot;</span><span class="p">,</span> <span class="s">&quot;dd&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">test3</span><span class="p">(</span><span class="s">&quot;%s, %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;hello, world!&quot;</span><span class="p">,</span> <span class="mi">1234</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h3 id="arrays">Arrays<a class="headerlink" href="#arrays" title="Permanent link">&para;</a></h3>
<h4 id="variable-length-arrays"><a href="https://en.wikipedia.org/wiki/Variable-length_array">Variable-Length Arrays</a><a class="headerlink" href="#variable-length-arrays" title="Permanent link">&para;</a></h4>
<p>If an array has automatic storage duration and is without the <code>static</code> specifier, then it can be defined using a non-constant expression.</p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="nf">test</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">struct</span> <span class="n">data</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">];</span> <span class="p">}</span> <span class="n">d</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">d</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">};</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>

    <span class="n">test</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h4 id="subscripts">Subscripts<a class="headerlink" href="#subscripts" title="Permanent link">&para;</a></h4>
<p><code>x[i]</code> is equivalent to <code>*(x + i)</code>; the array name by default is a pointer that points to the first element.</p>
<div class="codehilite"><pre><span class="kt">int</span> <span class="n">x</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">};</span>

<span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>

<span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
</pre></div>


<p>Since C does not perform range checking on array subscripts, care must be taken to ensure <a href="https://en.wikipedia.org/wiki/Bounds_checking">out-of-bounds checking</a> when coding. An array's name by default is a constant pointer to the first element; <code>&amp;x[i]</code> returns a <code>int*</code> pointer, which points to element <code>x[i]</code>.</p>
<h4 id="initialization">Initialization<a class="headerlink" href="#initialization" title="Permanent link">&para;</a></h4>
<p>Besides using subscripts, an array can also be <a href="http://en.cppreference.com/w/c/language/array_initialization">initialized</a> using initializers.</p>
<div class="codehilite"><pre><span class="kt">int</span> <span class="n">x</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">};</span>
<span class="kt">int</span> <span class="n">y</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">};</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{};</span>

<span class="kt">int</span> <span class="n">z</span><span class="p">[][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="p">},</span>
    <span class="p">{</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span> <span class="p">},</span>
    <span class="p">{</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span> <span class="p">},</span>
<span class="p">};</span>
</pre></div>


<p>Rules of initialization are:</p>
<ul>
<li>If the array has <a href="http://en.cppreference.com/w/c/language/storage_duration#Storage_duration">static storage duration</a>, then the initializers must be <a href="http://en.cppreference.com/w/c/language/constant_expression">constant expressions</a>.</li>
<li>If initializers are present, then the size of the array can be omitted, which is determined by the last initializer.</li>
<li>If both the size of the array and initializers are present, then the elements without initializers are initialized to 0 or <code>NULL</code>.</li>
</ul>
<p>We can also initialize specific elements in the initializers. For example, the following code:</p>
<div class="codehilite"><pre><span class="kt">int</span> <span class="n">x</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span> <span class="p">};</span>
<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;x[%d] = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>


<p>will output:</p>
<div class="codehilite"><pre>x[0] = 1
x[1] = 2
x[2] = 0
x[3] = 0
x[4] = 0
x[5] = 0
x[6] = 10
x[7] = 11
</pre></div>


<h4 id="strings">Strings<a class="headerlink" href="#strings" title="Permanent link">&para;</a></h4>
<p>A string is a <code>char</code> array ending with <code>\0</code>.</p>
<p>The following code:</p>
<div class="codehilite"><pre><span class="kt">char</span> <span class="n">s</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;abc&quot;</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">x</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;abc&quot;</span><span class="p">;</span>

<span class="n">printf</span><span class="p">(</span><span class="s">&quot;s, size=%d, len=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;x, size=%d, len=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">strlen</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
</pre></div>


<p>will output:</p>
<div class="codehilite"><pre>s, size=10, len=3
x, size=4, len=3
</pre></div>


<h4 id="multidimensional-arrays">Multidimensional Arrays<a class="headerlink" href="#multidimensional-arrays" title="Permanent link">&para;</a></h4>
<p>A multidimensional array is an array whose elements are arrays. Note that elements are arrays, not array pointers.</p>
<p>The first dimension subscript can be omitted.</p>
<p>The following code:</p>
<div class="codehilite"><pre><span class="kt">int</span> <span class="n">x</span><span class="p">[][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">11</span> <span class="p">},</span>
    <span class="p">{</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">22</span> <span class="p">},</span>
    <span class="p">{</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">33</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">row</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">/</span> <span class="n">col</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">row</span><span class="p">;</span> <span class="n">r</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">col</span><span class="p">;</span> <span class="n">c</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;x[%d][%d] = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>will output:</p>
<div class="codehilite"><pre>x[0][0] = 1
x[0][1] = 11
x[1][0] = 2
x[1][1] = 22
x[2][0] = 3
x[2][1] = 33
</pre></div>


<p>A two-dimensional array is usually called a "matrix", like a <code>row * column</code> table. For example, <code>x[3][2]</code> is a table with 3 rows and 2 columns.</p>
<p>The elements in a multidimensional array are contiguously allocated, which is another factor that differentiate it from a pointer array.</p>
<p>The following code:</p>
<div class="codehilite"><pre><span class="kt">int</span> <span class="n">x</span><span class="p">[][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">11</span> <span class="p">},</span>
    <span class="p">{</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">22</span> <span class="p">},</span>
    <span class="p">{</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">33</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">x</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;x[%d] = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>


<p>will output:</p>
<div class="codehilite"><pre>x[0] = 1
x[1] = 11
x[2] = 2
x[3] = 22
x[4] = 3
x[5] = 33
</pre></div>


<p>Similarly, we can initialize specific elements.</p>
<p>The following code:</p>
<div class="codehilite"><pre><span class="kt">int</span> <span class="n">x</span><span class="p">[][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">11</span> <span class="p">},</span>
    <span class="p">{</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">22</span> <span class="p">},</span>
    <span class="p">{</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">33</span> <span class="p">},</span>
    <span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
    <span class="p">{</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">66</span> <span class="p">},</span>
    <span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">99</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">row</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">/</span> <span class="n">col</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">row</span><span class="p">;</span> <span class="n">r</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">col</span><span class="p">;</span> <span class="n">c</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;x[%d][%d] = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>will output:</p>
<div class="codehilite"><pre>x[0][0] = 1
x[0][1] = 11
x[1][0] = 2
x[1][1] = 22
x[2][0] = 0
x[2][1] = 0
x[3][0] = 0
x[3][1] = 0
x[4][0] = 0
x[4][1] = 100
x[5][0] = 6
x[5][1] = 66
x[6][0] = 0
x[6][1] = 0
x[7][0] = 9
x[7][1] = 99
</pre></div>


<h4 id="array-arguments">Array Arguments<a class="headerlink" href="#array-arguments" title="Permanent link">&para;</a></h4>
<p>When an array is used as a function parameter, it is always implicitly converted to a pointer that points to the first element of the array. This means <code>sizeof</code> is no longer available to be used to obtain the array size.</p>
<p>The following code:</p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="nf">test</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">test2</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">};</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
    <span class="n">test</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="n">test2</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>will output:</p>
<div class="codehilite"><pre>12
4
4
</pre></div>


<p>In the above code, <code>sizeof(x)</code> in <code>test</code> and <code>test2</code> is actually <code>sizeof(int*)</code>. We must either explicitly pass the length of the array, or use a special character (<code>NULL</code>) to mark the end of the array.</p>
<p>C99 supports arrays of variable size used as function parameters. Possible forms of passing array arguments are:</p>
<p><small><a href="https://gist.github.com/shichao-an/9497fd38d97760ceee5f#file-array-params-c">array-params.c</a></small></p>
<div class="codehilite"><pre><span class="cm">/* the array name by default is a pointer to its first element,</span>
<span class="cm"> * similar to test2</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">test1</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;x[%d] = %d; &quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* pass the pointer to the first element */</span>
<span class="kt">void</span> <span class="nf">test2</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;x[%d] = %d; &quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">i</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* array pointer: the array name by default points to the first element;</span>
<span class="cm"> * &amp;array returns the pointer to the entire array</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">test3</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="p">)[</span><span class="n">len</span><span class="p">])</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;x[%d] = %d; &quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="p">)[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* multidimensional array: the array name by default is a pointer to its</span>
<span class="cm"> * first elements, which is also int(*)[]</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">test4</span><span class="p">(</span><span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">[][</span><span class="n">c</span><span class="p">])</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">;</span> <span class="n">a</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">c</span><span class="p">;</span> <span class="n">b</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">&quot;y[%d][%d] = %d; &quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">y</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">b</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* multidimensional array: pass the pointer to the first element */</span>
<span class="kt">void</span> <span class="nf">test5</span><span class="p">(</span><span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">y</span><span class="p">)[</span><span class="n">c</span><span class="p">])</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">;</span> <span class="n">a</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">c</span><span class="p">;</span> <span class="n">b</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">&quot;y[%d][%d] = %d; &quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">y</span><span class="p">)[</span><span class="n">b</span><span class="p">]);</span>
        <span class="p">}</span>

        <span class="n">y</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* multidimensional array */</span>
<span class="kt">void</span> <span class="nf">test6</span><span class="p">(</span><span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">y</span><span class="p">)[][</span><span class="n">c</span><span class="p">])</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">;</span> <span class="n">a</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">c</span><span class="p">;</span> <span class="n">b</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">&quot;y[%d][%d] = %d; &quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">y</span><span class="p">)[</span><span class="n">a</span><span class="p">][</span><span class="n">b</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* pointer array whose elements are pointers, equivalent to test8 */</span>
<span class="kt">void</span> <span class="nf">test7</span><span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s; &quot;</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">s</span><span class="o">++</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">test8</span><span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">s</span><span class="p">[</span><span class="n">count</span><span class="p">])</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s; &quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* pointer array ending with NULL */</span>
<span class="kt">void</span> <span class="nf">test9</span><span class="p">(</span><span class="kt">int</span><span class="o">**</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">((</span><span class="n">p</span> <span class="o">=</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d; &quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
        <span class="n">x</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">};</span>

    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
    <span class="n">test1</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
    <span class="n">test2</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
    <span class="n">test3</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">y</span><span class="p">[][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span>
    <span class="p">{</span>
        <span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">20</span><span class="p">,</span> <span class="mi">21</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">30</span><span class="p">,</span> <span class="mi">31</span><span class="p">}</span>
    <span class="p">};</span>

    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">test4</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
    <span class="n">test5</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
    <span class="n">test6</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">);</span>

    <span class="kt">char</span><span class="o">*</span> <span class="n">s</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;aaa&quot;</span><span class="p">,</span> <span class="s">&quot;bbb&quot;</span><span class="p">,</span> <span class="s">&quot;ccc&quot;</span> <span class="p">};</span>
    <span class="n">test7</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">),</span> <span class="n">s</span><span class="p">);</span>
    <span class="n">test8</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">),</span> <span class="n">s</span><span class="p">);</span>

    <span class="kt">int</span><span class="o">*</span> <span class="n">xx</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="o">&amp;</span><span class="p">(</span><span class="kt">int</span><span class="p">){</span><span class="mi">111</span><span class="p">},</span> <span class="o">&amp;</span><span class="p">(</span><span class="kt">int</span><span class="p">){</span><span class="mi">222</span><span class="p">},</span> <span class="o">&amp;</span><span class="p">(</span><span class="kt">int</span><span class="p">){</span><span class="mi">333</span><span class="p">},</span> <span class="nb">NULL</span> <span class="p">};</span>
    <span class="n">test9</span><span class="p">(</span><span class="n">xx</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>The above code will output:</p>
<div class="codehilite"><pre>x[0] = 1; x[1] = 2; x[2] = 3;
x[0] = 1; x[1] = 2; x[2] = 3;
x[0] = 1; x[1] = 2; x[2] = 3;
y[0][0] = 10; y[0][1] = 11; y[1][0] = 20; y[1][1] = 21; y[2][0] = 30; y[2][1] = 31;
y[0][0] = 10; y[0][1] = 11; y[1][0] = 20; y[1][1] = 21; y[2][0] = 30; y[2][1] = 31;
y[0][0] = 10; y[0][1] = 11; y[1][0] = 20; y[1][1] = 21; y[2][0] = 30; y[2][1] = 31;
aaa; bbb; ccc;
aaa; bbb; ccc;
111; 222; 333;
</pre></div>


<h3 id="pointers">Pointers<a class="headerlink" href="#pointers" title="Permanent link">&para;</a></h3>
<h4 id="void-pointers"><code>void</code> Pointers<a class="headerlink" href="#void-pointers" title="Permanent link">&para;</a></h4>
<p><code>void*</code> (<code>void</code> pointer, or <a href="http://en.cppreference.com/w/c/language/pointer#Pointers_to_void">pointer to void</a>) is also called the "versatile pointer". It is able to store an address of any object, but does not have the type of this object. This means the pointer must be converted (to the correct type) before operating on the object. Pointer to object of any type can be implicitly converted to <code>void</code> pointer to void, and vice versa.</p>
<p>The following code:</p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="nf">test</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">cp</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%02x &quot;</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">cp</span> <span class="o">+</span> <span class="n">i</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mh">0x00112233</span><span class="p">;</span>
    <span class="n">test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>will output:</p>
<div class="codehilite"><pre>33 22 11 00
</pre></div>


<h4 id="initializing-pointers">Initializing Pointers<a class="headerlink" href="#initializing-pointers" title="Permanent link">&para;</a></h4>
<p>A pointer can be initialized with an initializer:</p>
<ul>
<li>The null-pointer constant: <code>NULL</code>.</li>
<li>A pointer of the same type, or a pointer of same type and with less qualifiers.</li>
<li>A <code>void</code> pointer.</li>
</ul>
<p>A non-automatic or static pointer variable must be initialized using a compile-time constant expression, such as a function name.</p>
<div class="codehilite"><pre><span class="kt">char</span> <span class="n">s</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;abc&quot;</span><span class="p">;</span>
<span class="kt">char</span><span class="o">*</span> <span class="n">sp</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">xp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">test</span><span class="p">()</span> <span class="p">{}</span>
<span class="k">typedef</span> <span class="nf">void</span><span class="p">(</span><span class="o">*</span><span class="n">test_t</span><span class="p">)();</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">int</span><span class="o">*</span> <span class="n">sx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>
    <span class="k">static</span> <span class="n">test_t</span> <span class="n">t</span> <span class="o">=</span> <span class="n">test</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Note that in the above code, <code>typedef void(*test_t)()</code> declares a pointer type (as discussed in <a href="#function-types">a prior section</a>).</p>
<h4 id="pointer-operations">Pointer Operations<a class="headerlink" href="#pointer-operations" title="Permanent link">&para;</a></h4>
<h5 id="using-equality-operators"><strong>Using equality operators</strong> *<a class="headerlink" href="#using-equality-operators" title="Permanent link">&para;</a></h5>
<p>An <a href="http://en.cppreference.com/w/c/language/operator_comparison#Equality_operators">equality operator</a> can be used to determine two pointers point to the same object.</p>
<div class="codehilite"><pre><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>
<span class="n">b</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>

<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">);</span>
</pre></div>


<h5 id="using-addition-operators"><strong>Using addition operators</strong> *<a class="headerlink" href="#using-addition-operators" title="Permanent link">&para;</a></h5>
<p>An addition operation on a pointer can get the pointer to the <em>n</em>-th element of the array. (See <a href="http://en.cppreference.com/w/c/language/operator_arithmetic#Pointer_arithmetic">pointer arithmetic</a>)</p>
<div class="codehilite"><pre><span class="kt">int</span> <span class="n">x</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">};</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>

<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d, %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">*</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
</pre></div>


<h5 id="using-subtraction-operators"><strong>Using subtraction operators</strong> *<a class="headerlink" href="#using-subtraction-operators" title="Permanent link">&para;</a></h5>
<p>An subtraction operation on a pointer can get index number of the array element the pointer points to.</p>
<div class="codehilite"><pre><span class="kt">int</span> <span class="n">x</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">};</span>

<span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
<span class="n">p</span><span class="o">++</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="n">x</span><span class="p">;</span>

<span class="n">printf</span><span class="p">(</span><span class="s">&quot;x[%d] = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
</pre></div>


<h5 id="using-relational-operators"><strong>Using relational operators</strong> *<a class="headerlink" href="#using-relational-operators" title="Permanent link">&para;</a></h5>
<p>Using a <a href="http://en.cppreference.com/w/c/language/operator_comparison#Relational_operators">relation operator</a> to compare pointers is equivalent to comparing index numbers of array elements.</p>
<p>The following code:</p>
<div class="codehilite"><pre><span class="kt">int</span> <span class="n">x</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">};</span>

<span class="kt">int</span><span class="o">*</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
<span class="n">p1</span><span class="o">++</span><span class="p">;</span> <span class="n">p2</span><span class="o">++</span><span class="p">;</span> <span class="n">p2</span><span class="o">++</span><span class="p">;</span>

<span class="n">printf</span><span class="p">(</span><span class="s">&quot;p1 &lt; p2? %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p1</span> <span class="o">&lt;</span> <span class="n">p2</span> <span class="o">?</span> <span class="s">&quot;Y&quot;</span> <span class="o">:</span> <span class="s">&quot;N&quot;</span><span class="p">);</span>
</pre></div>


<p>outputs:</p>
<div class="codehilite"><pre>p1 &lt; p2? Y
</pre></div>


<h5 id="using-xi"><strong>Using <code>&amp;x[i]</code></strong><a class="headerlink" href="#using-xi" title="Permanent link">&para;</a></h5>
<p><code>&amp;x[i]</code> can be used to get the pointer that points to the array element specified by index number <code>i</code>.</p>
<div class="codehilite"><pre><span class="kt">int</span> <span class="n">x</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">};</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="o">*</span><span class="n">p</span> <span class="o">+=</span> <span class="mi">10</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</pre></div>


<p>Note that <code>[]</code> takes precedence over <code>&amp;</code>, and <code>*</code> takes precedence over arithmetic operators.</p>
<h4 id="qualifiers">Qualifiers<a class="headerlink" href="#qualifiers" title="Permanent link">&para;</a></h4>
<p>The <code>const</code> qualifier can be used to declare:</p>
<ul>
<li>A <a href="../part2/#constant-pointer">constant pointer</a>: a constant of pointer type.</li>
<li>A <a href="../part2/#pointer-to-constant">pointer to constant</a>: a pointer that points to a constant.</li>
</ul>
<div class="codehilite"><pre><span class="kt">int</span> <span class="n">x</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">};</span>

<span class="c1">// constant pointer: the pointer itself is a constant, which cannot</span>
<span class="c1">// be modified, but the object it points to can be modified</span>
<span class="kt">int</span><span class="o">*</span> <span class="k">const</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
<span class="o">*</span><span class="p">(</span><span class="n">p1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">22</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

<span class="c1">// pointer to constant: the object it points to is a constant,</span>
<span class="c1">// which cannot be modified, but the pointer can be modified</span>
<span class="kt">int</span> <span class="k">const</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>  <span class="c1">// equivalent to: const int *p2 = x;</span>
<span class="n">p2</span><span class="o">++</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">p2</span><span class="p">);</span>
</pre></div>


<p>They differ in whether <code>const</code> qualifies <code>p</code> or <code>*p</code>.
o</p>
<p>A pointer with a <a href="http://en.cppreference.com/w/c/language/restrict"><code>restrict</code></a> qualifier is called a restrict-qualified pointer (or restrict pointer). It suggests to the compiler that during the <code>lifetime</code> of the pointer it is only allowed to modify the object through this pointer, but the complier can decide on its own whether to adopt this suggestion.</p>
<h4 id="pointer-to-array">Pointer to Array<a class="headerlink" href="#pointer-to-array" title="Permanent link">&para;</a></h4>
<p>A "pointer to array" is a pointer to an array, not a pointer to the first element of this array.</p>
<div class="codehilite"><pre><span class="kt">int</span> <span class="n">x</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">};</span>
<span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)[]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;x[%d] = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)[</span><span class="n">i</span><span class="p">]);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;x[%d] = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">+</span> <span class="n">i</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>


<p><code>&amp;x</code> returns a pointer to the array. <code>*p</code> obtains the same pointer as <code>x</code>, namely the pointer to the first element, and the subscript or pointer operation can be used to access elements.</p>
<h4 id="array-of-pointers">Array of Pointers<a class="headerlink" href="#array-of-pointers" title="Permanent link">&para;</a></h4>
<p>An array of pointers is the one whose elements are pointers. It is usually used to represent an array of strings or a <a href="https://en.wikipedia.org/wiki/Jagged_array">jagged array</a>. This kind of array's elements are pointers to the target objects (which can be arrays or other objects) instead of actual contents.</p>
<p>The following code:</p>
<div class="codehilite"><pre><span class="kt">int</span><span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{};</span>

<span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">[]){</span> <span class="mi">1</span> <span class="p">};</span>
<span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">[]){</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">22</span> <span class="p">};</span>
<span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">[]){</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">33</span> <span class="p">};</span>

<span class="kt">int</span><span class="o">*</span> <span class="n">x1</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">x1</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>


<p>will output:</p>
<div class="codehilite"><pre>2
2
22
22
</pre></div>


<p>Array <code>x</code> has three pointers to (three) target objects (arrays). <code>*(x + 1)</code> obtains the target object, which is equivalent to <code>x[1]</code>.</p>
<h3 id="structs">Structs<a class="headerlink" href="#structs" title="Permanent link">&para;</a></h3>
<h4 id="incomplete-structs">Incomplete Structs<a class="headerlink" href="#incomplete-structs" title="Permanent link">&para;</a></h4>
<p>A <a href="http://en.cppreference.com/w/c/language/struct">struct</a> cannot have a member of its own type, but it can have a member as a pointer to its own type. See also <a href="http://en.cppreference.com/w/c/language/type#Incomplete_types">incomplete types</a>.</p>
<div class="codehilite"><pre><span class="k">struct</span> <span class="n">list_node</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">list_node</span><span class="o">*</span> <span class="n">prev</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">list_node</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">value</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>Only a struct tag can be used to define an incomplete struct type. Using <a href="https://en.wikipedia.org/wiki/Typedef"><code>typedef</code></a> like below is not allowed:</p>
<div class="codehilite"><pre><span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
    <span class="n">list_node</span><span class="o">*</span> <span class="n">prev</span><span class="p">;</span>
    <span class="n">list_node</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span> <span class="n">list_node</span><span class="p">;</span>
</pre></div>


<p>This will result in a compiler error:</p>
<div class="codehilite"><pre>$ make
gcc -Wall -g -c -std=c99 -o main.o main.c
main.c:15: error: expected specifier-qualifier-list before ‘list_node’
</pre></div>


<p><code>typedef</code> and the struct tag can be used together:</p>
<div class="codehilite"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">node_t</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">node_t</span><span class="o">*</span> <span class="n">prev</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">node_t</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span> <span class="n">list_node</span><span class="p">;</span>
</pre></div>


<p>The tag name can be the same as the type name defined by <code>typedef</code>:</p>
<div class="codehilite"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">node_t</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">node_t</span><span class="o">*</span> <span class="n">prev</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">node_t</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span> <span class="n">node_t</span><span class="p">;</span>
</pre></div>


<h4 id="anonymous-stucts">Anonymous Stucts<a class="headerlink" href="#anonymous-stucts" title="Permanent link">&para;</a></h4>
<p>It is a common usage to use an anonymous struct as a member within a struct.</p>
<div class="codehilite"><pre><span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
    <span class="k">struct</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
        <span class="kt">char</span> <span class="n">chars</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
    <span class="p">}</span> <span class="n">s</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span> <span class="n">data_t</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">data_t</span> <span class="n">d</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">chars</span> <span class="o">=</span> <span class="s">&quot;abcd&quot;</span><span class="p">,</span> <span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">1234</span> <span class="p">};</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">%s</span><span class="se">\n</span><span class="s">%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">d</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">,</span> <span class="n">d</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">chars</span><span class="p">,</span> <span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>It can also be used to define a variable:</p>
<div class="codehilite"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">a</span><span class="p">;</span> <span class="kt">char</span> <span class="n">b</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span> <span class="p">}</span> <span class="n">d</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="p">.</span><span class="n">b</span> <span class="o">=</span> <span class="s">&quot;abcd&quot;</span> <span class="p">};</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">d</span><span class="p">.</span><span class="n">a</span><span class="p">,</span> <span class="n">d</span><span class="p">.</span><span class="n">b</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h4 id="member-offsets">Member Offsets<a class="headerlink" href="#member-offsets" title="Permanent link">&para;</a></h4>
<p>The <a href="http://en.cppreference.com/w/c/types/offsetof"><code>offsetof</code></a> macro in <code>stddef.h</code> can be used to get the offset value of a member:</p>
<p><small><a href="https://gist.github.com/shichao-an/4337a3f6b19adb668086543bb9699ee9">struct_offset.c</a></small></p>
<div class="codehilite"><pre><span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">short</span> <span class="n">y</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">z</span><span class="p">;</span>
<span class="p">}</span> <span class="n">data_t</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;x %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">data_t</span><span class="p">,</span> <span class="n">x</span><span class="p">));</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;y %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">data_t</span><span class="p">,</span> <span class="n">y</span><span class="p">));</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;y[1] %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">data_t</span><span class="p">,</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]));</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;z %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">data_t</span><span class="p">,</span> <span class="n">z</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>This will output:</p>
<div class="codehilite"><pre>x 0
y 4
y[1] 6
z 16
</pre></div>


<p>Note the <a href="https://en.wikipedia.org/wiki/Data_structure_alignment#Typical_alignment_of_C_structs_on_x86">byte alignment</a> in the output. See also <a href="http://en.cppreference.com/w/c/language/object">object and alignment</a>.</p>
<h4 id="struct-definitions">Struct Definitions<a class="headerlink" href="#struct-definitions" title="Permanent link">&para;</a></h4>
<p>There are many flexible ways to define structs.</p>
<p>The following code:</p>
<div class="codehilite"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="cm">/* directly define the struct type and a variable */</span>
    <span class="k">struct</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span> <span class="kt">short</span> <span class="n">y</span><span class="p">;</span> <span class="p">}</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">},</span> <span class="n">a2</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;a.x = %d, a.y = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>

    <span class="cm">/* the struct type can also be defined inside a function */</span>
    <span class="k">struct</span> <span class="n">data</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span> <span class="kt">short</span> <span class="n">y</span><span class="p">;</span> <span class="p">};</span>

    <span class="k">struct</span> <span class="n">data</span> <span class="n">b</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">3</span> <span class="p">};</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;b.x = %d, b.y = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>

    <span class="cm">/* compound literal */</span>
    <span class="k">struct</span> <span class="n">data</span><span class="o">*</span> <span class="n">c</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="k">struct</span> <span class="n">data</span><span class="p">){</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">};</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;c.x = %d, c.y = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">y</span><span class="p">);</span>

    <span class="cm">/* directly place the struct type definition inside the compound literal */</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="k">struct</span> <span class="n">data2</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span> <span class="kt">short</span> <span class="n">y</span><span class="p">;</span> <span class="p">}){</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">22</span> <span class="p">};</span>

    <span class="cm">/* structs with the same memory layout can be cast from each other */</span>
    <span class="k">struct</span> <span class="n">data</span><span class="o">*</span> <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">data</span><span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;d.x = %d, d.y = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">y</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>will output:</p>
<div class="codehilite"><pre>a.x = 1, a.y = 2
b.x = 0, b.y = 3
c.x = 1, c.y = 2
d.x = 11, d.y = 22
</pre></div>


<h4 id="struct-initialization">Struct Initialization<a class="headerlink" href="#struct-initialization" title="Permanent link">&para;</a></h4>
<p>Initializing a struct is as simple as initializing an array, including using initializers to initialize specific members. Uninitialized members are set to 0.</p>
<div class="codehilite"><pre><span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">short</span> <span class="n">y</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">z</span><span class="p">;</span>
<span class="p">}</span> <span class="n">data_t</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">data_t</span> <span class="n">d</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">data_t</span> <span class="n">d1</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="p">{</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">33</span> <span class="p">},</span> <span class="mi">2LL</span> <span class="p">};</span>
    <span class="n">data_t</span> <span class="n">d2</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="mi">3LL</span><span class="p">,</span> <span class="p">.</span><span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="p">};</span>
    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>The result is:</p>
<div class="codehilite"><pre>d = {x = 0, y = {0, 0, 0}, z = 0}
d1 = {x = 1, y = {11, 22, 33}, z = 2}
d2 = {x = 0, y = {0, 0, 2}, z = 3}
</pre></div>


<h4 id="flexible-array-member">Flexible Array Member<a class="headerlink" href="#flexible-array-member" title="Permanent link">&para;</a></h4>
<p>A struct that contains a <a href="https://en.wikipedia.org/wiki/Flexible_array_member">flexible array member</a> is also known as a "variable length struct". The flexible array member is an array, without its size specified, as the last member of its struct. See also <a href="http://en.cppreference.com/w/c/language/struct">struct declaration</a>.</p>
<p><small><a href="https://gist.github.com/shichao-an/b735bc3a6f42eecd4802fad3f677511a#file-flexible_array_member-c">flexible_array_member.c</a></small></p>
<div class="codehilite"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">string</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">chars</span><span class="p">[];</span>
<span class="p">}</span> <span class="n">string</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">string</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>  <span class="c1">// length for a 10-byte string (\0 included)</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">len</span><span class="p">];</span>                  <span class="c1">// allocate storage from the stack</span>

    <span class="n">string</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">string</span><span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>       <span class="c1">// convert to a struct string pointer</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">chars</span><span class="p">,</span> <span class="s">&quot;123456789&quot;</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">chars</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Considering different compilers and ANSI C standards, <code>char chars[]</code> can be replaced by <code>char chars[1]</code> or <code>char</code>.</p>
<p>Note that when copying this kind of structs, the last array member won't be copied.</p>
<p><small><a href="https://gist.github.com/shichao-an/b735bc3a6f42eecd4802fad3f677511a#file-flexible_array_member_copy-c">flexible_array_member_copy.c</a></small></p>
<div class="codehilite"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">string</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">len</span><span class="p">];</span>

    <span class="n">string</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">string</span><span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">chars</span><span class="p">,</span> <span class="s">&quot;123456789&quot;</span><span class="p">);</span>

    <span class="n">string</span> <span class="n">s2</span> <span class="o">=</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>                          <span class="c1">// copy struct string s</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s2</span><span class="p">.</span><span class="n">length</span><span class="p">,</span> <span class="n">s2</span><span class="p">.</span><span class="n">chars</span><span class="p">);</span> <span class="c1">// s2.length is copied, s2.chars is not</span>
    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Furthermore, the flexible array member cannot be initialized.</p>
<h3 id="union">Union<a class="headerlink" href="#union" title="Permanent link">&para;</a></h3>
<p>A <a href="http://en.cppreference.com/w/c/language/union">union</a> is different from a struct in that: a union can only store one member, and the union's size is determined by the member with the largest size.</p>
<div class="codehilite"><pre><span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
    <span class="k">union</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">ivalue</span><span class="p">;</span>
        <span class="kt">long</span> <span class="kt">long</span> <span class="n">lvalue</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span> <span class="n">data_t</span><span class="p">;</span>

<span class="n">data_t</span> <span class="n">d</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x8899</span><span class="p">,</span> <span class="p">.</span><span class="n">value</span><span class="p">.</span><span class="n">lvalue</span> <span class="o">=</span> <span class="mh">0x1234LL</span> <span class="p">};</span>
<span class="n">data_t</span> <span class="n">d2</span><span class="p">;</span>
<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">d</span><span class="p">));</span>

<span class="n">printf</span><span class="p">(</span><span class="s">&quot;type:%d, value:%lld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">d2</span><span class="p">.</span><span class="n">type</span><span class="p">,</span> <span class="n">d2</span><span class="p">.</span><span class="n">value</span><span class="p">.</span><span class="n">lvalue</span><span class="p">);</span>
</pre></div>


<p>Though the above example can also be implemented with pointers, the union embeds the data in the struct. This facilitates the use of <a href="http://en.cppreference.com/w/c/string/byte/memcpy"><code>memcpy</code></a> and makes pointer type conversions unnecessary.</p>
<p>A union can be <a href="http://en.cppreference.com/w/c/language/struct_initialization">initialized</a> using initializers; if no designator is specified, then it defaults to the first member.</p>
<div class="codehilite"><pre><span class="k">union</span> <span class="n">value_t</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ivalue</span><span class="p">;</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">lvalue</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">union</span> <span class="n">value_t</span> <span class="n">v1</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">10</span> <span class="p">};</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">v1</span><span class="p">.</span><span class="n">ivalue</span><span class="p">);</span>

<span class="k">union</span> <span class="n">value_t</span> <span class="n">v2</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">lvalue</span> <span class="o">=</span> <span class="mi">20LL</span> <span class="p">};</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%lld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">v2</span><span class="p">.</span><span class="n">lvalue</span><span class="p">);</span>

<span class="k">union</span> <span class="n">value2_t</span> <span class="p">{</span> <span class="kt">char</span> <span class="n">c</span><span class="p">;</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span> <span class="n">v3</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">100</span> <span class="p">};</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">v3</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
</pre></div>


<p>The following example is a common usage of unions:</p>
<div class="codehilite"><pre><span class="k">union</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span> <span class="k">struct</span> <span class="p">{</span><span class="kt">char</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">;}</span> <span class="n">bytes</span><span class="p">;</span> <span class="p">}</span> <span class="n">n</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x12345678</span> <span class="p">};</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%#x =&gt; %x, %x, %x, %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">.</span><span class="n">bytes</span><span class="p">.</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span><span class="p">.</span><span class="n">bytes</span><span class="p">.</span><span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">.</span><span class="n">bytes</span><span class="p">.</span><span class="n">c</span><span class="p">,</span> <span class="n">n</span><span class="p">.</span><span class="n">bytes</span><span class="p">.</span><span class="n">d</span><span class="p">);</span>
</pre></div>


<p>will output:</p>
<div class="codehilite"><pre>0x12345678 =&gt; 78, 56, 34, 12
</pre></div>


<h3 id="bit-fields"><a href="http://en.cppreference.com/w/c/language/bit_field">Bit Fields</a><a class="headerlink" href="#bit-fields" title="Permanent link">&para;</a></h3>
<p>Multiple members of a struct or union can be "compressed and stored" in a single field to save memory.</p>
<div class="codehilite"><pre><span class="k">struct</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">year</span> <span class="p">:</span> <span class="mi">22</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">month</span> <span class="p">:</span> <span class="mi">4</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">day</span> <span class="p">:</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">}</span> <span class="n">d</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">2010</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">30</span> <span class="p">};</span>

<span class="n">printf</span><span class="p">(</span><span class="s">&quot;size: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">d</span><span class="p">));</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;year = %u, month = %u, day = %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">d</span><span class="p">.</span><span class="n">year</span><span class="p">,</span> <span class="n">d</span><span class="p">.</span><span class="n">month</span><span class="p">,</span> <span class="n">d</span><span class="p">.</span><span class="n">day</span><span class="p">);</span>
</pre></div>


<p>A common usage of bit fields is <a href="https://en.wikipedia.org/wiki/Flag_field">flag fields</a>, which is more straightforward than <a href="https://en.wikipedia.org/wiki/Bitwise_operation">bitwise operation</a> and saves memory.</p>
<p><small><a href="https://gist.github.com/shichao-an/f77f1a8a70f34942d3bd480866d73408#file-bit_field-c">bit_field.c</a></small></p>
<div class="codehilite"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="k">struct</span>
    <span class="p">{</span>
        <span class="kt">bool</span> <span class="nl">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="nl">b</span><span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="nl">c</span><span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">flags</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">b</span> <span class="o">=</span> <span class="nb">true</span> <span class="p">};</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">flags</span><span class="p">.</span><span class="n">b</span> <span class="o">?</span> <span class="s">&quot;b.T&quot;</span> <span class="o">:</span> <span class="s">&quot;b.F&quot;</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">flags</span><span class="p">.</span><span class="n">c</span> <span class="o">?</span> <span class="s">&quot;c.T&quot;</span> <span class="o">:</span> <span class="s">&quot;c.F&quot;</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p><a href="http://en.cppreference.com/w/c/types/offsetof"><code>offsetof</code></a> cannot be used on a bit field.</p>
<h3 id="declarations">Declarations<a class="headerlink" href="#declarations" title="Permanent link">&para;</a></h3>
<p>A <a href="http://en.cppreference.com/w/c/language/declarations">declaration</a> specifies the meaning and properties of a target. The same target can be declared in multiple places, but only one <a href="http://en.cppreference.com/w/c/language/declarations#Definitions">definition</a> is allowed.</p>
<p>A definition creates the object and allocate storage for it, while a declaration does not.</p>
<p>A declaration normally include:</p>
<ul>
<li>Declaring a user-defined type (UDT), such as struct, union and enumeration.</li>
<li>Declaring a function.</li>
<li>Declaring and defining a <a href="https://en.wikipedia.org/wiki/Global_variable">global variable</a>.</li>
<li>Delcaring an <a href="https://en.wikipedia.org/wiki/External_variable">external variable</a>.</li>
<li>Using <code>typedef</code> to declare a new name for an existing type.</li>
</ul>
<p>If the function body is present when declaring a function, then this declaration is also a definition.</p>
<p>If storage is allocated for the object when it is declared, then this declaration is also a definition.</p>
<h4 id="type-qualifiers">Type Qualifiers<a class="headerlink" href="#type-qualifiers" title="Permanent link">&para;</a></h4>
<p>The <a href="https://en.wikipedia.org/wiki/Type_qualifier">type qualifiers</a> in C99 are:</p>
<ul>
<li><a href="http://en.cppreference.com/w/c/language/const"><code>const</code></a>: constant qualifier. The object cannot be modifed.</li>
<li><a href="http://en.cppreference.com/w/c/language/volatile"><code>volatile</code></a>: the target may be modified by other threads or events. Before using this variable, it must be re-accessed from the memory.</li>
<li><a href="http://en.cppreference.com/w/c/language/restrict"><code>restrict</code></a>: restrict-qualified pointer. Except through this pointer, no other way is allowed to modify the target object.</li>
</ul>
<h4 id="linkage">Linkage<a class="headerlink" href="#linkage" title="Permanent link">&para;</a></h4>
<table>
<thead>
<tr>
<th>Element</th>
<th><a href="http://en.cppreference.com/w/c/language/storage_duration#Storage_duration">Storage</a></th>
<th><a href="http://en.cppreference.com/w/c/language/scope">Scope</a></th>
<th><a href="http://en.cppreference.com/w/c/language/lifetime">Lifetime</a></th>
<th><a href="http://en.cppreference.com/w/c/language/storage_duration#Linkage">Linkage</a></th>
</tr>
</thead>
<tbody>
<tr>
<td>Global UDTs</td>
<td></td>
<td>File</td>
<td></td>
<td>Internal linkage</td>
</tr>
<tr>
<td>Nested UDTs</td>
<td></td>
<td>Class</td>
<td></td>
<td>Internal linkage</td>
</tr>
<tr>
<td>Local UDTs</td>
<td></td>
<td>Block</td>
<td>No linkage</td>
<td></td>
</tr>
<tr>
<td>Global functions and variables</td>
<td><code>extern</code></td>
<td>File</td>
<td>Permanent</td>
<td>External linkage</td>
</tr>
<tr>
<td>Static global functions and variables</td>
<td><code>static</code></td>
<td>File</td>
<td>Permanent</td>
<td>Internal linkage</td>
</tr>
<tr>
<td>Local variables and constants</td>
<td><code>auto</code></td>
<td>Block</td>
<td>Temporary</td>
<td>No linkage</td>
</tr>
<tr>
<td>Global static variables and constants</td>
<td><code>static</code></td>
<td>Block</td>
<td>Permanent</td>
<td>No linkage</td>
</tr>
<tr>
<td>Global constants</td>
<td></td>
<td>File</td>
<td>Permanent</td>
<td>Internal linkage</td>
</tr>
<tr>
<td>Static global constants</td>
<td><code>static</code></td>
<td>File</td>
<td>Permanent</td>
<td>Internal linkage</td>
</tr>
<tr>
<td>Macro definitions</td>
<td></td>
<td>File</td>
<td></td>
<td>Internal linkage</td>
</tr>
</tbody>
</table>
<h4 id="implicit-initialization">Implicit Initialization<a class="headerlink" href="#implicit-initialization" title="Permanent link">&para;</a></h4>
<p>Objects that has static storage duration will be initialized to the default value 0 (<code>NULL</code> for pointers).</p>
<h3 id="preprocessor"><a href="http://en.cppreference.com/w/c/preprocessor">Preprocessor</a><a class="headerlink" href="#preprocessor" title="Permanent link">&para;</a></h3>
<p>Preprocessing directives start with <code>#</code> (which can be preceded by spaces or tabs) and are normally one-line, but can continue on the next line with <code>\</code>.</p>
<h4 id="constants">Constants<a class="headerlink" href="#constants" title="Permanent link">&para;</a></h4>
<p>The preprocessor will expand and replace the macros.</p>
<p>The following code:</p>
<div class="codehilite"><pre><span class="cp">#define SIZE 10</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">[</span><span class="n">SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>will expand to:</p>
<div class="codehilite"><pre>$ gcc -E main.c

int main(int argc, char* argv[])
{
    int x[10] = {};
    return 0;
}
</pre></div>


<h4 id="macro-functions">Macro Functions<a class="headerlink" href="#macro-functions" title="Permanent link">&para;</a></h4>
<p>Macros can be used to define pseudo-functions. Usually, <code>({...})</code> is used to structure multi-line statements, with the last expression being return values (no <code>return</code> and ended with <code>;</code>).</p>
<div class="codehilite"><pre><span class="cp">#define test(x, y) ({ \</span>
<span class="cp">    int _z = x + y; \</span>
<span class="cp">    _z; })</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">test</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>will expand to:</p>
<div class="codehilite"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">({</span> <span class="kt">int</span> <span class="n">_z</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span> <span class="n">_z</span><span class="p">;</span> <span class="p">}));</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h4 id="variadic-macros">Variadic Macros<a class="headerlink" href="#variadic-macros" title="Permanent link">&para;</a></h4>
<p><code>__VA_ARGS__</code> can be used to represent variable number of arguments.</p>
<div class="codehilite"><pre><span class="cp">#define println(format, ...) ({ \</span>
<span class="cp">    printf(format &quot;\n&quot;, __VA_ARGS__); })</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">println</span><span class="p">(</span><span class="s">&quot;%s, %d&quot;</span><span class="p">,</span> <span class="s">&quot;string&quot;</span><span class="p">,</span> <span class="mi">1234</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>will expand to:</p>
<div class="codehilite"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="p">({</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s, %d&quot;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;string&quot;</span><span class="p">,</span> <span class="mi">1234</span><span class="p">);</span> <span class="p">});</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h4 id="stringification-operator">Stringification Operator<a class="headerlink" href="#stringification-operator" title="Permanent link">&para;</a></h4>
<p>Unary operator <code>#</code> will turn a macro parameter into a string. See also <a href="https://gcc.gnu.org/onlinedocs/cpp/Stringification.html">stringification</a> and <a href="http://en.cppreference.com/w/c/preprocessor/replace">replacing text macros</a>.</p>
<p>The following code:</p>
<div class="codehilite"><pre><span class="cp">#define test(name) ({ \</span>
<span class="cp">    printf(&quot;%s\n&quot;, #name); })</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">test</span><span class="p">(</span><span class="n">main</span><span class="p">);</span>
    <span class="n">test</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">main&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>will expand to:</p>
<div class="codehilite"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="p">({</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;main&quot;</span><span class="p">);</span> <span class="p">});</span>
    <span class="p">({</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\&quot;\\\&quot;</span><span class="s">main</span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="p">);</span> <span class="p">});</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>The preprocessor adds backslashes to escape the quotes surrounding embedded string literals, and doubles the backslashes within the string as necessary.</p>
<h4 id="token-pasting-operator">Token-pasting Operator<a class="headerlink" href="#token-pasting-operator" title="Permanent link">&para;</a></h4>
<p>Binary operator <code>#</code> concatenate left operand and right operand to form a single token.</p>
<p>The following code:</p>
<div class="codehilite"><pre><span class="cp">#define test(name, index) ({ \</span>
<span class="cp">    int i, len = sizeof(name ## index) / sizeof(int); \</span>
<span class="cp">    for (i = 0; i &lt; len; i++) \</span>
<span class="cp">    { \</span>
<span class="cp">    printf(&quot;%d\n&quot;, name ## index[i]); \</span>
<span class="cp">    }})</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x1</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">};</span>
    <span class="kt">int</span> <span class="n">x2</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">44</span><span class="p">,</span> <span class="mi">55</span> <span class="p">};</span>
    <span class="n">test</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">test</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>will expand to:</p>
<div class="codehilite"><pre>int main(int argc, char* argv[])
{
    int x1[] = { 1, 2, 3 };
    int x2[] = { 11, 22, 33, 44, 55 };
    ({ int i, len = sizeof(x1) / sizeof(int); for (i = 0; i &lt; len; i++) { printf(&quot;%d\n&quot;, x1[i]); }});
    ({ int i, len = sizeof(x2) / sizeof(int); for (i = 0; i &lt; len; i++) { printf(&quot;%d\n&quot;, x2[i]); }});
    return 0;
}
</pre></div>


<h4 id="conditional-compilation">Conditional Compilation<a class="headerlink" href="#conditional-compilation" title="Permanent link">&para;</a></h4>
<p><code>#if ... #elif ... #else ... #endif</code>, <code>#define</code>, and <code>#undef</code> can be used to perform <a href="https://en.wikipedia.org/wiki/Conditional_compilation">conditional compilation</a>. See also <a href="http://en.cppreference.com/w/c/preprocessor/conditional">conditional inclusion</a>.</p>
<p>The following code:</p>
<div class="codehilite"><pre><span class="cp">#define V1</span>

<span class="cp">#if defined(V1) || defined(V2)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Old</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#else</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;New</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#undef V1</span>
</pre></div>


<p>will expand to:</p>
<div class="codehilite"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Old</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p><code>#ifdef</code>, <code>#ifndef</code> can replace <code>#if</code>.</p>
<p>The following code:</p>
<div class="codehilite"><pre><span class="cp">#define V1</span>

<span class="cp">#ifdef V1</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Old</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#else</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;New</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#undef A</span>
</pre></div>


<p>will expand to:</p>
<div class="codehilite"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Old</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h4 id="typeof"><code>typeof</code><a class="headerlink" href="#typeof" title="Permanent link">&para;</a></h4>
<p>The GCC extension <a href="https://gcc.gnu.org/onlinedocs/gcc/Typeof.html"><code>typeof</code></a> can obtain the type of an argument.</p>
<p><small><a href="https://gist.github.com/shichao-an/962dc6f27da887a03efebced1f77f487#file-typeof-c">typeof.c</a></small></p>
<div class="codehilite"><pre><span class="cp">#define test(x) ({ \</span>
<span class="cp">    typeof(x) _x = (x); \</span>
<span class="cp">    _x += 1; \</span>
<span class="cp">    _x; \</span>
<span class="cp">})</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">float</span> <span class="n">f</span> <span class="o">=</span> <span class="mf">0.5F</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">f2</span> <span class="o">=</span> <span class="n">test</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">f2</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h4 id="others">Others<a class="headerlink" href="#others" title="Permanent link">&para;</a></h4>
<p>Some commonly-used special constants (<a href="https://gcc.gnu.org/onlinedocs/cpp/Standard-Predefined-Macros.html">Standard Predefined Macros</a>):</p>
<ul>
<li><code>#error "message"</code> : define compiler error message.</li>
<li><code>__DATE__</code>: string for the compiling date.</li>
<li><code>__TIME__</code>: string for the compiling time.</li>
<li><code>__FILE__</code>: current file name.</li>
<li><code>__LINE__</code>: current line number.</li>
<li><code>__func__</code>: current function name.</li>
</ul>
<h3 id="debugging">Debugging<a class="headerlink" href="#debugging" title="Permanent link">&para;</a></h3>
<p>Develop a habit of using the <a href="http://en.cppreference.com/w/c/error/assert"><code>assert</code></a> macro on function arguments and conditions, which saves yourself much trouble.</p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">test</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">test</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>The expansion result is:</p>
<div class="codehilite"><pre><span class="c1">// $ gcc -E main.c</span>

<span class="kt">void</span> <span class="nf">test</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">((</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">__assert_fail</span> <span class="p">(</span><span class="s">&quot;x &gt; 0&quot;</span><span class="p">,</span> <span class="s">&quot;main.c&quot;</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="n">__PRETTY_FUNCTION__</span><span class="p">));</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>If the <code>assert</code> condition expression is not true, it outputs error and <a href="http://en.cppreference.com/w/c/program/abort">aborts</a>.</p>
<p>However, when compiling a release version, remember to add <code>-DNDEBUG</code> argument to disable <code>assert</code>.</p>
<div class="codehilite"><pre><span class="c1">// $ gcc -E -DNDEBUG main.c</span>

<span class="kt">void</span> <span class="nf">test</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">((</span><span class="kt">void</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span><span class="p">));</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<h3 id="doubts-and-solutions">Doubts and Solutions<a class="headerlink" href="#doubts-and-solutions" title="Permanent link">&para;</a></h3>
<h4 id="verbatim">Verbatim<a class="headerlink" href="#verbatim" title="Permanent link">&para;</a></h4>
<h5 id="p29-on-multidimensional-arrays"><strong>p29 on multidimensional arrays</strong><a class="headerlink" href="#p29-on-multidimensional-arrays" title="Permanent link">&para;</a></h5>
<div class="codehilite"><pre><span class="kt">int</span> <span class="n">x</span><span class="p">[][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">11</span> <span class="p">},</span>
    <span class="p">{</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">22</span> <span class="p">},</span>
    <span class="p">{</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">33</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">x</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;x[%d] = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>


<p><span class="text-danger">Question</span>: The array <code>x</code> is cast into a pointer p of type <code>int*</code> and iterated over like a one-dimensional regular array. Does this mean <code>p</code> is a "flattened" version of <code>x</code>?</p>
<hr />
<h3 id="references">References<a class="headerlink" href="#references" title="Permanent link">&para;</a></h3>
<ul>
<li><a href="http://en.cppreference.com/w/c">C reference - cppreference.com</a></li>
<li>[CPP] <em>C Primer Plus</em> (6th Edition)</li>
</ul>
            </div>
        </div>

        <footer class="col-md-12">
            
        </footer>

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script>
        <script src="../../js/base.js"></script>
        <script src="../../custom.js"></script>
    </body>
</html>