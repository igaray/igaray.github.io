<!DOCTYPE html>
<html lang="en">
    <head>
        <!-- Global Site Tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-59055167-2"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments)};
          gtag('js', new Date());

          gtag('config', 'UA-59055167-2');
        </script>

        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://notes.shichao.io/devops/ch7/">
        <link rel="shortcut icon" href="../../toki_32.png">
        

	<title>Chapter 7. Monitoring - Shichao's Notes</title>

        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../../css/base.css" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,400italic,500,600" rel="stylesheet">
        <link href="../../custom.css" rel="stylesheet">
        <link href="../../friendly.css" rel="stylesheet">
        <link href="../../theme.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        
<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../..">Shichao's Notes</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">APUE <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../apue/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch1/">Chapter 1. UNIX System Overview</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch2/">Chapter 2. UNIX Standardization and Implementations</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch3/">Chapter 3. File I/O</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch4/">Chapter 4. Files and Directories</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch5/">Chapter 5. Standard I/O Library</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch6/">Chapter 6. System Data Files and Information</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch7/">Chapter 7. Process Environment</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch8/">Chapter 8. Process Control</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch9/">Chapter 9. Process Relationships</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch10/">Chapter 10. Signals</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch11/">Chapter 11. Threads</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch12/">Chapter 12. Thread Control</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch13/">Chapter 13. Daemon Processes</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch14/">Chapter 14. Advanced I/O</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch15/">Chapter 15. Interprocess Communication</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch16/">Chapter 16. Network IPC: Sockets</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch17/">Chapter 17. Advanced IPC</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UNP <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../unp/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch2/">Chapter 2. The Transport Layer: TCP, UDP, and SCTP</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch3/">Chapter 3. Sockets Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch4/">Chapter 4. Elementary TCP Sockets</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch5/">Chapter 5. TCP Client/Server Example</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch6/">Chapter 6. I/O Multiplexing: The select and poll Functions</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch7/">Chapter 7. Socket Options</a>
                        </li>
                      
                        <li>
                            <a href="../../unp/ch8/">Chapter 8. Elementary UDP Sockets</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">TCPv1 <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../tcpv1/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch2/">Chapter 2. The Internet Address Architecture</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch3/">Chapter 3. Link Layer</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch4/">Chapter 4. ARP: Address Resolution Protocol</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch5/">Chapter 5. The Internet Protocol (IP)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch6/">Chapter 6. System Configuration: DHCP and Autoconfiguration</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch7/">Chapter 7. Firewalls and Network Address Translation (NAT)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch8/">Chapter 8. ICMPv4 and ICMPv6: Internet Control Message Protocol</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch9/">Chapter 9. Broadcasting and Local Multicasting (IGMP and MLD)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch10/">Chapter 10. User Datagram Protocol (UDP) and IP Fragmentation</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch11/">Chapter 11. Name Resolution and the Domain Name System (DNS)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch12/">Chapter 12. TCP: The Transmission Control Protocol (Preliminaries)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch13/">Chapter 13. TCP Connection Management</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch14/">Chapter 14. TCP Timeout and Retransmission</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch15/">Chapter 15. TCP Data Flow and Window Management</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch16/">Chapter 16. TCP Congestion Control</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch17/">Chapter 17. TCP Keepalive</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch18/">Chapter 18. Security: EAP, IPsec, TLS, DNSSEC, and DKIM</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/headers/">Headers</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">GOPL <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../gopl/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch1/">Chapter 1. Tutorial</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch2/">Chapter 2. Program Structure</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch3/">Chapter 3. Basic Data Types</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch4/">Chapter 4. Composite Types</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch5/">Chapter 5. Functions</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch6/">Chapter 6. Methods</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch7/">Chapter 7. Interfaces</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch8/">Chapter 8. Goroutines and Channels</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch9/">Chapter 9. Concurrency with Shared Variables</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch10/">Chapter 10. Packages and the Go Tool</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch11/">Chapter 11. Testing</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch12/">Chapter 12. Reflection</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">CSN <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../csn/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../csn/part1/">Part 1: Language</a>
                        </li>
                      
                        <li>
                            <a href="../../csn/part2/">Part 2: Advanced</a>
                        </li>
                      
                    </ul>
                </li>
            <li>
                    <a href="../../toc/">TOC</a>
                </li>
            </ul>
            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    
                        <a href="https://github.com/shichao-an/notes/blob/master/docs/devops/ch7.md">
                    
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#chapter-7-monitoring">Chapter 7. Monitoring</a></li>
        
    
        <li class="main "><a href="#introduction">Introduction</a></li>
        
    
        <li class="main "><a href="#what-to-monitor">What to Monitor</a></li>
        
            <li><a href="#failure-detection">Failure Detection</a></li>
        
            <li><a href="#performance-degradation-detection">Performance Degradation Detection</a></li>
        
            <li><a href="#capacity-planning">Capacity Planning</a></li>
        
            <li><a href="#user-interaction">User Interaction</a></li>
        
            <li><a href="#intrusion-detection">Intrusion Detection</a></li>
        
    
        <li class="main "><a href="#how-to-monitor">How to Monitor</a></li>
        
            <li><a href="#agent-based-and-agentless-monitoring">Agent-Based and Agentless Monitoring</a></li>
        
            <li><a href="#monitoring-operation-activities">Monitoring Operation Activities</a></li>
        
            <li><a href="#collection-and-storage">Collection and Storage</a></li>
        
    
        <li class="main "><a href="#when-to-change-the-monitoring-configuration">When to Change the Monitoring Configuration</a></li>
        
    
        <li class="main "><a href="#interpreting-monitoring-data">Interpreting Monitoring Data</a></li>
        
            <li><a href="#logs">Logs</a></li>
        
            <li><a href="#graphing-and-display">Graphing and Display</a></li>
        
            <li><a href="#alarms-and-alerts">Alarms and Alerts</a></li>
        
            <li><a href="#diagnosis-and-reaction">Diagnosis and Reaction</a></li>
        
            <li><a href="#monitoring-devops-processes">Monitoring DevOps Processes</a></li>
        
    
        <li class="main "><a href="#challenges">Challenges</a></li>
        
            <li><a href="#challenge-1-monitoring-under-continuous-changes">Challenge 1: Monitoring Under Continuous Changes</a></li>
        
            <li><a href="#challenge-2-bottom-up-vs-top-down-and-monitoring-in-the-cloud">Challenge 2: Bottom-Up vs. Top-Down and Monitoring in the Cloud</a></li>
        
            <li><a href="#challenge-3-monitoring-a-microservice-architecture">Challenge 3: Monitoring a Microservice Architecture</a></li>
        
            <li><a href="#challenge-4-dealing-with-large-volumes-of-distributed-log-data">Challenge 4: Dealing with Large Volumes of Distributed (Log) Data</a></li>
        
    
        <li class="main "><a href="#tools">Tools</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">
              

<h3 id="chapter-7-monitoring"><strong>Chapter 7. Monitoring</strong><a class="headerlink" href="#chapter-7-monitoring" title="Permanent link">&para;</a></h3>
<h3 id="introduction">Introduction<a class="headerlink" href="#introduction" title="Permanent link">&para;</a></h3>
<p>This chapter focuses on software monitoring. Software monitoring comprises myriad types of monitoring and the considerations that come with them. Activities as varied as collecting metrics at various levels (resources/OS/middleware/application-level), graphing and analyzing metrics, logging, generating alerts concerning system health status, and measuring user interactions all are a portion of what is meant by monitoring.</p>
<p>The insights available from monitoring fall into five different categories:</p>
<ol>
<li>Identifying failures and the associated faults both at runtime and during postmortems held after a failure has occurred.</li>
<li>Identifying performance problems of both individual systems and collections of interacting systems.</li>
<li>Characterizing workload for both short-term and long-term capacity planning and billing purposes.</li>
<li>Measuring user reactions to various types of interfaces or business offerings. A/B testing is disucssed in <a href="../ch5/">Chapters 5</a> and <a href="../ch6/">Chapter 6</a>.</li>
<li>Detecting intruders who are attempting to break into the system.</li>
</ol>
<p>The term <strong>monitoring</strong> refers to the process of observing and recording system state changes and data flows:</p>
<ul>
<li><strong>State changes</strong> can be expressed by direct measurement of the state or by logs recording updates that impact part of the state.</li>
<li><strong>Data flows</strong> can be captured by logging requests and responses between both internal components and external systems.</li>
</ul>
<p>The software supporting such a process is called a <strong>monitoring system</strong>.</p>
<p>Monitoring a workload include the tools and infrastructure associated with operations activities. All of the activities in an environment contribute to a datacenter’s workload, and this includes both operations-centric and monitoring tools.</p>
<p>DevOps’ continuous delivery/ deployment practices and strong reliance on automation mean that changes to the system happen at a much higher frequency. Use of a microservice architecture also makes monitoring of data flows more challenging.</p>
<p>Some examples of the new challenges are:</p>
<ul>
<li><strong>Monitoring under continuous changes is difficult.</strong><ul>
<li>Traditional monitoring relies heavily on anomaly detection. You know the profile of your system during normal operation. You set thresholds on metrics and monitor to detect abnormal behavior. If your system changes, you may have to readjust them. This approach becomes less effective if your system is constantly changing due to continuous deployment practices and cloud elasticity.</li>
<li>Setting thresholds based on normal operation will trigger multiple false alarms during a deployment. Disabling alarms during deployments will, potentially, miss critical errors when a system is already in a fairly unstable state. Multiple deployments can simultaneously occur as we discussed in Chapter 6, and these deployments further complicate the setting of thresholds.</li>
</ul>
</li>
<li><strong>The cloud environment introduces different levels from application programming interface (API) calls to VM resource usage.</strong> Choosing between a top-down approach and a bottom-up approach for different scenarios and balancing the tradeoffs is not easy.</li>
<li><strong>Monitoring requires attention to more moving parts</strong> (when adopting the microservice architecture as introduced in <a href="../ch4/">Chapter 4</a>).<ul>
<li>It also requires logging more inter-service communication to ensure a user request traversing through a dozen services still meets your service level agreements. If anything goes wrong, you need to determine the cause through analysis of large volumes of (distributed) data.</li>
</ul>
</li>
<li><strong>Managing logs becomes a challenge in large-scale distributed systems.</strong><ul>
<li>When you have hundreds or thousands of nodes, collecting all logs centrally becomes difficult or prohibitively expensive. Performing analysis on huge collections of logs is challenging as well, because of the sheer volume of logs, noise, and inconsistencies in logs from multiple independent sources.</li>
</ul>
</li>
</ul>
<p>Monitoring solutions must be tested and validated just as other portions of the infrastructure. Testing a monitoring solution in your various environments is one portion of the testing, but the scale of your non-production environments may not approach the scale of your production—which implies that your monitoring environments may be only partially tested prior to being placed into production</p>
<h3 id="what-to-monitor">What to Monitor<a class="headerlink" href="#what-to-monitor" title="Permanent link">&para;</a></h3>
<p>The following table lists the insights you might gain from the monitoring data and the portions of the stack where such data can be collected: [p129]</p>
<table>
<thead>
<tr>
<th>Goal of Monitoring</th>
<th>Source of Data</th>
</tr>
</thead>
<tbody>
<tr>
<td>Failure detection</td>
<td>Application and infrastructure</td>
</tr>
<tr>
<td>Performance degradation detection</td>
<td>Application and infrastructure</td>
</tr>
<tr>
<td>Capacity planning</td>
<td>Application and infrastructure</td>
</tr>
<tr>
<td>User reaction to business offerings</td>
<td>Application</td>
</tr>
<tr>
<td>Intruder detection</td>
<td>Application and infrastructure</td>
</tr>
</tbody>
</table>
<p>The fundamental items to be monitored consist of inputs, resources, and outcomes:</p>
<ul>
<li>The resources can be hard resources such as CPU, memory, disk, and network (even if virtualized).</li>
<li>They can also be soft resources such as queues, thread pools, or configuration specifications.</li>
<li>The outcomes include items such as transactions and business-oriented activities.</li>
</ul>
<h4 id="failure-detection">Failure Detection<a class="headerlink" href="#failure-detection" title="Permanent link">&para;</a></h4>
<p>Any element of the physical infrastructure can fail. Total failures are relatively easy to detect: No data is flowing where data used to flow. It is the partial failures that are difficult to detect, for instance: a cable is not firmly seated and degrades performance; before a machine totally fails because of overheating it experiences intermittent failure; and so forth.</p>
<p>Detecting failure of the physical infrastructure is the datacenter provider’s problem. Instrumenting the operating system or its virtual equivalent will provide the data for the datacenter.</p>
<p>Software can also fail, either totally or partially. Total failure is relatively easy to detect. Partial software failures have myriad causes (similar to partial hardware failures):</p>
<ul>
<li>The underlying hardware may have a partial failure;</li>
<li>A downstream service may have failed;</li>
<li>The software (or its supporting software) may have been misconfigured.</li>
</ul>
<p>Detecting software failures can be done in one of three fashions:</p>
<ol>
<li>The monitoring software performs <strong>health checks</strong> on the system from an external point.</li>
<li>A <strong>special agent inside the system</strong> performs the monitoring.</li>
<li>The <strong>system itself</strong> detects problems and reports them.</li>
</ol>
<p>Partial failures may also manifest as performance problems (discussed in the following subsection).</p>
<h4 id="performance-degradation-detection">Performance Degradation Detection<a class="headerlink" href="#performance-degradation-detection" title="Permanent link">&para;</a></h4>
<p>Detecting performance degradations is the most common use of monitoring data. Degraded performance can be observed by comparing current performance to historical data, or by complaints from clients or end users. Ideally, the monitoring system catches performance degradation before users are impacted at a notable strength.</p>
<p>Performance measures include <strong>latency</strong>, <strong>throughput</strong>, and <strong>utilization</strong>.</p>
<h5 id="latency"><strong>Latency</strong><a class="headerlink" href="#latency" title="Permanent link">&para;</a></h5>
<p>Latency is the time from the initiation of an activity to its completion, which can be measured at various levels of granularity:</p>
<ul>
<li>At a coarse grain, latency can refer to the period from a user request to the satisfaction of that request.</li>
<li>At a fine grain, latency can refer to the period from placing a message on a network to the receipt of that message.</li>
</ul>
<p>Latency can also be measured at either the infrastructure or the application level. Measuring latency across different physical computers is more problematic because of the difficulty of synchronizing clocks.</p>
<p>Latency is cumulative in the sense that the latency of responding to a user request is the sum of the latency of all of the activities that occur until the request is satisfied, adjusted for parallelism. It is useful when diagnosing the cause of a latency problem to know the latency of the various subactivities performed in the satisfaction of the original request. [p131]</p>
<h5 id="throughput"><strong>Throughput</strong><a class="headerlink" href="#throughput" title="Permanent link">&para;</a></h5>
<p>Throughput is the number of operations of a particular type in a unit time. Although throughput could refer to infrastructure activities (e.g., the number of disk reads per minute), it is more commonly used at the application level. For example, the number of transactions per second is a common reporting measure.</p>
<p><u>Throughput provides a system-wide measure involving all of the users, whereas latency has a single-user or client focus.</u> High throughput may or may not be related to low latency. The relation will depend on the number of users and their pattern of use.</p>
<p>A reduction in throughput is not, by itself, a problem. The reduction in throughput may be caused by a reduction in the number of users. Problems are indicated through the coupling of throughput and user numbers.</p>
<h5 id="utilization"><strong>Utilization</strong><a class="headerlink" href="#utilization" title="Permanent link">&para;</a></h5>
<p>Utilization is the relative amount of use of a resource and is typically measured by inserting probes on the resources of interest. For example, the CPU utilization may be 80%. High utilization can be used as either of the following:</p>
<ul>
<li>An early warning indicator of problems with latency or throughput,</li>
<li>A diagnostic tool used to find the cause of problems with latency or throughput.</li>
</ul>
<p>The resources can either be at the infrastructure or application level:</p>
<ul>
<li>Hard resources such as CPU, memory, disk, or network are best measured by the infrastructure.</li>
<li>Soft resources such as queues or thread pools can be measured either by the application or the infrastructure depending on where the resource lives.</li>
</ul>
<p>Making sense of utilization frequently requires attributing usage to activities or applications. For example, <em>app1</em> is using 20% of the CPU, disk compression is using 30%, and so on. Thus, connecting the measurements with applications or activities is an important portion of data collection.</p>
<h4 id="capacity-planning">Capacity Planning<a class="headerlink" href="#capacity-planning" title="Permanent link">&para;</a></h4>
<p>There two types of capacity planning:</p>
<ul>
<li><strong>Long-term capacity planning</strong> involves humans and has a time frame on the order of days,</li>
<li><strong>Short-term capacity planning</strong> is performed automatically and has a time frame on the order of minutes.</li>
</ul>
<h5 id="long-term-capacity-planning"><strong>Long-Term Capacity Planning</strong><a class="headerlink" href="#long-term-capacity-planning" title="Permanent link">&para;</a></h5>
<p>Long-term capacity planning is intended to match hardware needs (whether real or virtualized) with workload requirements.</p>
<ul>
<li>In a physical datacenter, it involves ordering hardware.</li>
<li>In a virtualized public datacenter, it involves deciding on the number and characteristics of the virtual resources that are to be allocated.</li>
</ul>
<p>In both cases, the input to the capacity planning process is a characterization of the current workload gathered from monitoring data and a projection of the future workload based on business considerations and the current workload. <u>Based on the future workload, the desired throughput and latency for the future workload, and the costs of various provisioning options, the organization will decide on one option and provide the budget for it.</u></p>
<h5 id="short-term-capacity-planning"><strong>Short-Term Capacity Planning</strong><a class="headerlink" href="#short-term-capacity-planning" title="Permanent link">&para;</a></h5>
<p>In the cloud, short-term capacity planning means creating a new virtual machine (VM) for an application or deleting an existing VM.</p>
<ul>
<li>A common method of making and executing these decisions (creating and deleting VMs) is based on monitoring information collected by the infrastructure.<ul>
<li><a href="../ch4/">Chapter 4</a> discusses various options for controlling the allocation of VM instances based on the current load.</li>
<li>Monitoring the usage of the current VM instances was an important portion of each option.</li>
</ul>
</li>
<li>Monitoring data is also used for billing in public clouds. In order to charge for use, the use must be determined, and this is accomplished through monitoring by the cloud provider.</li>
</ul>
<h4 id="user-interaction">User Interaction<a class="headerlink" href="#user-interaction" title="Permanent link">&para;</a></h4>
<p>User satisfaction is an important element of a business. It depends on four elements that can be monitored:</p>
<ol>
<li><strong>The latency of a user request.</strong> Users expect decent response times. Depending on the application, seemingly trivial variations in response can have a large impact.</li>
<li><strong>The reliability of the system with which the user is interacting.</strong> Failure and failure detection are discussed earlier.</li>
<li><strong>The effect of a particular business offering or user interface modification.</strong> A/B testing is discussed in <a href="../ch5/">Chapters 5</a> and <a href="../ch6/">Chapter 6</a>. The measurements collected from A/B testing must be meaningful for the goal of the test, and the data must be associated with variant A or B of the system.</li>
<li><strong>The organization’s particular set of metrics.</strong> These metrics should be important indicators either of the following:<ul>
<li>User satisfaction,</li>
<li>The effectiveness of the organization’s computer-based services.</li>
</ul>
</li>
</ol>
<p>There are generally two types of user interaction monitoring.</p>
<ol>
<li><strong>Real user monitoring</strong> (RUM). RUM essentially records all user interactions with an application.<ul>
<li>RUM data is used to assess the real service level a user experiences and whether server side changes are being propagated to users correctly.</li>
<li>RUM is usually passive in terms of not affecting the application payload without exerting load or changing the server-side application.</li>
</ul>
</li>
<li><strong>Synthetic monitoring</strong>. It is similar to developers performing stress testing on an application.<ul>
<li>Expected user behaviors are scripted either using some emulation system or using actual client software (such as a browser). However, the goal is often not to stress test with heavy loads, but to monitor the user experience.</li>
<li>Synthetic monitoring allows you to monitor user experience in a systematic and repeatable fashion, not dependent on how users are using the system right now.</li>
<li>Synthetic monitoring may be a portion of the automated user acceptance tests discussed in <a href="../ch5/">Chapter 5</a>.</li>
</ul>
</li>
</ol>
<h4 id="intrusion-detection">Intrusion Detection<a class="headerlink" href="#intrusion-detection" title="Permanent link">&para;</a></h4>
<p>Intruders can break into a system by subverting an application (for example, through incorrect authorization or a man-in-the-middle attack). Applications can monitor users and their activities to determine whether the activities are consistent with the users’ role in the organization or their past behavior.</p>
<p>For instance, if user John has a mobile phone using the application, and the phone is currently in Australia, any log-in attempts from, say, Nigeria should be seen as suspicious.</p>
<h5 id="intrusion-detector"><strong>Intrusion detector</strong> *<a class="headerlink" href="#intrusion-detector" title="Permanent link">&para;</a></h5>
<p>An <strong>intrusion detector</strong> is a software application that monitors network traffic by looking for abnormalities. These abnormalities can be caused by:</p>
<ul>
<li>Attempts to compromise a system by unauthorized users,</li>
<li>Violations of an organization’s security policies.</li>
</ul>
<p>Intrusion detectors use a variety of different techniques to identify attacks. They frequently use historical data from an organization’s network to understand what is normal. They also use libraries that contain the network traffic patterns observed during various attacks. Current traffic on a network is compared to the expected (from an organization’s history) and the abnormal (from the attack history) to decide whether an attack is currently under way.</p>
<p>Intrusion detectors can also monitor traffic to determine whether an organization’s security policies are being violated without malicious intent.</p>
<p>Intrusion detectors generate alerts and alarms as discussed in <a href="#interpreting-monitoring-data">Section 7.5</a>. Problems with false positives and false negatives exist with intrusion detectors as they do with all monitoring systems.</p>
<h3 id="how-to-monitor">How to Monitor<a class="headerlink" href="#how-to-monitor" title="Permanent link">&para;</a></h3>
<p>Monitoring systems interact with the elements being monitored, as shown in the figure below.</p>
<p><a href="../figure_7.1.png" title="Figure 7.1 Monitoring system interacting with the elements being monitored [Notation: Architecture]"><img alt="Figure 7.1 Monitoring system interacting with the elements being monitored [Notation: Architecture]" src="../figure_7.1.png" /></a></p>
<p>The system to be monitored can be as broad as a collection of independent applications or services, or as narrow as a single application:</p>
<ol>
<li><strong>Agentless monitoring</strong>. If the system is actively contributing to the data being monitored (the arrow labeled "agentless") then the monitoring is intrusive and affects the system design.</li>
<li><strong>Agent-based monitoring</strong>. If the system is not actively contributing to the data being monitored (the arrow labeled "agent-based") then the monitoring is nonintrusive and does not affect the system design.</li>
<li><strong>Health checks</strong>. A third source of data is indicted by the arrow labeled "health checks". External systems can also monitor system or application-level states through health checks, performance-related requests, or transaction monitoring</li>
</ol>
<p>The data collected either through agents or through agentless means is eventually sent to a central repository ("Monitoring data storage" in <a href="../figure_7.1.png">Figure 7.1</a>). The central repository is typically distributed (logically but not physically central). Each step from the initial collection to the central repository can do filtering and aggregation.</p>
<p>The considerations in determining the amount of filtering and aggregation are:</p>
<ul>
<li>The volume of data being generated,</li>
<li>The potential failure of local nodes,</li>
<li>The granularity of the necessary communication.</li>
</ul>
<p>Retrieving the data from local nodes is important because the local node may fail and the data become unavailable. Sending all of the data directly to a central repository may introduce congestion to the network. Thus, selecting the intermediate steps from the local nodes to the central repository and the filtering and aggregation done at each step are important architectural decisions when setting up a monitoring framework.</p>
<p>Once monitoring data is collected, you can do many things:</p>
<ul>
<li>Alarms can be configured to trigger alerts that notify operators or other systems about major state changes.</li>
<li>Graphing and dashboards can be used to visualize system state changes for human operators.</li>
<li>A monitoring system also allows operators to drill down into detailed monitoring data and logs, which is important for error diagnosis, root cause analysis, and deciding on the best reaction to a problem.</li>
</ul>
<p>The traditional view of the monitoring system (as discussed so far) is increasingly being challenged by new interactions between the monitoring system and other systems, which are shown outside of the dotted areas in <a href="../figure_7.1.png">Figure 7.1</a>.</p>
<p>You can perform stream processing and (big) data analytics on monitoring data streams and historical data. Not only can you gain insights into system characteristics using system-level monitoring data, you may also gain insights into user behaviors and intentions using application- and user-level monitoring data.</p>
<p>Because of these growing different uses of monitoring data, many companies are starting to use a unified log and metrics-centric publish-subscribe architecture for both the monitoring system and the overall application system. More and more types of data, including nontraditional log and metrics data, are being put into a unified storage, where various other systems (whether monitoring-related or not) can subscribe to the data of interest. Several implications of the unified view are:</p>
<ul>
<li>It significantly reduces the coupling of any two systems. <u>Systems interact with the unified log in a publish-subscribe fashion that makes publishers ignorant of the specific identity of the subscriber and vice versa.</u></li>
<li>It simplifies the integration of multiple sources of data. <u>Using a central log store allows data to be correlated based on attributes such as time stamps rather than their source.</u> [p136]</li>
</ul>
<p>The line between the monitoring system and the system to be monitored is getting blurred when application and user monitoring data are treated the same as system-level monitoring data: data from anywhere and at any level could contribute to insights about both systems and users.</p>
<p>The following sections discuss the method of retrieving monitoring data, monitoring operations, and data collection and storage:</p>
<h4 id="agent-based-and-agentless-monitoring">Agent-Based and Agentless Monitoring<a class="headerlink" href="#agent-based-and-agentless-monitoring" title="Permanent link">&para;</a></h4>
<p>In some situations, the system to be monitored already has internal monitoring facilities that can be accessed through a defined protocol. For example:</p>
<ul>
<li>The <a href="https://en.wikipedia.org/wiki/Simple_Network_Management_Protocol">Simple Network Management Protocol</a> (SNMP) is a common mechanism for gathering metrics from servers and network equipment. It is especially useful on network equipment because that equipment often comes as a closed system and you cannot install monitoring agents.</li>
<li>You can use protocols like Secure Shell (SSH) to remotely access a system and retrieve available data.</li>
<li><a href="https://en.wikipedia.org/wiki/Application_Response_Measurement">Application Response Measurement</a> (ARM) is an industry standard that provides ways for an application to trigger actions such as requesting an external ARMsupported system to start or stop tracking a transaction and correlating times spent in different systems for a single transaction.</li>
</ul>
<p>Agentless monitoring is particularly useful when you cannot install agents, and it can simplify the deployment of your monitoring system.</p>
<p>The agent-based and agentless approaches both have their strengths and weaknesses:</p>
<ul>
<li><strong>Agentless</strong>. <u>The <strong>agentless</strong> approach is better in terms of deployment and maintenance effort.</u> However, it is less secure if the collection repository is outside of your network because more ports need to be opened and firewall rules relaxed to allow different layers of a system to communicate its data to the external world.</li>
<li><strong>Agent-based</strong>. In contrast, an <strong>agent</strong> on a host can communicate with the OS and applications locally and send all collected information over a single channel. <u>This also allows an agent-based approach to optimize network traffic and processing overhead.</u></li>
<li><strong>External</strong>. In addition to collecting monitoring data from inside a system, you can collect information from an external viewpoint. You can set up <strong>health checks</strong> to periodically check a system or conduct performance monitoring from an external user’s point of view</li>
</ul>
<p>Questions to be considered when designing a system include:</p>
<ul>
<li>Where does this information come from?</li>
<li>How does this information fit into the application and monitoring architecture?</li>
<li>What are the quality implications?</li>
</ul>
<h4 id="monitoring-operation-activities">Monitoring Operation Activities<a class="headerlink" href="#monitoring-operation-activities" title="Permanent link">&para;</a></h4>
<p>Some operations tools (such as Chef) monitor resources such as configuration settings to determine whether they conform to prespecified settings. We also mentioned monitoring resource specification files to identify changes. Both of these types of monitoring are best done by agents that periodically sample the actual values and the files that specify those values.</p>
<p>Treating infrastructure-as-code implies that infrastructure should contribute monitoring information in the same fashion as other applications, which can be through any of the means discussed: agents, agentless, or external.</p>
<p><a href="../ch14/">Chapter 14</a> discusses how to perform fine-grained monitoring of the behavior of operations tools and scripts. This can include assertions over monitoring data. <u>For instance, during a rolling upgrade a number of VMs are taken out of service to be replaced with VMs running a newer version of the application. Then you can expect the average CPU utilization of the remaining machines to increase by a certain factor.</u></p>
<h4 id="collection-and-storage">Collection and Storage<a class="headerlink" href="#collection-and-storage" title="Permanent link">&para;</a></h4>
<p>The core of monitoring is recoding and analyzing time series data (a sequence of time-stamped data points):</p>
<ul>
<li>These data points are acquired at successive intervals in time and represent certain aspects of states and state changes.</li>
<li>The system being monitored will generate time-stamped event notifications at various levels of severity. These notifications are typically output as logs.</li>
</ul>
<p>The monitoring system can conduct direct measurement or collect existing data, statistics, or logs and then turn them into metrics (with time and space). The data is then transferred to a repository. The incoming data streams need to be processed into a time series and stored in a time series database.</p>
<p>Three key challenges are: [p138]</p>
<ul>
<li><strong>Collating related items by time.</strong> Time stamps in a distributed system are not going to be consistent.<ul>
<li>Different nodes in a single cluster may differ in their clocks by several microseconds.</li>
<li>Different nodes across multiple clusters may differ by much more.</li>
</ul>
</li>
<li><strong>Collating related items by context.</strong></li>
<li><strong>The volume of monitoring data.</strong> You may need a retention policy to cope with the volume of data collected.</li>
</ul>
<p>The <a href="https://en.wikipedia.org/wiki/RRDtool">Round-Robin Database</a> (RRD) is a popular time series database, which is designed for storing and displaying time series data with good retention policy configuration capabilities. Big data storage and processing solutions are increasingly used for monitoring data. You can treat your monitoring data as data streams feeding into streaming systems for real-time processing, combined with (big) historical data. You can load all your data into big data storage systems such as Hadoop Distributed File System (HDFS) or archive it in relatively inexpensive online storage systems such as <a href="https://aws.amazon.com/glacier/">Amazon Glacier</a>.</p>
<h3 id="when-to-change-the-monitoring-configuration">When to Change the Monitoring Configuration<a class="headerlink" href="#when-to-change-the-monitoring-configuration" title="Permanent link">&para;</a></h3>
<p>Monitoring is either time-based or event-based. Timing frequency and generation of events should all be configurable and changed in response to events occurring in the datacenter.</p>
<p>Some examples of events that could change the monitoring configuration are:</p>
<ul>
<li><strong>An alert.</strong> One consequence of an alert could be that the frequency of sampling is increased.  The frequency could be decreased if the alert does not turn into an alarm.</li>
<li><strong>Deployment.</strong> Any of the deployment scenarios can trigger changes to monitoring:<ul>
<li>Canary deployment. The new versions under test should be monitored more closely</li>
<li>Rolling upgrade. Closer monitoring will help detect the occurrence of a race condition more quickly.</li>
<li>Feature activation or deactivation. Feature changes should trigger changes in the monitoring configuration.</li>
</ul>
</li>
<li><strong>Changes to any infrastructure software including DevOps tools.</strong></li>
<li><strong>Changes to any configuration parameters.</strong> One of the major sources of errors in modern distributed systems is incorrect parameters.</li>
</ul>
<h3 id="interpreting-monitoring-data">Interpreting Monitoring Data<a class="headerlink" href="#interpreting-monitoring-data" title="Permanent link">&para;</a></h3>
<p>Assume that the monitoring data (both time-based and event-based) has been collected in a central repository. This data is being added and examined continually, by both other systems and humans.</p>
<h4 id="logs">Logs<a class="headerlink" href="#logs" title="Permanent link">&para;</a></h4>
<p>A log is a time series of events. Records are typically appended to the end of the log. Logs usually record the actions performed that may result in a state change of the system.</p>
<p>[p140]</p>
<p>Logs are used:</p>
<ul>
<li>During operations to detect and diagnose problems.</li>
<li>During debugging to detect errors.</li>
<li>During post-problem forensics to understand the sequence that led to a particular problem.</li>
</ul>
<p>Some general rules about writing logs are:</p>
<ul>
<li>Logs should have a consistent format.</li>
<li>Logs should include an explanation for why this particular log message was produced.</li>
<li>Log entries should include context information. Besides date and time, it also includes information to support tracking the log entry such as:<ul>
<li>Source of the log entry within the code</li>
<li>Process ID for the process executing when the log entry was produced</li>
<li>Request ID for the request that caused that process to execute this log producer</li>
<li>VM ID for the VM that produced this message</li>
</ul>
</li>
<li>Logs should provide screening information. Log messages are collected in a repository that is accessed through queries. Severity levels are an example of screening information, alert levels are another.</li>
</ul>
<h4 id="graphing-and-display">Graphing and Display<a class="headerlink" href="#graphing-and-display" title="Permanent link">&para;</a></h4>
<p>Once you have all relevant data, it is useful to visualize it:</p>
<ul>
<li>Some monitoring systems have strong visualization capabilities embedded.</li>
<li>There are also specialized systems just for visualization and querying, such as <a href="https://github.com/graphite-project/graphite-web">Graphite</a>, which support real-time graphing of large amounts of data.</li>
</ul>
<p>You can set up a dashboard showing important real-time aspects of your system and its components at an aggregated level. You can also dive into the details interactively or navigate through history when you detect an issue. An experienced operator will use visual patterns of graphs to discern problems.</p>
<p>[p141]</p>
<h4 id="alarms-and-alerts">Alarms and Alerts<a class="headerlink" href="#alarms-and-alerts" title="Permanent link">&para;</a></h4>
<p>Monitoring systems inform the operator of significant events. This information can be in the form of either an alarm or an alert:</p>
<ul>
<li><strong>Alerts</strong> are raised for purposes of informing and may be in advance of an alarm (e.g., the datacenter temperature is rising);</li>
<li><strong>Alarms</strong> require action by the operator or another system (e.g., the datacenter is on fire).</li>
</ul>
<p>Alarms and alerts can be triggered by any of the following:</p>
<ul>
<li>Events (e.g., a particular physical machine is not responding),</li>
<li>Values crossing a threshold (e.g., the response time for a particular disk is greater than an acceptable value),</li>
<li>Sophisticated combinations of values and trends.</li>
</ul>
<p>[p141]</p>
<p>The typical issues are:</p>
<ul>
<li>How do you configure your monitoring system to reduce <strong>false positives</strong> (alarms without the necessity for action) and <strong>false negatives</strong> (the necessity for action without an alarm being raised)?</li>
<li>How do you configure your monitoring system so that the alerts provide necessary information to diagnose an alarm?</li>
</ul>
<p>A problem for operators is receiving false positive alarms or a flood of alerts from different channels about the same event. Under such conditions, operators will quickly get "alert fatigue" and start ignoring alerts or simply turn some of them off. On the other hand, if you try to reduce false positives, you may risk missing important events, which increases false negatives.</p>
<p>If your alarms are very specific in their triggering conditions, you may be informed about some subtle errors early in their occurrence. However, you may risk rendering your alarms less effective when the system undergoes changes over time, or when the system momentarily exhibits interference of legitimate but previously unknown operations. [p142]</p>
<p>Some general rules to improve the usefulness of alerts and alarms are:</p>
<ul>
<li>Introduce context to your alarms.<ul>
<li>This could be as simple as disabling certain alerts during specific times or actions; for example, when replacing a physical computer it does not make sense to raise alarms about the computer’s health.</li>
<li>Other more complex contexts could be related to external events or interfering operations.</li>
</ul>
</li>
<li><u>Alarms can not only go off if something happens, they can also be set to go off if an expected event did not happen</u>. This helps with drills and testing of your alarms since you can set an alarm to go off when an event that you know is not going to happen does not, in fact, happen.</li>
<li>Aggregate different alerts that are likely referring to the same events.</li>
<li>Set clear severity levels and urgency levels so people or systems receiving the alerts can act accordingly.</li>
</ul>
<h4 id="diagnosis-and-reaction">Diagnosis and Reaction<a class="headerlink" href="#diagnosis-and-reaction" title="Permanent link">&para;</a></h4>
<p>Operators often use monitoring systems to diagnose the causes and observe the progress of mitigation and recovery. However, monitoring systems are not designed for interactive or automated diagnosis. Thus, operators, in ad hoc ways, will try to correlate events, dive into details and execute queries, and examine logs. Concurrently, they manually trigger more diagnostic tests and recovery actions (such as restarting processes or isolating problematic components) and observe their effects from the monitoring system.</p>
<p>The essence of the skill of a reliability engineer is the ability to diagnose a problem in the presence of uncertainty. Once the problem has been diagnosed, frequently the reaction is clear although, at times, possible reactions have different business consequences. [p142-143]</p>
<h4 id="monitoring-devops-processes">Monitoring DevOps Processes<a class="headerlink" href="#monitoring-devops-processes" title="Permanent link">&para;</a></h4>
<p>DevOps processes should be monitored so that they can be improved and problems can be detected.</p>
<p>Five things that are important to monitor:</p>
<ol>
<li>A business metric</li>
<li>Cycle time</li>
<li>Mean time to detect errors</li>
<li>Mean time to report errors</li>
<li>Amount of scrap (rework)</li>
</ol>
<h3 id="challenges">Challenges<a class="headerlink" href="#challenges" title="Permanent link">&para;</a></h3>
<h4 id="challenge-1-monitoring-under-continuous-changes">Challenge 1: Monitoring Under Continuous Changes<a class="headerlink" href="#challenge-1-monitoring-under-continuous-changes" title="Permanent link">&para;</a></h4>
<h5 id="deviation-from-normal-behavior"><strong>Deviation from normal behavior</strong> *<a class="headerlink" href="#deviation-from-normal-behavior" title="Permanent link">&para;</a></h5>
<p>In operation, a deviation from normal behavior is a problem. Normal behavior assumes the system is relatively stable over time. However, in a large-scale complex environment, changes are the norm. Besides varying workloads or dynamic aspects of your application, which are often well anticipated, the new challenges come from both of:</p>
<ul>
<li>Cloud elasticity makes infrastructure resources more volatile.</li>
<li>Automated DevOps operations trigger various sporadic operations (such as upgrade, reconfiguration, or backups).<ul>
<li>Sporadic operations and continuous deployment and deployment practices make software changes more frequent.</li>
</ul>
</li>
</ul>
<p>Deploying a new version into production multiple times a day is becoming a common practice:</p>
<ul>
<li>Each deployment is a change to the system and may impact monitoring.</li>
<li>These changes may be happening simultaneously in different portions of an application or the infrastructure.</li>
</ul>
<h5 id="how-to-use-the-past-monitoring-data-to-do-performance-management-capacity-planning-anomaly-detection-and-error-diagnosis-for-the-new-system"><strong>How to use the past monitoring data to do performance management, capacity planning, anomaly detection, and error diagnosis for the new system?</strong> *<a class="headerlink" href="#how-to-use-the-past-monitoring-data-to-do-performance-management-capacity-planning-anomaly-detection-and-error-diagnosis-for-the-new-system" title="Permanent link">&para;</a></h5>
<p>In practice, operators may turn off monitoring during scheduled maintenance and upgrades as a work-around to reduce false positive alerts triggered by those changes. However, this can lead to no monitoring (e.g. flying blind).</p>
<p>The following techniques can solve this:</p>
<ol>
<li>Carefully identify the non-changing portions of the data.<ul>
<li>For example, use dimensionless data (i.e., ratios). You may find that although individual variables change frequently, the ratio of two variables is relatively constant.</li>
</ul>
</li>
<li>Focus monitoring on things that have changed.</li>
<li>Compare performance of the canaries with historical performance. (As discussed in <a href="../ch6/">Chapter 6</a>, canary testing is a way of monitoring a small rollout of a new system for issues in production.) Changes that cannot be rationalized because of feature changes may indicate problems.</li>
</ol>
<h5 id="specification-of-monitoring-parameters"><strong>Specification of monitoring parameters</strong> *<a class="headerlink" href="#specification-of-monitoring-parameters" title="Permanent link">&para;</a></h5>
<p>The specification of monitoring parameters is another challenge related to monitoring under continuous changes [p144].</p>
<p>The complexity of setting up and maintaining a monitoring system consists of:</p>
<ul>
<li>Specifying what needs to be monitored</li>
<li>Setting thresholds</li>
<li>Defining the alerting logic</li>
</ul>
<p>Continuous changes in the system infrastructure and the system itself complicate the setting of monitoring parameters. Your monitoring may need to be adjusted for  variance on the infrastructure side. [p144]</p>
<p>As a consequence, it makes sense to automate the configuration of alarms, alerts, and thresholds as much as possible. The monitoring configuration process is just another DevOps process to be automated:</p>
<ul>
<li>When you provision a new server, registering this server in the monitoring system automatically.</li>
<li>When a server is terminated, a de-registration process should happen automatically.</li>
</ul>
<h4 id="challenge-2-bottom-up-vs-top-down-and-monitoring-in-the-cloud">Challenge 2: Bottom-Up vs. Top-Down and Monitoring in the Cloud<a class="headerlink" href="#challenge-2-bottom-up-vs-top-down-and-monitoring-in-the-cloud" title="Permanent link">&para;</a></h4>
<h4 id="challenge-3-monitoring-a-microservice-architecture">Challenge 3: Monitoring a Microservice Architecture<a class="headerlink" href="#challenge-3-monitoring-a-microservice-architecture" title="Permanent link">&para;</a></h4>
<h4 id="challenge-4-dealing-with-large-volumes-of-distributed-log-data">Challenge 4: Dealing with Large Volumes of Distributed (Log) Data<a class="headerlink" href="#challenge-4-dealing-with-large-volumes-of-distributed-log-data" title="Permanent link">&para;</a></h4>
<h3 id="tools">Tools<a class="headerlink" href="#tools" title="Permanent link">&para;</a></h3>
            </div>
        </div>

        <footer class="col-md-12">
            
        </footer>

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script>
        <script src="../../js/base.js"></script>
        <script src="../../custom.js"></script>
    </body>
</html>