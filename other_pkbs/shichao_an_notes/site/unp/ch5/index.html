<!DOCTYPE html>
<html lang="en">
    <head>
        <!-- Global Site Tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-59055167-2"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments)};
          gtag('js', new Date());

          gtag('config', 'UA-59055167-2');
        </script>

        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://notes.shichao.io/unp/ch5/">
        <link rel="shortcut icon" href="../../toki_32.png">
        

	<title>Chapter 5. TCP Client/Server Example - Shichao's Notes</title>

        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../../css/base.css" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,400italic,500,600" rel="stylesheet">
        <link href="../../custom.css" rel="stylesheet">
        <link href="../../friendly.css" rel="stylesheet">
        <link href="../../theme.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        
<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../..">Shichao's Notes</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">APUE <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../apue/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch1/">Chapter 1. UNIX System Overview</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch2/">Chapter 2. UNIX Standardization and Implementations</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch3/">Chapter 3. File I/O</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch4/">Chapter 4. Files and Directories</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch5/">Chapter 5. Standard I/O Library</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch6/">Chapter 6. System Data Files and Information</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch7/">Chapter 7. Process Environment</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch8/">Chapter 8. Process Control</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch9/">Chapter 9. Process Relationships</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch10/">Chapter 10. Signals</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch11/">Chapter 11. Threads</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch12/">Chapter 12. Thread Control</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch13/">Chapter 13. Daemon Processes</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch14/">Chapter 14. Advanced I/O</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch15/">Chapter 15. Interprocess Communication</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch16/">Chapter 16. Network IPC: Sockets</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch17/">Chapter 17. Advanced IPC</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UNP <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../ch2/">Chapter 2. The Transport Layer: TCP, UDP, and SCTP</a>
                        </li>
                      
                        <li>
                            <a href="../ch3/">Chapter 3. Sockets Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../ch4/">Chapter 4. Elementary TCP Sockets</a>
                        </li>
                      
                        <li class="active">
                            <a href="./">Chapter 5. TCP Client/Server Example</a>
                        </li>
                      
                        <li>
                            <a href="../ch6/">Chapter 6. I/O Multiplexing: The select and poll Functions</a>
                        </li>
                      
                        <li>
                            <a href="../ch7/">Chapter 7. Socket Options</a>
                        </li>
                      
                        <li>
                            <a href="../ch8/">Chapter 8. Elementary UDP Sockets</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">TCPv1 <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../tcpv1/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch2/">Chapter 2. The Internet Address Architecture</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch3/">Chapter 3. Link Layer</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch4/">Chapter 4. ARP: Address Resolution Protocol</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch5/">Chapter 5. The Internet Protocol (IP)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch6/">Chapter 6. System Configuration: DHCP and Autoconfiguration</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch7/">Chapter 7. Firewalls and Network Address Translation (NAT)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch8/">Chapter 8. ICMPv4 and ICMPv6: Internet Control Message Protocol</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch9/">Chapter 9. Broadcasting and Local Multicasting (IGMP and MLD)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch10/">Chapter 10. User Datagram Protocol (UDP) and IP Fragmentation</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch11/">Chapter 11. Name Resolution and the Domain Name System (DNS)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch12/">Chapter 12. TCP: The Transmission Control Protocol (Preliminaries)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch13/">Chapter 13. TCP Connection Management</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch14/">Chapter 14. TCP Timeout and Retransmission</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch15/">Chapter 15. TCP Data Flow and Window Management</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch16/">Chapter 16. TCP Congestion Control</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch17/">Chapter 17. TCP Keepalive</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch18/">Chapter 18. Security: EAP, IPsec, TLS, DNSSEC, and DKIM</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/headers/">Headers</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">GOPL <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../gopl/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch1/">Chapter 1. Tutorial</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch2/">Chapter 2. Program Structure</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch3/">Chapter 3. Basic Data Types</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch4/">Chapter 4. Composite Types</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch5/">Chapter 5. Functions</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch6/">Chapter 6. Methods</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch7/">Chapter 7. Interfaces</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch8/">Chapter 8. Goroutines and Channels</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch9/">Chapter 9. Concurrency with Shared Variables</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch10/">Chapter 10. Packages and the Go Tool</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch11/">Chapter 11. Testing</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch12/">Chapter 12. Reflection</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">CSN <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../csn/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../csn/part1/">Part 1: Language</a>
                        </li>
                      
                        <li>
                            <a href="../../csn/part2/">Part 2: Advanced</a>
                        </li>
                      
                    </ul>
                </li>
            <li>
                    <a href="../../toc/">TOC</a>
                </li>
            </ul>
            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    
                        <a href="https://github.com/shichao-an/notes/blob/master/docs/unp/ch5.md">
                    
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#chapter-5-tcp-clientserver-example">Chapter 5. TCP Client/Server Example</a></li>
        
    
        <li class="main "><a href="#introduction">Introduction</a></li>
        
    
        <li class="main "><a href="#tcp-echo-server-main-function">TCP Echo Server: main Function</a></li>
        
    
        <li class="main "><a href="#tcp-echo-server-str_echo-function">TCP Echo Server: str_echo Function</a></li>
        
    
        <li class="main "><a href="#tcp-echo-client-main-function">TCP Echo Client: main Function</a></li>
        
    
        <li class="main "><a href="#tcp-echo-client-str_cli-function">TCP Echo Client: str_cli Function</a></li>
        
    
        <li class="main "><a href="#normal-startup">Normal Startup</a></li>
        
            <li><a href="#start-the-server-in-the-background">Start the server in the background</a></li>
        
            <li><a href="#run-netstat">Run netstat</a></li>
        
            <li><a href="#start-the-client-on-the-same-host">Start the client on the same host</a></li>
        
            <li><a href="#run-netstat-after-connection-completes">Run netstat after connection completes</a></li>
        
            <li><a href="#run-ps-to-check-process-status-and-relationship">Run ps to check process status and relationship</a></li>
        
    
        <li class="main "><a href="#normal-termination">Normal Termination</a></li>
        
    
        <li class="main "><a href="#posix-signal-handling">POSIX Signal Handling</a></li>
        
    
        <li class="main "><a href="#signal-function">signal Function</a></li>
        
            <li><a href="#simplify-function-prototype-using-typedef">Simplify function prototype using typedef</a></li>
        
            <li><a href="#set-handler">Set handler</a></li>
        
            <li><a href="#set-signal-mask-for-handler">Set signal mask for handler</a></li>
        
            <li><a href="#set-sa_restart-flag">Set SA_RESTART flag</a></li>
        
            <li><a href="#call-sigaction">Call sigaction</a></li>
        
    
        <li class="main "><a href="#handling-sigchld-signals">Handling SIGCHLD Signals</a></li>
        
            <li><a href="#handling-zombies">Handling Zombies</a></li>
        
            <li><a href="#handling-interrupted-system-calls">Handling Interrupted System Calls</a></li>
        
    
        <li class="main "><a href="#wait-and-waitpid-functions">wait and waitpid Functions</a></li>
        
            <li><a href="#difference-between-wait-and-waitpid">Difference between wait and waitpid</a></li>
        
    
        <li class="main "><a href="#connection-abort-before-accept-returns">Connection Abort before accept Returns</a></li>
        
    
        <li class="main "><a href="#termination-of-server-process">Termination of Server Process</a></li>
        
    
        <li class="main "><a href="#sigpipe-signal">SIGPIPE Signal</a></li>
        
    
        <li class="main "><a href="#crashing-of-server-host">Crashing of Server Host</a></li>
        
    
        <li class="main "><a href="#crashing-and-rebooting-of-server-host">Crashing and Rebooting of Server Host</a></li>
        
    
        <li class="main "><a href="#shutdown-of-server-host">Shutdown of Server Host</a></li>
        
    
        <li class="main "><a href="#summary-of-tcp-example">Summary of TCP Example</a></li>
        
            <li><a href="#clients-perspective">Client's perspective</a></li>
        
            <li><a href="#servers-perspective">Server's perspective</a></li>
        
    
        <li class="main "><a href="#data-format">Data Format</a></li>
        
            <li><a href="#example-passing-text-strings-between-client-and-server">Example: Passing Text Strings between Client and Server</a></li>
        
            <li><a href="#example-passing-binary-structures-between-client-and-server">Example: Passing Binary Structures between Client and Server</a></li>
        
    
        <li class="main "><a href="#summary">Summary</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">
              

<h3 id="chapter-5-tcp-clientserver-example"><strong>Chapter 5. TCP Client/Server Example</strong><a class="headerlink" href="#chapter-5-tcp-clientserver-example" title="Permanent link">&para;</a></h3>
<h3 id="introduction">Introduction<a class="headerlink" href="#introduction" title="Permanent link">&para;</a></h3>
<p>We will now use the elementary functions from the previous chapter to write a complete TCP client/server example. Our simple example is an echo server that performs the following steps:</p>
<ol>
<li>The client reads a line of text from its standard input and writes the line to the server.</li>
<li>The server reads the line from its network input and echoes the line back to the client.</li>
<li>The client reads the echoed line and prints it on its standard output.</li>
</ol>
<p>The figure below depcits this simple client/server:</p>
<p><a href="../figure_5.1.png" title="Figure 5.1. Simple echo client and server."><img alt="Figure 5.1. Simple echo client and server." src="../figure_5.1.png" /></a></p>
<p>Despite two arrows between the client and server in the above figure, it is really a <a href="../ch2/#transmission-control-protocol-tcp">full-duplex</a> TCP connection. <code>fgets</code> and <code>fputs</code> functions are from the standard I/O library. <code>writen</code> and <code>readline</code> functions were shown in <a href="../ch3/#readn-writen-and-readline-functions">Section 3.9</a>.</p>
<p>The echo client/server is a valid, simple example of a network application. To expand this example into your own application, all you need to do is change what the server does with the input it receives from its clients.</p>
<p>Besides running the client/server in normal mode (type in a line and watch it echo), we examine lots of boundary conditions:</p>
<ul>
<li>What happens when the client and server are started?</li>
<li>What happens when the client terminates normally?</li>
<li>What happens to the client if the server process terminates before the client is done?</li>
<li>What happens to the client if the server host crashes?</li>
</ul>
<p>In all these examples, we have "hard-coded" protocol-specific constants such as addresses and ports. There are two reasons for this:</p>
<ul>
<li>We must understand exactly what needs to be stored in the protocol-specific address structures</li>
<li>We have not yet covered the library functions that can make this more portable</li>
</ul>
<h3 id="tcp-echo-server-main-function">TCP Echo Server: <code>main</code> Function<a class="headerlink" href="#tcp-echo-server-main-function" title="Permanent link">&para;</a></h3>
<p>Our TCP client and server follow the flow of functions that we diagrammed in <a href="../figure_4.1.png">Figure 4.1</a>. The below code is the concurrent server program:</p>
<p><small><a href="https://github.com/shichao-an/unpv13e/blob/master/tcpcliserv/tcpserv01.c">tcpcliserv/tcpserv01.c</a></small></p>
<div class="codehilite"><pre><span class="cp">#include</span>    <span class="cpf">&quot;unp.h&quot;</span><span class="cp"></span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span>                 <span class="n">listenfd</span><span class="p">,</span> <span class="n">connfd</span><span class="p">;</span>
    <span class="kt">pid_t</span>               <span class="n">childpid</span><span class="p">;</span>
    <span class="kt">socklen_t</span>           <span class="n">clilen</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">sockaddr_in</span>  <span class="n">cliaddr</span><span class="p">,</span> <span class="n">servaddr</span><span class="p">;</span>

    <span class="n">listenfd</span> <span class="o">=</span> <span class="n">Socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">bzero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">servaddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">servaddr</span><span class="p">));</span>
    <span class="n">servaddr</span><span class="p">.</span><span class="n">sin_family</span>      <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
    <span class="n">servaddr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">);</span>
    <span class="n">servaddr</span><span class="p">.</span><span class="n">sin_port</span>        <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">SERV_PORT</span><span class="p">);</span>

    <span class="n">Bind</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="p">(</span><span class="n">SA</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">servaddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">servaddr</span><span class="p">));</span>

    <span class="n">Listen</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="n">LISTENQ</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">clilen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cliaddr</span><span class="p">);</span>
        <span class="n">connfd</span> <span class="o">=</span> <span class="n">Accept</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="p">(</span><span class="n">SA</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">cliaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clilen</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">childpid</span> <span class="o">=</span> <span class="n">Fork</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>    <span class="cm">/* child process */</span>
            <span class="n">Close</span><span class="p">(</span><span class="n">listenfd</span><span class="p">);</span>    <span class="cm">/* close listening socket */</span>
            <span class="n">str_echo</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>   <span class="cm">/* process the request */</span>
            <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">Close</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>          <span class="cm">/* parent closes connected socket */</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>The above code does the following:</p>
<ul>
<li><strong>Create socket, bind server's well-known port</strong><ul>
<li>A TCP socket is created.</li>
<li>An Internet socket address structure is filled in with the wildcard address (<code>INADDR_ANY</code>) and the server's well-known port (<code>SERV_PORT</code>, which is defined as 9877 in our <a href="https://github.com/shichao-an/unpv13e/blob/master/lib/unp.h#L200">unp.h</a> header). Binding the wildcard address tells the system that we will accept a connection destined for any local interface, in case the system is multihomed. Our choice of the TCP port number is based on <a href="../figure_2.10.png">Figure 2.10</a> in <a href="../ch2/#port-numbers">Section 2.9</a>. It should be greater than 1023 (we do not need a reserved port), greater than 5000 (to avoid conflict with the ephemeral ports allocated by many Berkeley-derived implementations), less than 49152 (to avoid conflict with the "correct" range of ephemeral ports), and it should not conflict with any registered port.  [p122]</li>
<li>The socket is converted into a listening socket by <code>listen</code>.</li>
</ul>
</li>
<li><strong>Wait for client connection to complete</strong><ul>
<li>The server blocks in the call to <code>accept</code>, waiting for a client connection to complete.</li>
</ul>
</li>
<li><strong>Concurrent server</strong><ul>
<li>For each client, <code>fork</code> spawns a child, and the child handles the new client. The child closes the listening socket and the parent closes the connected socket. (<a href="../ch4/#concurrent-servers">Section 4.8</a>)</li>
</ul>
</li>
</ul>
<h3 id="tcp-echo-server-str_echo-function">TCP Echo Server: <code>str_echo</code> Function<a class="headerlink" href="#tcp-echo-server-str_echo-function" title="Permanent link">&para;</a></h3>
<p>The function <code>str_echo</code> performs the server processing for each client: It reads data from the client and echoes it back to the client.</p>
<p><small><a href="https://github.com/shichao-an/unpv13e/blob/master/lib/str_echo.c">lib/str_echo.c</a></small></p>
<div class="codehilite"><pre><span class="cp">#include</span>    <span class="cpf">&quot;unp.h&quot;</span><span class="cp"></span>

<span class="kt">void</span>
<span class="nf">str_echo</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">ssize_t</span>     <span class="n">n</span><span class="p">;</span>
    <span class="kt">char</span>        <span class="n">buf</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>

<span class="nl">again</span><span class="p">:</span>
    <span class="k">while</span> <span class="p">(</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">Writen</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">errno</span> <span class="o">==</span> <span class="n">EINTR</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;str_echo: read error&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>The above code does the following:</p>
<ul>
<li><strong>Read a buffer and echo the buffer</strong><ul>
<li><code>read</code> reads data from the socket and the line is echoed back to the client by <code>writen</code>. If the client closes the connection (the normal scenario), <u>the receipt of the client's FIN causes the child's read to return 0.</u> This causes the <code>str_echo</code> function to return, which terminates the child.</li>
</ul>
</li>
</ul>
<h3 id="tcp-echo-client-main-function">TCP Echo Client: <code>main</code> Function<a class="headerlink" href="#tcp-echo-client-main-function" title="Permanent link">&para;</a></h3>
<p></small><a href="https://github.com/shichao-an/unpv13e/blob/master/tcpcliserv/tcpcli01.c">tcpcliserv/tcpcli01.c</a></small></p>
<div class="codehilite"><pre><span class="cp">#include</span>    <span class="cpf">&quot;unp.h&quot;</span><span class="cp"></span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span>                 <span class="n">sockfd</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">sockaddr_in</span>  <span class="n">servaddr</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">err_quit</span><span class="p">(</span><span class="s">&quot;usage: tcpcli &lt;IPaddress&gt;&quot;</span><span class="p">);</span>

    <span class="n">sockfd</span> <span class="o">=</span> <span class="n">Socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">bzero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">servaddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">servaddr</span><span class="p">));</span>
    <span class="n">servaddr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
    <span class="n">servaddr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">SERV_PORT</span><span class="p">);</span>
    <span class="n">Inet_pton</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">servaddr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">);</span>

    <span class="n">Connect</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="p">(</span><span class="n">SA</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">servaddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">servaddr</span><span class="p">));</span>

    <span class="n">str_cli</span><span class="p">(</span><span class="n">stdin</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">);</span>     <span class="cm">/* do it all */</span>

    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>The above code does the following:</p>
<ul>
<li><strong>Create socket, fill in Internet socket address structure</strong><ul>
<li>A TCP socket is created and an Internet socket address structure is filled in with the server's IP address and port number. The server's IP address is taken from the command-line argument and the server's well-known port (<code>SERV_PORT</code>) is from our <code>unp.h</code> header.</li>
</ul>
</li>
<li><strong>Connect to server</strong><ul>
<li><code>connect</code> establishes the connection with the server. The function <code>str_cli</code> handles the rest of the client processing.</li>
</ul>
</li>
</ul>
<h3 id="tcp-echo-client-str_cli-function">TCP Echo Client: <code>str_cli</code> Function<a class="headerlink" href="#tcp-echo-client-str_cli-function" title="Permanent link">&para;</a></h3>
<p>The <code>str_cli</code> function handles the client processing loop: It reads a line of text from standard input, writes it to the server, reads back the server's echo of the line, and outputs the echoed line to standard output.</p>
<p></small><a href="https://github.com/shichao-an/unpv13e/blob/master/lib/str_cli.c">lib/str_cli.c</a></small></p>
<div class="codehilite"><pre><span class="cp">#include</span>    <span class="cpf">&quot;unp.h&quot;</span><span class="cp"></span>

<span class="kt">void</span>
<span class="nf">str_cli</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sockfd</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span>    <span class="n">sendline</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">],</span> <span class="n">recvline</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">Fgets</span><span class="p">(</span><span class="n">sendline</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">Writen</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">sendline</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">sendline</span><span class="p">));</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">Readline</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">recvline</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">err_quit</span><span class="p">(</span><span class="s">&quot;str_cli: server terminated prematurely&quot;</span><span class="p">);</span>

        <span class="n">Fputs</span><span class="p">(</span><span class="n">recvline</span><span class="p">,</span> <span class="n">stdout</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>The above code does the following:</p>
<ul>
<li><strong>Read a line, write to server</strong><ul>
<li><code>fgets</code> reads a line of text and <code>writen</code> sends the line to the server.</li>
</ul>
</li>
<li><strong>Read echoed line from server, write to standard output</strong><ul>
<li><code>readline</code> reads the line echoed back from the server and <code>fputs</code> writes it to standard output.</li>
</ul>
</li>
<li><strong>Return to main</strong><ul>
<li>The loop terminates when <code>fgets</code> returns a null pointer, which occurs when it encounters either an end-of-file (EOF) or an error. Our <code>Fgets</code> wrapper function checks for an error and aborts if one occurs, so <code>Fgets</code> returns a null pointer only when an end-of-file is encountered.</li>
</ul>
</li>
</ul>
<h3 id="normal-startup">Normal Startup<a class="headerlink" href="#normal-startup" title="Permanent link">&para;</a></h3>
<p>Although the TCP example is small, it is essential that we understand:</p>
<ul>
<li>How the client and server start and end,</li>
<li>What happens when something goes wrong:<ul>
<li>the client host crashes,</li>
<li>the client process crashes,</li>
<li>network connectivity is lost</li>
</ul>
</li>
</ul>
<p>Only by understanding these boundary conditions, and their interaction with the TCP/IP protocols, can we write robust clients and servers that can handle these conditions.</p>
<h4 id="start-the-server-in-the-background">Start the server in the background<a class="headerlink" href="#start-the-server-in-the-background" title="Permanent link">&para;</a></h4>
<p>First, we start the server in the background:</p>
<div class="codehilite"><pre>linux % tcpserv01 &amp;
[1] 17870
</pre></div>


<p>When the server starts, it calls <code>socket</code>, <code>bind</code>, <code>listen</code>, and <code>accept</code>, blocking in the call to accept.</p>
<h4 id="run-netstat">Run <code>netstat</code><a class="headerlink" href="#run-netstat" title="Permanent link">&para;</a></h4>
<p>Before starting the client, we run the <code>netstat</code> program to verify the state of the server's listening socket.</p>
<div class="codehilite"><pre>linux % netstat -a
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address       Foreign Address      State
tcp        0      0 *:9877              *:*                  LISTEN
</pre></div>


<p>This command shows the status of all sockets on the system. We must specify the <code>-a</code> flag to see listening sockets.</p>
<p>In the output, a socket is in the LISTEN state with a wildcard for the local IP address and a local port of 9877. <code>netstat</code> prints an asterisk for an IP address of 0 (<code>INADDR_ANY</code>, the wildcard) or for a port of 0.</p>
<h4 id="start-the-client-on-the-same-host">Start the client on the same host<a class="headerlink" href="#start-the-client-on-the-same-host" title="Permanent link">&para;</a></h4>
<p>We then start the client on the same host, specifying the server's IP address of 127.0.0.1 (the loopback address). We could have also specified the server's normal (nonloopback) IP address.</p>
<div class="codehilite"><pre>linux % tcpcli01 127.0.0.1
</pre></div>


<p>The client calls <code>socket</code>, and <code>connect</code> which causes TCP's three-way handshake. When the three-way handshake completes, <code>connect</code> returns in the client and <code>accept</code> returns in the server. The connection is established. The following steps then take place:</p>
<ol>
<li>The client calls <code>str_cli</code>, which will block in the call to <code>fgets</code>.</li>
<li>When <code>accept</code> returns in the server, it calls <code>fork</code> and the child calls <code>str_echo</code>. This function calls <code>readline</code>, which calls <code>read</code>, which blocks while waiting for a line to be sent from the client.</li>
<li>The server parent, on the other hand, calls <code>accept</code> again, and blocks while waiting for the next client connection.</li>
</ol>
<p>Notes from the previous three steps:</p>
<ul>
<li>All three processes are asleep (blocked): client, server parent, and server child.</li>
<li>We purposely list the client step first, and then the server steps when the three-way handshake completes. This is because <code>accept</code> returns one-half of the RTT after <code>connect</code> returns (see <a href="../figure_2.5.png">Figure 2.5</a>):<ul>
<li>On the client side, <code>connect</code> returns when the second segment of the handshake is received</li>
<li>On the server side, <code>accept</code> does not return until the third segment of the handshake is received</li>
</ul>
</li>
</ul>
<h4 id="run-netstat-after-connection-completes">Run <code>netstat</code> after connection completes<a class="headerlink" href="#run-netstat-after-connection-completes" title="Permanent link">&para;</a></h4>
<p>Since we are running the client and server on the same host, <code>netstat</code> now shows two additional lines of output, corresponding to the TCP connection:</p>
<div class="codehilite"><pre>linux % netstat -a
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address          State
tcp        0      0 local host:9877         localhost:42758          ESTABLISHED
tcp        0      0 local host:42758        localhost:9877           ESTABLISHED
tcp        0      0 *:9877                  *:*                      LISTEN
</pre></div>


<ul>
<li>The first ESTABLISHED line corresponds to the server child's socket, since the local port is 9877.</li>
<li>The second ESTABLISHED lines is the client's socket, since the local port is 42758</li>
</ul>
<p>If we were running the client and server on different hosts, the client host would display only the client's socket, and the server host would display only the two server sockets.</p>
<h4 id="run-ps-to-check-process-status-and-relationship">Run <code>ps</code> to check process status and relationship<a class="headerlink" href="#run-ps-to-check-process-status-and-relationship" title="Permanent link">&para;</a></h4>
<div class="codehilite"><pre>linux % ps -t pts/6 -o pid,ppid,tty,stat,args,wchan
  PID  PPID TT       STAT COMMAND          WCHAN
22038 22036 pts/6    S    -bash            wait4
17870 22038 pts/6    S    ./tcpserv01      wait_for_connect
19315 17870 pts/6    S    ./tcpserv01      tcp_data_wait
19314 22038 pts/6    S    ./tcpcli01 127.0 read_chan
</pre></div>


<p>Very specific arguments to <code>ps</code> are used:</p>
<ul>
<li>The TT column (<code>pts/6</code>): client and server are run from the same window, pseudo-terminal number 6.</li>
<li>The PID and PPID columns show the parent and child relationships.<ul>
<li>The first <code>tcpserv01</code> line is the parent and the second tcpserv01 line is the child since the PPID of the child is the parent's PID.</li>
<li>The PPID of the parent is the shell (bash).</li>
</ul>
</li>
<li>The STAT column for all three of our network processes is "S", meaning the process is sleeping (waiting for something).</li>
<li>The WCHAN column specifies the condition when a process is asleep.<ul>
<li>Linux prints <code>wait_for_connect</code> when a process is blocked in either <code>accept</code> or <code>connect</code>, <code>tcp_data_wait</code> when a process is blocked on socket input or output, or <code>read_chan</code> when a process is blocked on terminal I/O.</li>
<li>In <a href="http://man7.org/linux/man-pages/man1/ps.1.html"><code>ps(1)</code></a>, WCHAN column indicates the name of the kernel function in which the process is sleeping, a "-" if the process is running, or a "*" if the process is multi-threaded and ps is not displaying threads.</li>
</ul>
</li>
</ul>
<h3 id="normal-termination">Normal Termination<a class="headerlink" href="#normal-termination" title="Permanent link">&para;</a></h3>
<p>At this point, the connection is established and whatever we type to the client is echoed back.</p>
<div class="codehilite"><pre><span class="go">linux % tcpcli01 127.0.0.1   # we showed this line earlier</span>
<span class="go">hello, world                 # we now type this</span>
<span class="go">hello, world                 # and the line is echoed</span>
<span class="go">good bye</span>
<span class="go">good bye</span>
<span class="go">^D                           # Control-D is our terminal EOF character</span>
</pre></div>


<p>If we immediately execute netstat, we have:</p>
<div class="codehilite"><pre><span class="go">linux % netstat -a | grep 9877</span>
<span class="go">tcp        0      0 *:9877               *:*               LISTEN</span>
<span class="go">tcp        0      0 localhost:42758      localhost:9877    TIME_WAIT</span>
</pre></div>


<p>This time we pipe the output of netstat into <code>grep</code>, printing only the lines with our server's well-known port:</p>
<ul>
<li>The client's side of the connection (since the local port is 42758) enters the TIME_WAIT state</li>
<li>The listening server is still waiting for another client connection.</li>
</ul>
<p>The following steps are involved in the normal termination of client and server:</p>
<ol>
<li>When we type our EOF character, <code>fgets</code> returns a null pointer and the function <code>str_cli</code> (<a href="#tcp-echo-client-str_cli-function">Section 5.5</a>) returns.</li>
<li><code>str_cli</code> returns to the client <code>main</code> function (<a href="#tcp-echo-client-main-function">Section 5.5</a>), which terminates by calling <code>exit</code>.</li>
<li>Part of process termination is the closing of all open descriptors, so the client socket is closed by the kernel. This sends a FIN to the server, to which the server TCP responds with an ACK. This is the first half of the TCP connection termination sequence. At this point, the server socket is in the CLOSE_WAIT state and the client socket is in the FIN_WAIT_2 state (<a href="../figure_2.4.png">Figure 2.4</a> and <a href="../figure_2.5.png">Figure 2.5</a>)</li>
<li>When the server TCP receives the FIN, the server child is blocked in a call to <code>read</code> (<a href="#tcp-echo-server-str_echo-function">Section 3.8</a>), and <code>read</code> then returns 0. This causes the <code>str_echo</code> function to return to the server child main. [Errata] [p128]</li>
<li>The server child terminates by calling exit. (<a href="#tcp-echo-server-main-function">Section 5.2</a>)</li>
<li>All open descriptors in the server child are closed.<ul>
<li>The closing of the connected socket by the child causes the final two segments of the TCP connection termination to take place: a FIN from the server to the client, and an ACK from the client.</li>
</ul>
</li>
<li>Finally, the <code>SIGCHLD</code> signal is sent to the parent when the server child terminates.<ul>
<li>This occurs in this example, but we do not catch the signal in our code, and the default action of the signal is to be ignored. Thus, the child enters the zombie state. We can verify this with the <code>ps</code> command.</li>
</ul>
</li>
</ol>
<div class="codehilite"><pre><span class="go">linux % ps -t pts/6 -o pid,ppid,tty,stat,args,wchan</span>
<span class="go">  PID  PPID TT       STAT COMMAND          WCHAN</span>
<span class="go">22038 22036 pts/6    S    -bash            read_chan</span>
<span class="go">17870 22038 pts/6    S    ./tcpserv01      wait_for_connect</span>
<span class="go">19315 17870 pts/6    Z    [tcpserv01 &lt;defu do_exit</span>
</pre></div>


<p>The STAT of the child is now <code>Z</code> (for zombie).</p>
<p>We need to clean up our zombie processes and doing this requires dealing with Unix signals. The next section will give an overview of signal handling.</p>
<h3 id="posix-signal-handling">POSIX Signal Handling<a class="headerlink" href="#posix-signal-handling" title="Permanent link">&para;</a></h3>
<p>A <strong>signal</strong> is a notification to a process that an event has occurred. Signals are sometimes called <strong>software interrupts</strong>. Signals usually occur asynchronously, which means that a process doesn't know ahead of time exactly when a signal will occur.</p>
<p>Signals can be sent:</p>
<ul>
<li>By one process to another process (or to itself)</li>
<li>By the kernel to a process.<ul>
<li>For example, whenever a process terminates, the kernel send a <code>SIGCHLD</code> signal to the parent of the terminating process.</li>
</ul>
</li>
</ul>
<p>Every signal has a <strong>disposition</strong>, which is also called the <strong>action</strong> associated with the signal. We set the disposition of a signal by calling the <code>sigaction</code> function and we have three choices for the disposition:</p>
<ol>
<li>
<p><strong>Catching a signal</strong>. We can provide a function called a <strong>signal handler</strong> that is called whenever a specific signal occurs. The two signals <code>SIGKILL</code> and <code>SIGSTOP</code> cannot be caught. Our function is called with a single integer argument that is the signal number and the function returns nothing. Its function prototype is therefore:</p>
<div class="codehilite"><pre>void handler (int signo);
</pre></div>


<p>For most signals, we can call <code>sigaction</code> and specify the signal handler to catch it. A few signals, <code>SIGIO</code>, <code>SIGPOLL</code>, and <code>SIGURG</code>, all require additional actions on the part of the process to catch the signal.</p>
</li>
<li>
<p><strong>Ignoring a signal</strong>. We can ignore a signal by setting its disposition to <code>SIG_IGN</code>. The two signals SIGKILL and SIGSTOP cannot be ignored.</p>
</li>
<li><strong>Setting the default disposition for a signal</strong>. This can be done by setting its disposition to <code>SIG_DFL</code>. The default is normally to terminate a process on receipt of a signal, with certain signals also generating a core image of the process in its current working directory. There are a few signals whose default disposition is to be ignored: <code>SIGCHLD</code> and <code>SIGURG</code> (sent on the arrival of out-of-band data) are two that we will encounter in this text.</li>
</ol>
<h3 id="signal-function"><code>signal</code> Function<a class="headerlink" href="#signal-function" title="Permanent link">&para;</a></h3>
<p>The POSIX way to establish the disposition of a signal is to call the <code>sigaction</code> function, which is complicated in that one argument to the function is a structure (<code>struct sigaction</code>) that we must allocate and fill in.</p>
<p>An easier way to set the disposition of a signal is to call the <code>signal</code> function. The first argument is the signal name and the second argument is either a pointer to a function or one of the constants <code>SIG_IGN</code> or <code>SIG_DFL</code>.</p>
<p>However, <code>signal</code> is an historical function that predates POSIX. Different implementations provide different signal semantics when it is called, providing backward compatibility, whereas POSIX explicitly spells out the semantics when <code>sigaction</code> is called.</p>
<p>The solution is to define our own function named <code>signal</code> that just calls the POSIX <code>sigaction</code> function. This provides a simple interface with the desired POSIX semantics. We include this function in our own library, along with our <code>err</code>_XXX functions and our wrapper functions. [p130]</p>
<p><small><a href="https://github.com/shichao-an/unpv13e/blob/master/lib/signal.c">lib/signal.c</a></small></p>
<div class="codehilite"><pre><span class="cp">#include</span>    <span class="cpf">&quot;unp.h&quot;</span><span class="cp"></span>

<span class="n">Sigfunc</span> <span class="o">*</span>
<span class="nf">signal</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">,</span> <span class="n">Sigfunc</span> <span class="o">*</span><span class="n">func</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">sigaction</span>    <span class="n">act</span><span class="p">,</span> <span class="n">oact</span><span class="p">;</span>

    <span class="n">act</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">=</span> <span class="n">func</span><span class="p">;</span>
    <span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">act</span><span class="p">.</span><span class="n">sa_mask</span><span class="p">);</span>
    <span class="n">act</span><span class="p">.</span><span class="n">sa_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">signo</span> <span class="o">==</span> <span class="n">SIGALRM</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef  SA_INTERRUPT</span>
        <span class="n">act</span><span class="p">.</span><span class="n">sa_flags</span> <span class="o">|=</span> <span class="n">SA_INTERRUPT</span><span class="p">;</span>   <span class="cm">/* SunOS 4.x */</span>
<span class="cp">#endif</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="cp">#ifdef  SA_RESTART</span>
        <span class="n">act</span><span class="p">.</span><span class="n">sa_flags</span> <span class="o">|=</span> <span class="n">SA_RESTART</span><span class="p">;</span>     <span class="cm">/* SVR4, 44BSD */</span>
<span class="cp">#endif</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sigaction</span><span class="p">(</span><span class="n">signo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">act</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oact</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="n">SIG_ERR</span><span class="p">);</span>
    <span class="k">return</span><span class="p">(</span><span class="n">oact</span><span class="p">.</span><span class="n">sa_handler</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/* end signal */</span>

<span class="n">Sigfunc</span> <span class="o">*</span>
<span class="nf">Signal</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">,</span> <span class="n">Sigfunc</span> <span class="o">*</span><span class="n">func</span><span class="p">)</span>    <span class="cm">/* for our signal() function */</span>
<span class="p">{</span>
    <span class="n">Sigfunc</span> <span class="o">*</span><span class="n">sigfunc</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">sigfunc</span> <span class="o">=</span> <span class="n">signal</span><span class="p">(</span><span class="n">signo</span><span class="p">,</span> <span class="n">func</span><span class="p">))</span> <span class="o">==</span> <span class="n">SIG_ERR</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;signal error&quot;</span><span class="p">);</span>
    <span class="k">return</span><span class="p">(</span><span class="n">sigfunc</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<h4 id="simplify-function-prototype-using-typedef">Simplify function prototype using <code>typedef</code><a class="headerlink" href="#simplify-function-prototype-using-typedef" title="Permanent link">&para;</a></h4>
<p>The normal function prototype for <code>signal</code> is complicated by the level of nested parentheses.</p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">signal</span> <span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">)))</span> <span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</pre></div>


<p>To simplify this, we define the <code>Sigfunc</code> type in our <a href="https://github.com/shichao-an/unpv13e/blob/master/lib/unp.h#L243">unp.h</a> header as</p>
<div class="codehilite"><pre><span class="k">typedef</span>    <span class="kt">void</span>    <span class="nf">Sigfunc</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</pre></div>


<p>stating that signal handlers are functions with an integer argument and the function returns nothing (<code>void</code>). The function prototype then becomes</p>
<div class="codehilite"><pre><span class="n">Sigfunc</span> <span class="o">*</span><span class="nf">signal</span> <span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">,</span> <span class="n">Sigfunc</span> <span class="o">*</span><span class="n">func</span><span class="p">);</span>
</pre></div>


<p>A pointer to a signal handling function is the second argument to the function, as well as the return value from the function.</p>
<h4 id="set-handler">Set handler<a class="headerlink" href="#set-handler" title="Permanent link">&para;</a></h4>
<p>The <code>sa_handler</code> member of the <code>sigaction</code> structure is set to the <em>func</em> argument.</p>
<h4 id="set-signal-mask-for-handler">Set signal mask for handler<a class="headerlink" href="#set-signal-mask-for-handler" title="Permanent link">&para;</a></h4>
<p>POSIX allows us to specify a set of signals that will be blocked when our signal handler is called. Any signal that is blocked cannot be delivered to a process. We set the <code>sa_mask</code> member to the empty set, which means that no additional signals will be blocked while our signal handler is running. <u>POSIX guarantees that the signal being caught is always blocked while its handler is executing.</u></p>
<h4 id="set-sa_restart-flag">Set <code>SA_RESTART</code> flag<a class="headerlink" href="#set-sa_restart-flag" title="Permanent link">&para;</a></h4>
<p><code>SA_RESTART</code> is an optional flag. When the flag is set, a system call interrupted by this signal will be automatically restarted by the kernel.</p>
<p>If the signal being caught is not <code>SIGALRM</code>, we specify the <code>SA_RESTART</code> flag, if defined. This is because the purpose of generating the <code>SIGALRM</code> signal is normally to place a timeout on an I/O operation, in which case, we want the blocked system call to be interrupted by the signal. [p131]</p>
<h4 id="call-sigaction">Call <code>sigaction</code><a class="headerlink" href="#call-sigaction" title="Permanent link">&para;</a></h4>
<p>We call <code>sigaction</code> and then <u>return the old action for the signal as the return value of the signal function.</u></p>
<p>Throughout this text, we will use the <code>signal</code> function from the above definition.</p>
<h3 id="handling-sigchld-signals">Handling <code>SIGCHLD</code> Signals<a class="headerlink" href="#handling-sigchld-signals" title="Permanent link">&para;</a></h3>
<p>The zombie state is to maintain information about the child for the parent to fetch later, which includes:</p>
<ul>
<li>process ID of the child,</li>
<li>termination status,</li>
<li>information on the resource utilization of the child.</li>
</ul>
<p>If a parent process of zombie children terminates, the parent process ID of all the zombie children is set to 1 (the <code>init</code> process), which will inherit the children and clean them up (<code>init</code> will <code>wait</code> for them, which removes the zombie). [p132]</p>
<h4 id="handling-zombies">Handling Zombies<a class="headerlink" href="#handling-zombies" title="Permanent link">&para;</a></h4>
<p>Zombies take up space in the kernel and eventually we can run out of processes. Whenever we <code>fork</code> children, we must <code>wait</code> for them to prevent them from becoming zombies. We can establish a signal handler to catch <code>SIGCHLD</code> and call <code>wait</code> within the handler. We establish the signal handler by adding the following function call after the call to <code>listen</code> (in <a href="#tcp-echo-server-main-function">server's <code>main</code> function</a>; it must be done before <code>fork</code>ing the first child and needs to be done only once.):</p>
<div class="codehilite"><pre><span class="n">Signal</span> <span class="p">(</span><span class="n">SIGCHLD</span><span class="p">,</span> <span class="n">sig_chld</span><span class="p">);</span>
</pre></div>


<p>The signal handler, the function <code>sig_chld</code>, is defined below:</p>
<div class="codehilite"><pre><span class="cp">#include</span>    <span class="cpf">&quot;unp.h&quot;</span><span class="cp"></span>

<span class="kt">void</span>
<span class="nf">sig_chld</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">pid_t</span>   <span class="n">pid</span><span class="p">;</span>
    <span class="kt">int</span>     <span class="n">stat</span><span class="p">;</span>

    <span class="n">pid</span> <span class="o">=</span> <span class="n">wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stat</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;child %d terminated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Note that calling standard I/O functions such as <code>printf</code> in a signal handler is not recommended. We call <code>printf</code> here as a diagnostic tool to see when the child terminates.</p>
<h5 id="compiling-and-running-the-program-on-solaris"><strong>Compiling and running the program on Solaris</strong> *<a class="headerlink" href="#compiling-and-running-the-program-on-solaris" title="Permanent link">&para;</a></h5>
<p>This program (<a href="https://github.com/shichao-an/unpv13e/blob/master/tcpcliserv/tcpserv02.c">tcpcliserv/tcpserv02.c</a>) is compiled on Solaris 9 and uses the <code>signal</code> function from the system library (not <a href="#signal-function">our version</a>).</p>
<div class="codehilite"><pre><span class="go">solaris % tcpserv02 &amp;                 # start server in background</span>
<span class="go">[2] 16939</span>
<span class="go">solaris % tcpcli01 127.0.0.1          # then start client in foreground</span>
<span class="go">hi there                              # we type this</span>
<span class="go">hi there                              # and this is echoed</span>
<span class="go">^D                                    # we type our EOF character</span>
<span class="go">child 16942 terminated                # output by printf in signal handler</span>
<span class="go">accept error: Interrupted system call # main function aborts</span>
</pre></div>


<p>The sequence of steps is as follows:</p>
<ol>
<li>We terminate the client by typing our EOF character. The client TCP sends a FIN to the server and the server responds with an ACK.</li>
<li>The receipt of the FIN delivers an EOF to the child's pending <code>readline</code>. The child terminates.</li>
<li>The parent is blocked in its call to accept when the <code>SIGCHLD</code> signal is delivered. The <code>sig_chld</code> function executes (our signal handler), <code>wait</code> fetches the child's PID and termination status, and <code>printf</code> is called from the signal handler. The signal handler returns.</li>
<li>Since the signal was caught by the parent while the parent was blocked in a slow system call (<code>accept</code>), the kernel causes the <code>accept</code> to return an error of <code>EINTR</code> (interrupted system call). The parent does not handle this error (see <a href="#tcp-echo-server-main-function">server's <code>main</code> function</a>), so it aborts.</li>
</ol>
<p>From this example, we know that when writing network programs that catch signals, we must be cognizant of interrupted system calls, and we must handle them. In this example, the <code>signal</code> function provided in the standard C library does not cause an interrupted system call to be automatically restarted by the kernel. Some other systems automatically restart the interrupted system call. If we run the same example under 4.4BSD, using its library version of the <code>signal</code> function, the kernel restarts the interrupted system call and accept does not return an error. To handle this potential problem between different operating systems is one reason we define our own version of the <code>signal</code> function. [p134]</p>
<p>As part of the coding conventions used in this text, we always code an explicit return in our signal handlers, even though this is unnecessary for a function returning <code>void</code>. This reads as a reminder that the return may interrupt a system call.</p>
<h4 id="handling-interrupted-system-calls">Handling Interrupted System Calls<a class="headerlink" href="#handling-interrupted-system-calls" title="Permanent link">&para;</a></h4>
<p>The term "slow system call" is used to describe any system call that can block forever, such as <code>accept</code>. That is, the system call need never return. Most networking functions fall into this category. Examples are:</p>
<ul>
<li><code>accept</code>: there is no guarantee that a server's call to <code>accept</code> will ever return, if there are no clients that will connect to the server.</li>
<li><code>read</code>: the server's call to <code>read</code> in <a href="#tcp-echo-server-str_echo-function">server's <code>str_echo</code> function</a> will never return if the client never sends a line for the server to echo.</li>
</ul>
<p>Other examples of slow system calls are reads and writes of pipes and terminal devices. A notable exception is disk I/O, which usually returns to the caller (assuming no catastrophic hardware failure).</p>
<p>When a process is blocked in a slow system call and the process catches a signal and the signal handler returns, the system call can return an error of <code>EINT</code>. Some kernels automatically restart some interrupted system calls. For portability, when we write a program that catches signals (most concurrent servers catch <code>SIGCHLD</code>), we must be prepared for slow system calls to return <code>EINTR</code>. [p134]</p>
<p>To handle an interrupted <code>accept</code>, we change the call to <code>accept</code> in <a href="#tcp-echo-server-main-function">server's <code>main</code> function</a>, the beginning of the for loop, to the following:</p>
<div class="codehilite"><pre>     <span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
         <span class="n">clilen</span> <span class="o">=</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">cliaddr</span><span class="p">);</span>
         <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">connfd</span> <span class="o">=</span> <span class="n">accept</span> <span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="p">(</span><span class="n">SA</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">cliaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clilen</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
             <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EINTR</span><span class="p">)</span>
                 <span class="k">continue</span><span class="p">;</span>         <span class="cm">/* back to for () */</span>
             <span class="k">else</span>
                 <span class="nf">err_sys</span> <span class="p">(</span><span class="s">&quot;accept error&quot;</span><span class="p">);</span>
        <span class="p">}</span>
</pre></div>


<p>Note that this <code>accept</code> is not our wrapper function <code>Accept</code>, since we must handle the failure of the function ourselves.</p>
<p>The modified version of the server source code is <a href="https://github.com/shichao-an/unpv13e/blob/master/tcpcliserv/tcpserv03.c">tcpcliserv/tcpserv03.c</a>.</p>
<p>Restarting the interrupted system call is fine for:</p>
<ul>
<li><code>accept</code></li>
<li><code>read</code></li>
<li><code>write</code></li>
<li><code>select</code></li>
<li><code>open</code></li>
</ul>
<p>However, there is one function that we cannot restart: <code>connect</code>. If this function returns <code>EINTR</code>, we cannot call it again, as doing so will return an immediate error. When <code>connect</code> is interrupted by a caught signal and is not automatically restarted, we must call <code>select</code> to wait for the connection to complete.</p>
<h3 id="wait-and-waitpid-functions"><code>wait</code> and <code>waitpid</code> Functions<a class="headerlink" href="#wait-and-waitpid-functions" title="Permanent link">&para;</a></h3>
<p>We can call <code>wait</code> function to handle the terminated child.</p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&lt;sys/wait.h&gt;</span><span class="cp"></span>

<span class="kt">pid_t</span> <span class="nf">wait</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">statloc</span><span class="p">);</span>
<span class="kt">pid_t</span> <span class="nf">waitpid</span> <span class="p">(</span><span class="kt">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">statloc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">options</span><span class="p">);</span>

<span class="cm">/* Both return: process ID if OK, 0 or–1 on error */</span>
</pre></div>


<p><code>wait</code> and <code>waitpid</code> both return two values: the return value of the function is the process ID of the terminated child, and the termination status of the child (an integer) is returned through the statloc pointer.</p>
<p>There are three macros that we can call that examine the termination status (see <a href="../../apue/ch8/#wait-and-waitpid-functions">APUE</a>):</p>
<ul>
<li><code>WIFEXITED</code>: tells if the child terminated normally</li>
<li><code>WIFSIGNALED</code>: tells if the child was killed by a signal</li>
<li><code>WIFSTOPPED</code>: tells if the child was just stopped by job control</li>
</ul>
<p>Additional macros let us then fetch the exit status of the child, or the value of the signal that killed the child, or the value of the job-control signal that stopped the child. We will use the <code>WIFEXITED</code> and <code>WEXITSTATUS</code> macros  for this purpose.</p>
<p>If there are no terminated children for the process calling <code>wait</code>, but the process has one or more children that are still executing, then <code>wait</code> blocks until the first of the existing children terminates.</p>
<p><code>waitpid</code> has more control over which process to wait for and whether or not to block:</p>
<ul>
<li>The <em>pid</em> argument specifies the process ID that we want to wait for. A value of -1 says to wait for the first of our children to terminate.</li>
<li>The <em>options</em> argument specifies additional options. The most common option is <code>WNOHANG</code>, which tells the kernel not to block if there are no terminated children.</li>
</ul>
<h4 id="difference-between-wait-and-waitpid">Difference between <code>wait</code> and <code>waitpid</code><a class="headerlink" href="#difference-between-wait-and-waitpid" title="Permanent link">&para;</a></h4>
<p>The following example illustrates the difference between the <code>wait</code> and <code>waitpid</code> functions when used to clean up terminated children.</p>
<p>We modify our TCP client as below, which establishes five connections with the server and then uses only the first one (<code>sockfd[0]</code>) in the call to <code>str_cli</code>. The purpose of establishing multiple connections is to spawn multiple children from the concurrent server.</p>
<p><small><a href="https://github.com/shichao-an/unpv13e/blob/master/tcpcliserv/tcpcli04.c">tcpcliserv/tcpcli04.c</a></small></p>
<div class="codehilite"><pre><span class="cp">#include</span>    <span class="cpf">&quot;unp.h&quot;</span><span class="cp"></span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span>                 <span class="n">i</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
    <span class="k">struct</span> <span class="n">sockaddr_in</span>  <span class="n">servaddr</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">err_quit</span><span class="p">(</span><span class="s">&quot;usage: tcpcli &lt;IPaddress&gt;&quot;</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sockfd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

        <span class="n">bzero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">servaddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">servaddr</span><span class="p">));</span>
        <span class="n">servaddr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
        <span class="n">servaddr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">SERV_PORT</span><span class="p">);</span>
        <span class="n">Inet_pton</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">servaddr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">);</span>

        <span class="n">Connect</span><span class="p">(</span><span class="n">sockfd</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">(</span><span class="n">SA</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">servaddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">servaddr</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="n">str_cli</span><span class="p">(</span><span class="n">stdin</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>      <span class="cm">/* do it all */</span>

    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>When the client terminates, all open descriptors are closed automatically by the kernel (we do not call <code>close</code>, only <code>exit</code>), and all five connections are terminated at about the same time. This causes five FINs to be sent, one on each connection, which in turn causes all five server children to terminate at about the same time. This causes five <code>SIGCHLD</code> signals to be delivered to the parent at about the same time. This causes the problem under discussion.</p>
<p>We first run the server (<a href="https://github.com/shichao-an/unpv13e/blob/master/tcpcliserv/tcpserv03.c">tcpcliserv/tcpserv03.c</a>) in the background and then our new client:</p>
<div class="codehilite"><pre><span class="go">linux % tcpserv03 &amp;</span>
<span class="go">[1] 20419</span>
<span class="go">linux % tcpcli04 127.0.0.1</span>
<span class="go">hello                       # we type this</span>
<span class="go">hello                       # and it is echoed</span>
<span class="go">^D                          # we then type our EOF character</span>
<span class="go">child 20426 terminated      # output by server</span>
</pre></div>


<p>Only one <code>printf</code> is output, when we expect all five children to have terminated. If we execute <code>ps</code>, we see that the other four children still exist as zombies.</p>
<div class="codehilite"><pre>PID TTY          TIME CMD
20419 pts/6     00:00:00 tcpserv03
20421 pts/6     00:00:00 tcpserv03 &lt;defunct&gt;
20422 pts/6     00:00:00 tcpserv03 &lt;defunct&gt;
20423 pts/6     00:00:00 tcpserv03 &lt;defunct&gt;
</pre></div>


<p>Establishing a signal handler and calling wait from that handler are insufficient for preventing zombies. <u>The problem is that all five signals are generated before the signal handler is executed, and the signal handler is executed only one time because Unix signals are normally not queued.</u>This problem is nondeterministic. Dependent on the timing of the FINs arriving at the server host, the signal handler is executed two, three or even four times.</p>
<p>The correct solution is to call <code>waitpid</code> instead of <code>wait</code>. The code below shows the version of our <code>sig_chld</code> function that handles <code>SIGCHLD</code> correctly. This version works because we call <code>waitpid</code> within a loop, fetching the status of any of our children that have terminated, with the <code>WNOHANG</code> option, which tells <code>waitpid</code> not to block if there are running children that have not yet terminated. We cannot call <code>wait</code> in a loop, because there is no way to prevent wait from blocking if there are running children that have not yet terminated.</p>
<p><small><a href="https://github.com/shichao-an/unpv13e/blob/master/tcpcliserv/sigchldwaitpid.c">tcpcliserv/sigchldwaitpid.c</a></small></p>
<div class="codehilite"><pre><span class="cp">#include</span>    <span class="cpf">&quot;unp.h&quot;</span><span class="cp"></span>

<span class="kt">void</span>
<span class="nf">sig_chld</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">pid_t</span>   <span class="n">pid</span><span class="p">;</span>
    <span class="kt">int</span>     <span class="n">stat</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span> <span class="p">(</span><span class="n">pid</span> <span class="o">=</span> <span class="n">waitpid</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stat</span><span class="p">,</span> <span class="n">WNOHANG</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;child %d terminated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>The code below shows the final version of our server. It correctly handles a return of <code>EINTR</code> from <code>accept</code> and it establishes a signal handler (code above) that calls <code>waitpid</code> for all terminated children.</p>
<p><small><a href="https://github.com/shichao-an/unpv13e/blob/master/tcpcliserv/tcpserv04.c">tcpcliserv/tcpserv04.c</a></small></p>
<div class="codehilite"><pre><span class="cp">#include</span>    <span class="cpf">&quot;unp.h&quot;</span><span class="cp"></span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span>                 <span class="n">listenfd</span><span class="p">,</span> <span class="n">connfd</span><span class="p">;</span>
    <span class="kt">pid_t</span>               <span class="n">childpid</span><span class="p">;</span>
    <span class="kt">socklen_t</span>           <span class="n">clilen</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">sockaddr_in</span>  <span class="n">cliaddr</span><span class="p">,</span> <span class="n">servaddr</span><span class="p">;</span>
    <span class="kt">void</span>                <span class="n">sig_chld</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

    <span class="n">listenfd</span> <span class="o">=</span> <span class="n">Socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">bzero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">servaddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">servaddr</span><span class="p">));</span>
    <span class="n">servaddr</span><span class="p">.</span><span class="n">sin_family</span>      <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
    <span class="n">servaddr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">);</span>
    <span class="n">servaddr</span><span class="p">.</span><span class="n">sin_port</span>        <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">SERV_PORT</span><span class="p">);</span>

    <span class="n">Bind</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="p">(</span><span class="n">SA</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">servaddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">servaddr</span><span class="p">));</span>

    <span class="n">Listen</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="n">LISTENQ</span><span class="p">);</span>

    <span class="n">Signal</span><span class="p">(</span><span class="n">SIGCHLD</span><span class="p">,</span> <span class="n">sig_chld</span><span class="p">);</span>  <span class="cm">/* must call waitpid() */</span>

    <span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">clilen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cliaddr</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">connfd</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="p">(</span><span class="n">SA</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">cliaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clilen</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EINTR</span><span class="p">)</span>
                <span class="k">continue</span><span class="p">;</span>       <span class="cm">/* back to for() */</span>
            <span class="k">else</span>
                <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;accept error&quot;</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">childpid</span> <span class="o">=</span> <span class="n">Fork</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>    <span class="cm">/* child process */</span>
            <span class="n">Close</span><span class="p">(</span><span class="n">listenfd</span><span class="p">);</span>    <span class="cm">/* close listening socket */</span>
            <span class="n">str_echo</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>   <span class="cm">/* process the request */</span>
            <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">Close</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>          <span class="cm">/* parent closes connected socket */</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>The purpose of this section has been to demonstrate three scenarios that we can encounter with network programming:</p>
<ul>
<li>We must catch the <code>SIGCHLD</code> signal when forking child processes.</li>
<li>We must handle interrupted system calls when we catch signals.</li>
<li>A <code>SIGCHLD</code> handler must be coded correctly using <code>waitpid</code> to prevent any zombies from being left around.</li>
</ul>
<h3 id="connection-abort-before-accept-returns">Connection Abort before <code>accept</code> Returns<a class="headerlink" href="#connection-abort-before-accept-returns" title="Permanent link">&para;</a></h3>
<p>There is another condition similar to the interrupted system call that can cause <code>accept</code> to return a nonfatal error, in which case we should just call <code>accept</code> again. The sequence of packets shown below has been seen on busy servers (typically busy Web servers), where the server receives an RST for an <code>ESTABLISHED</code> connection before accept is called.</p>
<p><a href="../figure_5.13.png" title="Figure 5.13. Receiving an RST for an ESTABLISHED connection before accept is called."><img alt="Figure 5.13. Receiving an RST for an ESTABLISHED connection before accept is called." src="../figure_5.13.png" /></a></p>
<p>The three-way handshake completes, the connection is established, and then the client TCP sends an RST (reset). On the server side, the connection is queued by its TCP, waiting for the server process to call accept when the RST arrives. Sometime later, the server process calls accept.</p>
<p>An easy way to simulate this scenario is to start the server, have it call <code>socket</code>, <code>bind</code>, and <code>listen</code>, and then go to sleep for a short period of time before calling <code>accept</code>. While the server process is asleep, start the client and have it call <code>socket</code> and <code>connect</code>. As soon as <code>connect</code> returns, set the <code>SO_LINGER</code> socket option to generate the RST and terminate.</p>
<h3 id="termination-of-server-process">Termination of Server Process<a class="headerlink" href="#termination-of-server-process" title="Permanent link">&para;</a></h3>
<p>We will now start our client/server and then kill the server child process, which simulates the crashing of the server process. We must be careful to distinguish between the crashing of the server <em>process</em> and the crashing of the server <em>host</em>.</p>
<p>The following steps take place:</p>
<ol>
<li>We start the server and client and type one line to the client to verify that all is okay. That line is echoed normally by the server child.</li>
<li>We find the process ID of the server child and <code>kill</code> it. As part of process termination, all open descriptors in the child are closed. This causes a FIN to be sent to the client, and the client TCP responds with an ACK. This is the first half of the TCP connection termination.</li>
<li>The <code>SIGCHLD</code> signal is sent to the server parent and handled correctly.</li>
<li>Nothing happens at the client. The client TCP receives the FIN from the server TCP and responds with an ACK, but the problem is that the client process is blocked in the call to <code>fgets</code> waiting for a line from the terminal.</li>
<li>
<p>Running <code>netstat</code> at this point shows the state of the sockets.</p>
<div class="codehilite"><pre>linux % netstat -a | grep 9877
tcp        0      0 *:9877               *:*                 LISTEN
tcp        0      0 localhost:9877       localhost:43604     FIN_WAIT2
tcp        1      0 localhost:43604      localhost:9877      CLOSE_WAIT
</pre></div>


</li>
<li>
<p>We can still type a line of input to the client. Here is what happens at the client starting from Step 1:</p>
<div class="codehilite"><pre>linux % tcpcli01 127.0.0.1  # start client
hello               # the first line that we type
hello               # is echoed correctly  we kill the server child on the server host
another line        # we then type a second line to the client
str_cli : server terminated prematurely
</pre></div>


<p>When we type "another line," <code>str_cli</code> calls <code>writen</code> and the client TCP sends the data to the server. This is allowed by TCP because the receipt of the FIN by the client TCP only indicates that the server process has closed its end of the connection and will not be sending any more data. The receipt of the FIN does not tell the client TCP that the server process has terminated (which in this case, it has).</p>
<p>When the server TCP receives the data from the client, it responds with an RST since the process that had that socket open has terminated. We can verify that the RST was sent by watching the packets with <code>tcpdump</code>.</p>
</li>
<li>
<p>The client process will not see the RST because it calls <code>readline</code> immediately after the call to writen and readline returns 0 (EOF) immediately because of the FIN that was received in Step 2. Our client is not expecting to receive an EOF at this point (<a href="#tcp-echo-client-str_cli-function">str_cli</a>) so it quits with the error message "server terminated prematurely."</p>
</li>
<li>When the client terminates (by calling <code>err_quit</code> in <a href="#tcp-echo-client-str_cli-function">str_cli</a>), all its open descriptors are closed.<ul>
<li>If the <code>readline</code> happens before the RST is received (as shown in this example), the result is an unexpected EOF in the client.</li>
<li>If the RST arrives first, the result is an <code>ECONNRESET</code> ("Connection reset by peer") error return from <code>readline</code>.</li>
</ul>
</li>
</ol>
<p>The problem in this example is that the client is blocked in the call to <code>fgets</code> when the FIN arrives on the socket. The client is really working with two descriptors,the socket and the user input. Instead of blocking on input from only one of the two sources, it should block on input from either source. Indeed, this is one purpose of the <code>select</code> and <code>poll</code> functions described in <a href="../ch6/">Chapter 6</a>.</p>
<h3 id="sigpipe-signal"><code>SIGPIPE</code> Signal<a class="headerlink" href="#sigpipe-signal" title="Permanent link">&para;</a></h3>
<p>The rules are:</p>
<ul>
<li>When a process writes to a socket that has received an RST, the <code>SIGPIPE</code> signal is sent to the process. The default action of this signal is to terminate the process, so the process must catch the signal to avoid being involuntarily terminated.</li>
<li>If the process either catches the signal and returns from the signal handler, or ignores the signal, the write operation returns <code>EPIPE</code>.</li>
</ul>
<p>We can simulate this from the client by performing two writes to the server (which has sent FIN to the client) before reading anything back, with the first write eliciting the RST (causing the server to send an RST to the client). We must use two writes to obtain the signal, because the first write elicits the RST and the second write elicits the signal. It is okay to write to a socket that has received a FIN, but it is an error to write to a socket that has received an RST.</p>
<p>We modify our client as below:</p>
<p><small><a href="https://github.com/shichao-an/unpv13e/blob/master/tcpcliserv/str_cli11.c">tcpcliserv/str_cli11.c</a></small></p>
<div class="codehilite"><pre><span class="cp">#include</span>    <span class="cpf">&quot;unp.h&quot;</span><span class="cp"></span>

<span class="kt">void</span>
<span class="nf">str_cli</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sockfd</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span>    <span class="n">sendline</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">],</span> <span class="n">recvline</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">Fgets</span><span class="p">(</span><span class="n">sendline</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">Writen</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">sendline</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">Writen</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">sendline</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">sendline</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">Readline</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">recvline</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">err_quit</span><span class="p">(</span><span class="s">&quot;str_cli: server terminated prematurely&quot;</span><span class="p">);</span>

        <span class="n">Fputs</span><span class="p">(</span><span class="n">recvline</span><span class="p">,</span> <span class="n">stdout</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>The <code>writen</code> is called two times. The intent is for the first <code>writen</code> to elicit the RST and then for the second <code>writen</code> to generate <code>SIGPIPE</code>.</p>
<p>Run the program on the Linux host:</p>
<div class="codehilite"><pre><span class="go">linux % tcpclill 127.0.0.1</span>
<span class="go">hi there       # we type this line</span>
<span class="go">hi there       # this is echoed by the server</span>
<span class="gp">               #</span> here we <span class="nb">kill</span> the server child
<span class="go">bye            # then we type this line</span>
<span class="go">Broken pipe    # this is printed by the shell</span>
</pre></div>


<p>We start the client, type in one line, see that line echoed correctly, and then terminate the server child on the server host. We then type another line ("bye") and the shell tells us the process died with a <code>SIGPIPE</code> signal.</p>
<p>The recommended way to handle <code>SIGPIPE</code> depends on what the application wants to do when this occurs:</p>
<ul>
<li>If there is nothing special to do, then setting the signal disposition to <code>SIG_IGN</code> is easy, assuming that subsequent output operations will catch the error of <code>EPIPE</code> and terminate.</li>
<li>If special actions are needed when the signal occurs (writing to a log file perhaps), then the signal should be caught and any desired actions can be performed in the signal handler.</li>
<li>If multiple sockets are in use, the delivery of the signal will not tell us which socket encountered the error. If we need to know which <code>write</code> caused the error, then we must either ignore the signal or return from the signal handler and handle <code>EPIPE</code> from the <code>write</code>.</li>
</ul>
<h3 id="crashing-of-server-host">Crashing of Server Host<a class="headerlink" href="#crashing-of-server-host" title="Permanent link">&para;</a></h3>
<p>To simulate what happens when the server host crashes, we must run the client and server on different hosts. We then start the server, start the client, type in a line to the client to verify that the connection is up, disconnect the server host from the network, and type in another line at the client. This also covers the scenario of the server host being unreachable when the client sends data (i.e., some intermediate router goes down <u>after the connection has been established</u>).</p>
<p>The following steps take place:</p>
<ol>
<li>When the server host crashes (which means it is not shut down by an operator), nothing is sent out on the existing network connections.</li>
<li>We type a line of input to the client, it is written by <code>writen</code> (<a href="#tcp-echo-client-str_cli-function">str_cli</a>), and is sent by the client TCP as a data segment. The client then blocks in the call to <code>readline</code>, waiting for the echoed reply.</li>
<li>With <code>tcpdump</code>, we will see the client TCP continually retransmitting the data segment, trying to receive an ACK from the server. Berkeley-derived implementations retransmit the data segment 12 times, waiting for around 9 minutes before giving up. When the client TCP finally gives up (assuming the server host has not been rebooted during this time, or the server host is still unreachable), an error is returned to the client process's <code>readline</code>. The error can be one of the following:<ul>
<li>If the server host crashed and there were no responses at all to the client's data segments, the error is <code>ETIMEDOUT</code>.</li>
<li>If some intermediate router determined that the server host was unreachable and responded with an ICMP "destination unreachable" message, the error is either <code>EHOSTUNREACH</code> or <code>ENETUNREACH</code>.</li>
</ul>
</li>
</ol>
<p>To detect that the peer is down or unreachable quicker than 9 minutes, we can place a timeout on the call to <code>readline</code>, which is discussed in <a href="ch14.md">Chapter 14</a>.</p>
<p>This example detects that the server host has crashed only when we send data to that host. If we want to detect the crashing of the server host even if we are not actively sending it data, another technique is required: SO_KEEPALIVE socket option (<a href="../ch7/">Chapter 7</a>).</p>
<h3 id="crashing-and-rebooting-of-server-host">Crashing and Rebooting of Server Host<a class="headerlink" href="#crashing-and-rebooting-of-server-host" title="Permanent link">&para;</a></h3>
<p>In the following example, we will establish a connection between the client and server and then assume the server host crashes and reboots. The easiest way to simulate this is to establish the connection, disconnect the server from the network, shut down the server host and then reboot it, and then reconnect the server host to the network. We do not want the client to see the server host shut down.</p>
<p>As stated in the previous section, if the client is not actively sending data to the server when the server host crashes, the client is not aware that the server host has crashed. The following steps take place:</p>
<ol>
<li>We start the server and then the client. We type a line to verify that the connection is established.</li>
<li>The server host crashes and reboots.</li>
<li>We type a line of input to the client, which is sent as a TCP data segment to the server host.</li>
<li><u>When the server host reboots after crashing, its TCP loses all information about connections that existed before the crash. Therefore, the server TCP responds to the received data segment from the client with an RST.</u></li>
<li>Our client is blocked in the call to <code>readline</code> when the RST is received, causing <code>readline</code> to return the error <code>ECONNRESET</code>.</li>
</ol>
<p>If it is important for our client to detect the crashing of the server host, even if the client is not actively sending data, then some other technique, such as the <code>SO_KEEPALIVE</code> socket option or some client/server heartbeat function, is required.</p>
<h3 id="shutdown-of-server-host">Shutdown of Server Host<a class="headerlink" href="#shutdown-of-server-host" title="Permanent link">&para;</a></h3>
<p>This section discusses what happens if the server host is shut down by an operator while our server process is running on that host.</p>
<p>When a Unix system is shut down, the following steps happen:</p>
<ol>
<li>The <code>init</code> process normally sends the <code>SIGTERM</code> signal to all processes (we can catch this signal).</li>
<li>The <code>init</code> waits some fixed amount of time (often between 5 and 20 seconds).</li>
<li>The <code>init</code> sends the <code>SIGKILL</code> signal (which we cannot catch) to any processes still running.</li>
</ol>
<p>This gives all running processes a short amount of time to clean up and terminate. When the process terminates, all open descriptors are closed (the sequence of steps are same to <a href="#termination-of-server-process">Termination of Server Process</a>). We must use the <code>select</code> or <code>poll</code> function in our client to have the client detect the termination of the server process as soon as it occurs.</p>
<h3 id="summary-of-tcp-example">Summary of TCP Example<a class="headerlink" href="#summary-of-tcp-example" title="Permanent link">&para;</a></h3>
<p>Before any TCP client and server can communicate with each other, each end must specify the socket pair for the connection: the local IP address, local port, foreign IP address, and foreign port. These four values are shown as bullets in the two figures below.</p>
<h4 id="clients-perspective">Client's perspective<a class="headerlink" href="#clients-perspective" title="Permanent link">&para;</a></h4>
<p><a href="../figure_5.15.png" title="Figure 5.15. Summary of TCP client/server from client's perspective."><img alt="Figure 5.15. Summary of TCP client/server from client's perspective." src="../figure_5.15.png" /></a></p>
<ul>
<li><code>connect</code>. The foreign IP address and foreign port must be specified by the client in the call to <code>connect</code>. The two local values are normally chosen by the kernel as part of the <code>connect</code> function.</li>
<li><code>bind</code>. The client has the option of specifying either or both of the local values, by <code>calling</code> bind before <code>connect</code>, but this is not common.</li>
<li><code>getsockname</code>. The client can obtain the two local values chosen by the kernel by calling <code>getsockname</code> after the connection is established.</li>
</ul>
<h4 id="servers-perspective">Server's perspective<a class="headerlink" href="#servers-perspective" title="Permanent link">&para;</a></h4>
<p><a href="../figure_5.16.png" title="Figure 5.16. Summary of TCP client/server from server's perspective."><img alt="Figure 5.16. Summary of TCP client/server from server's perspective." src="../figure_5.16.png" /></a></p>
<ul>
<li><code>bind</code>. The local port (the server's well-known port) is specified by <code>bind</code>. Normally, the server also specifies the wildcard IP address in this call.</li>
<li><code>getsockname</code>. If the server binds the wildcard IP address on a multihomed host, it can determine the local IP address by calling <code>getsockname</code> after the connection is established.</li>
<li><code>accept.</code> The two foreign values are returned to the server by <code>accept</code>.</li>
<li><code>getpeername</code>. If another program is <code>exec</code>ed by the server that calls <code>accept</code>, that program can call <code>getpeername</code> to determine the client's IP address and port, if necessary.</li>
</ul>
<h3 id="data-format">Data Format<a class="headerlink" href="#data-format" title="Permanent link">&para;</a></h3>
<p>Normally we must worry about the format of the data exchanged between the client and server.</p>
<h4 id="example-passing-text-strings-between-client-and-server">Example: Passing Text Strings between Client and Server<a class="headerlink" href="#example-passing-text-strings-between-client-and-server" title="Permanent link">&para;</a></h4>
<p>We modify our server so that it still reads a line of text from the client, but the server now expects that line to contain two integers separated by white space, and the server returns the sum of those two integers. All that changes is our <code>str_echo</code> function:</p>
<p><small><a href="https://github.com/shichao-an/unpv13e/blob/master/tcpcliserv/str_echo08.c">tcpcliserv/str_echo08.c</a></small></p>
<div class="codehilite"><pre><span class="cp">#include</span>    <span class="cpf">&quot;unp.h&quot;</span><span class="cp"></span>

<span class="kt">void</span>
<span class="nf">str_echo</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">long</span>        <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">;</span>
    <span class="kt">ssize_t</span>     <span class="n">n</span><span class="p">;</span>
    <span class="kt">char</span>        <span class="n">line</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>

    <span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">Readline</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>     <span class="cm">/* connection closed by other end */</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="s">&quot;%ld%ld&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">snprintf</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">line</span><span class="p">),</span> <span class="s">&quot;%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">arg1</span> <span class="o">+</span> <span class="n">arg2</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="n">snprintf</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">line</span><span class="p">),</span> <span class="s">&quot;input error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

        <span class="n">n</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
        <span class="n">Writen</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>We call <code>sscanf</code> to convert the two arguments from text strings to long integers, and then snprintf is called to convert the result into a text string.</p>
<p>This modified client and server work fine, regardless of the byte ordering of the client and server hosts.</p>
<h4 id="example-passing-binary-structures-between-client-and-server">Example: Passing Binary Structures between Client and Server<a class="headerlink" href="#example-passing-binary-structures-between-client-and-server" title="Permanent link">&para;</a></h4>
<p>We now modify our client and server to pass binary values across the socket, instead of text strings. We will see that this does not work when the client and server are run on hosts with different byte orders, or on hosts that do not agree on the size of a long integer</p>
<p>We define one structure for the two arguments, another structure for the result, and place both definitions in our <a href="https://github.com/shichao-an/unpv13e/blob/master/tcpcliserv/sum.h">sum.h</a> header. Below show the modified <code>str_cli</code> function and <code>str_echo</code> function.</p>
<p><small><a href="https://github.com/shichao-an/unpv13e/blob/master/tcpcliserv/tcpcli09.c">tcpcliserv/tcpcli09.c</a></small></p>
<div class="codehilite"><pre><span class="cp">#include</span>    <span class="cpf">&quot;unp.h&quot;</span><span class="cp"></span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span>                 <span class="n">sockfd</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">sockaddr_in</span>  <span class="n">servaddr</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">err_quit</span><span class="p">(</span><span class="s">&quot;usage: tcpcli &lt;IPaddress&gt;&quot;</span><span class="p">);</span>

    <span class="n">sockfd</span> <span class="o">=</span> <span class="n">Socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">bzero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">servaddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">servaddr</span><span class="p">));</span>
    <span class="n">servaddr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
    <span class="n">servaddr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">SERV_PORT</span><span class="p">);</span>
    <span class="n">Inet_pton</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">servaddr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">);</span>

    <span class="n">Connect</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="p">(</span><span class="n">SA</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">servaddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">servaddr</span><span class="p">));</span>

    <span class="n">str_cli</span><span class="p">(</span><span class="n">stdin</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">);</span>     <span class="cm">/* do it all */</span>

    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p><code>sscanf</code> converts the two arguments from text strings to binary, and we call <code>writen</code> to send the structure to the server. We call <code>readn</code> to read the reply, and print the result using <code>printf</code>.</p>
<p><small><a href="https://github.com/shichao-an/unpv13e/blob/master/tcpcliserv/str_echo09.c">tcpcliserv/str_echo09.c</a></small></p>
<div class="codehilite"><pre><span class="cp">#include</span>    <span class="cpf">&quot;unp.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span>    <span class="cpf">&quot;sum.h&quot;</span><span class="cp"></span>

<span class="kt">void</span>
<span class="nf">str_echo</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">ssize_t</span>         <span class="n">n</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">args</span>     <span class="n">args</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">result</span>   <span class="n">result</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">Readn</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">args</span><span class="p">)))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>     <span class="cm">/* connection closed by other end */</span>

        <span class="n">result</span><span class="p">.</span><span class="n">sum</span> <span class="o">=</span> <span class="n">args</span><span class="p">.</span><span class="n">arg1</span> <span class="o">+</span> <span class="n">args</span><span class="p">.</span><span class="n">arg2</span><span class="p">;</span>
        <span class="n">Writen</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">result</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>We read the arguments by calling <code>readn</code>, calculate and store the sum, and call <code>writen</code> to send back the result structure.</p>
<p>If we run the client and server on two machines of the same architecture, say two SPARC machines, everything works fine. But when the client and server are on two machines of different architectures (say the server is on the big-endian SPARC system freebsd and the client is on the little endian Intel system linux), it does not work.</p>
<div class="codehilite"><pre><span class="go">linux % tcpcli09 206.168.112.96</span>
<span class="go">1 2        # we type this</span>
<span class="go">3          # and it works</span>
<span class="go">-22 -77    # then we type this</span>
<span class="go">-16777314  # and it does not work</span>
</pre></div>


<p>The problem is that the two binary integers are sent across the socket in little-endian format by the client, but interpreted as big-endian integers by the server. It appears to work for positive integers but fails for negative integers. There are really three potential problems:</p>
<ol>
<li>Different implementations store binary numbers in different formats. The most common formats are big-endian and little-endian, as we described in Section 3.4.</li>
<li>Different implementations can store the same C datatype differently. For example, most 32-bit Unix systems use 32 bits for a long but 64-bit systems typically use 64 bits for the same datatype. There is no guarantee that a <code>short</code>, <code>int</code>, or <code>long</code> is of any certain size.</li>
<li>Different implementations pack structures differently, depending on the number of bits used for the various datatypes and the alignment restrictions of the machine. Therefore, it is never wise to send binary structures across a socket.</li>
</ol>
<p>There are two common solutions to this data format problem:</p>
<ol>
<li>Pass all numeric data as text strings.</li>
<li>Explicitly define the binary formats of the supported datatypes (number of bits, big- or little-endian) and pass all data between the client and server in this format. RPC packages normally use this technique. RFC 1832 describes the External Data Representation (XDR) standard that is used with the Sun RPC package.</li>
</ol>
<h3 id="summary">Summary<a class="headerlink" href="#summary" title="Permanent link">&para;</a></h3>
<ul>
<li>The first problem was zombie children and we caught the <code>SIGCHLD</code> signal to handle this. Our signal handler then called <code>waitpid</code> and  we must call this function instead of the older <code>wait</code> function, since Unix signals are not queued.</li>
<li>The next problem we encountered was the client not being notified when the server process terminated. We saw that our client's TCP was notified, but we did not receive that notification since we were blocked, waiting for user input. We will use the <code>select</code> or <code>poll</code> function in <a href="../ch6/">Chapter 6</a> to handle this scenario, by waiting for any one of multiple descriptors to be ready, instead of blocking on a single descriptor.</li>
<li>If the server host crashes, we do not detect this until the client sends data to the server. Some applications must be made aware of this fact sooner; we will look at the <code>SO_KEEPALIVE</code> socket option in <a href="../ch7/">Chapter 7</a>.</li>
</ul>
            </div>
        </div>

        <footer class="col-md-12">
            
        </footer>

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script>
        <script src="../../js/base.js"></script>
        <script src="../../custom.js"></script>
    </body>
</html>