<!DOCTYPE html>
<html lang="en">
    <head>
        <!-- Global Site Tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-59055167-2"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments)};
          gtag('js', new Date());

          gtag('config', 'UA-59055167-2');
        </script>

        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://notes.shichao.io/unp/ch3/">
        <link rel="shortcut icon" href="../../toki_32.png">
        

	<title>Chapter 3. Sockets Introduction - Shichao's Notes</title>

        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../../css/base.css" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,400italic,500,600" rel="stylesheet">
        <link href="../../custom.css" rel="stylesheet">
        <link href="../../friendly.css" rel="stylesheet">
        <link href="../../theme.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        
<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../..">Shichao's Notes</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">APUE <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../apue/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch1/">Chapter 1. UNIX System Overview</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch2/">Chapter 2. UNIX Standardization and Implementations</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch3/">Chapter 3. File I/O</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch4/">Chapter 4. Files and Directories</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch5/">Chapter 5. Standard I/O Library</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch6/">Chapter 6. System Data Files and Information</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch7/">Chapter 7. Process Environment</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch8/">Chapter 8. Process Control</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch9/">Chapter 9. Process Relationships</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch10/">Chapter 10. Signals</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch11/">Chapter 11. Threads</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch12/">Chapter 12. Thread Control</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch13/">Chapter 13. Daemon Processes</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch14/">Chapter 14. Advanced I/O</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch15/">Chapter 15. Interprocess Communication</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch16/">Chapter 16. Network IPC: Sockets</a>
                        </li>
                      
                        <li>
                            <a href="../../apue/ch17/">Chapter 17. Advanced IPC</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">UNP <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../ch2/">Chapter 2. The Transport Layer: TCP, UDP, and SCTP</a>
                        </li>
                      
                        <li class="active">
                            <a href="./">Chapter 3. Sockets Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../ch4/">Chapter 4. Elementary TCP Sockets</a>
                        </li>
                      
                        <li>
                            <a href="../ch5/">Chapter 5. TCP Client/Server Example</a>
                        </li>
                      
                        <li>
                            <a href="../ch6/">Chapter 6. I/O Multiplexing: The select and poll Functions</a>
                        </li>
                      
                        <li>
                            <a href="../ch7/">Chapter 7. Socket Options</a>
                        </li>
                      
                        <li>
                            <a href="../ch8/">Chapter 8. Elementary UDP Sockets</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">TCPv1 <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../tcpv1/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch1/">Chapter 1. Introduction</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch2/">Chapter 2. The Internet Address Architecture</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch3/">Chapter 3. Link Layer</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch4/">Chapter 4. ARP: Address Resolution Protocol</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch5/">Chapter 5. The Internet Protocol (IP)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch6/">Chapter 6. System Configuration: DHCP and Autoconfiguration</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch7/">Chapter 7. Firewalls and Network Address Translation (NAT)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch8/">Chapter 8. ICMPv4 and ICMPv6: Internet Control Message Protocol</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch9/">Chapter 9. Broadcasting and Local Multicasting (IGMP and MLD)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch10/">Chapter 10. User Datagram Protocol (UDP) and IP Fragmentation</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch11/">Chapter 11. Name Resolution and the Domain Name System (DNS)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch12/">Chapter 12. TCP: The Transmission Control Protocol (Preliminaries)</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch13/">Chapter 13. TCP Connection Management</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch14/">Chapter 14. TCP Timeout and Retransmission</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch15/">Chapter 15. TCP Data Flow and Window Management</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch16/">Chapter 16. TCP Congestion Control</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch17/">Chapter 17. TCP Keepalive</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/ch18/">Chapter 18. Security: EAP, IPsec, TLS, DNSSEC, and DKIM</a>
                        </li>
                      
                        <li>
                            <a href="../../tcpv1/headers/">Headers</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">GOPL <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../gopl/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch1/">Chapter 1. Tutorial</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch2/">Chapter 2. Program Structure</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch3/">Chapter 3. Basic Data Types</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch4/">Chapter 4. Composite Types</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch5/">Chapter 5. Functions</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch6/">Chapter 6. Methods</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch7/">Chapter 7. Interfaces</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch8/">Chapter 8. Goroutines and Channels</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch9/">Chapter 9. Concurrency with Shared Variables</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch10/">Chapter 10. Packages and the Go Tool</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch11/">Chapter 11. Testing</a>
                        </li>
                      
                        <li>
                            <a href="../../gopl/ch12/">Chapter 12. Reflection</a>
                        </li>
                      
                    </ul>
                </li>
            <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">CSN <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="../../csn/">Contents</a>
                        </li>
                      
                        <li>
                            <a href="../../csn/part1/">Part 1: Language</a>
                        </li>
                      
                        <li>
                            <a href="../../csn/part2/">Part 2: Advanced</a>
                        </li>
                      
                    </ul>
                </li>
            <li>
                    <a href="../../toc/">TOC</a>
                </li>
            </ul>
            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    
                        <a href="https://github.com/shichao-an/notes/blob/master/docs/unp/ch3.md">
                    
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#chapter-3-sockets-introduction">Chapter 3. Sockets Introduction</a></li>
        
    
        <li class="main "><a href="#introduction">Introduction</a></li>
        
    
        <li class="main "><a href="#socket-address-structures">Socket Address Structures</a></li>
        
            <li><a href="#ipv4-socket-address-structure">IPv4 Socket Address Structure</a></li>
        
            <li><a href="#generic-socket-address-structure">Generic Socket Address Structure</a></li>
        
            <li><a href="#ipv6-socket-address-structure">IPv6 Socket Address Structure</a></li>
        
            <li><a href="#new-generic-socket-address-structure">New Generic Socket Address Structure</a></li>
        
            <li><a href="#comparison-of-socket-address-structures">Comparison of Socket Address Structures</a></li>
        
    
        <li class="main "><a href="#value-result-arguments">Value-Result Arguments</a></li>
        
            <li><a href="#from-process-to-kernel">From process to kernel</a></li>
        
            <li><a href="#from-kernel-to-process">From kernel to process</a></li>
        
    
        <li class="main "><a href="#byte-ordering-functions">Byte Ordering Functions</a></li>
        
    
        <li class="main "><a href="#byte-manipulation-functions">Byte Manipulation Functions</a></li>
        
    
        <li class="main "><a href="#inet_aton-inet_addr-and-inet_ntoa-functions">inet_aton, inet_addr, and inet_ntoa Functions</a></li>
        
    
        <li class="main "><a href="#inet_pton-and-inet_ntop-functions">inet_pton and inet_ntop Functions</a></li>
        
            <li><a href="#replacing-inet_addr-to-inet_pton">Replacing inet_addr to inet_pton</a></li>
        
            <li><a href="#replacing-inet_ntoa-to-inet_ntop">Replacing inet_ntoa to inet_ntop</a></li>
        
            <li><a href="#simple-definitions-of-inet_pton-and-inet_ntop-that-support-ipv4">Simple definitions of inet_pton and inet_ntop that support IPv4</a></li>
        
    
        <li class="main "><a href="#sock_ntop-and-related-functions">sock_ntop and Related Functions</a></li>
        
            <li><a href="#presentation-format-of-sock_ntop">Presentation format of sock_ntop</a></li>
        
            <li><a href="#sock_ntop-definition">sock_ntop definition</a></li>
        
            <li><a href="#related-functions">Related functions</a></li>
        
    
        <li class="main "><a href="#readn-writen-and-readline-functions">readn, writen, and readline Functions</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">
              

<h3 id="chapter-3-sockets-introduction"><strong>Chapter 3. Sockets Introduction</strong><a class="headerlink" href="#chapter-3-sockets-introduction" title="Permanent link">&para;</a></h3>
<h3 id="introduction">Introduction<a class="headerlink" href="#introduction" title="Permanent link">&para;</a></h3>
<p>This chapter begins the description of the sockets API.</p>
<h3 id="socket-address-structures">Socket Address Structures<a class="headerlink" href="#socket-address-structures" title="Permanent link">&para;</a></h3>
<p>The name of socket address structures begin with <code>sockaddr_</code> and end with a unique suffix for each protocol suite.</p>
<h4 id="ipv4-socket-address-structure">IPv4 Socket Address Structure<a class="headerlink" href="#ipv4-socket-address-structure" title="Permanent link">&para;</a></h4>
<p>An IPv4 socket address structure, commonly called an "Internet socket address structure", is named <code>sockaddr_in</code> and is defined by including the <code>&lt;netinet/in.h&gt;</code> header.</p>
<div class="codehilite"><pre><span class="k">struct</span> <span class="n">in_addr</span> <span class="p">{</span>
  <span class="n">in_addr_t</span>   <span class="n">s_addr</span><span class="p">;</span>           <span class="cm">/* 32-bit IPv4 address */</span>
                                <span class="cm">/* network byte ordered */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="p">{</span>
  <span class="kt">uint8_t</span>         <span class="n">sin_len</span><span class="p">;</span>      <span class="cm">/* length of structure (16) */</span>
  <span class="n">sa_family_t</span>     <span class="n">sin_family</span><span class="p">;</span>   <span class="cm">/* AF_INET */</span>
  <span class="n">in_port_t</span>       <span class="n">sin_port</span><span class="p">;</span>     <span class="cm">/* 16-bit TCP or UDP port number */</span>
                                <span class="cm">/* network byte ordered */</span>
  <span class="k">struct</span> <span class="n">in_addr</span>  <span class="n">sin_addr</span><span class="p">;</span>     <span class="cm">/* 32-bit IPv4 address */</span>
                                <span class="cm">/* network byte ordered */</span>
  <span class="kt">char</span>            <span class="n">sin_zero</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>  <span class="cm">/* unused */</span>
<span class="p">};</span>
</pre></div>


<ul>
<li><code>sin_len</code>: the length field. We need never set it and need never examine it.<ul>
<li>The four socket functions that pass a socket address structure from the process to the kernel, <code>bind</code>, <code>connect</code>, <code>sendto</code>, and <code>sendmsg</code>, all go through the <code>sockargs</code> function in a Berkeley-derived implementation. This function copies the socket address structure from the process and explicitly sets its <code>sin_len</code> member to the size of the structure that was passed as an argument to these four functions. The five socket functions that pass a socket address structure from the kernel to the process, <code>accept</code>, <code>recvfrom</code>, <code>recvmsg</code>, <code>getpeername</code>, and <code>getsockname</code>, all set the <code>sin_len</code> member before returning to the process.</li>
</ul>
</li>
<li>POSIX requires only three members in the structure: <code>sin_family</code>, <code>sin_addr</code>, and <code>sin_port</code>. Almost all implementations add the <code>sin_zero</code> member so that all socket address structures are at least 16 bytes in size.</li>
<li>The <code>in_addr_t</code> datatype must be an unsigned integer type of at least 32 bits, <code>in_port_t</code> must be an unsigned integer type of at least 16 bits, and <code>sa_family_t</code> can be any unsigned integer type. The latter is normally an 8-bit unsigned integer if the implementation supports the length field, or an unsigned 16-bit integer if the length field is not supported.</li>
<li>Both the IPv4 address and the TCP or UDP port number are always stored in the structure in <strong>network byte order</strong>.</li>
<li>The <code>sin_zero</code> member is unused. By convention, we always set the entire structure to 0 before filling it in.</li>
<li>Socket address structures are used only on a given host: The structure itself is not communicated between different hosts</li>
</ul>
<h4 id="generic-socket-address-structure">Generic Socket Address Structure<a class="headerlink" href="#generic-socket-address-structure" title="Permanent link">&para;</a></h4>
<p>A socket address structures is always passed by reference when passed as an argument to any socket functions. But any socket function that takes one of these pointers as an argument must deal with socket address structures from any of the supported protocol families.</p>
<p>A generic socket address structure in the <code>&lt;sys/socket.h&gt;</code> header:</p>
<div class="codehilite"><pre><span class="k">struct</span> <span class="n">sockaddr</span> <span class="p">{</span>
  <span class="kt">uint8_t</span>      <span class="n">sa_len</span><span class="p">;</span>
  <span class="n">sa_family_t</span>  <span class="n">sa_family</span><span class="p">;</span>    <span class="cm">/* address family: AF_xxx value */</span>
  <span class="kt">char</span>         <span class="n">sa_data</span><span class="p">[</span><span class="mi">14</span><span class="p">];</span>  <span class="cm">/* protocol-specific address */</span>
<span class="p">};</span>
</pre></div>


<p>The socket functions are then defined as taking a pointer to the generic socket address structure, as shown here in the ANSI C function prototype for the <code>bind</code> function:</p>
<div class="codehilite"><pre><span class="kt">int</span> <span class="nf">bind</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">,</span> <span class="kt">socklen_t</span><span class="p">);</span>
</pre></div>


<p>This requires that any calls to these functions must cast the <u>pointer to the <em>protocol-specific socket address structure</em></u> to be a <u>pointer to a <em>generic socket address structure</em>.</u></p>
<p>For example:</p>
<div class="codehilite"><pre><span class="k">struct</span> <span class="n">sockaddr_in</span>  <span class="n">serv</span><span class="p">;</span>      <span class="cm">/* IPv4 socket address structure */</span>

<span class="cm">/* fill in serv{} */</span>

<span class="n">bind</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">serv</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serv</span><span class="p">));</span>
</pre></div>


<p><a href="../ch1/#a-simple-daytime-client">In Chapter 1 in our unp.h header</a>, we define <code>SA</code> to be the string <code>struct sockaddr</code>, just to shorten the code that we must write to cast these pointers.</p>
<ul>
<li>From an application programmer ’s point of view, <u>the only use of these generic socket address structures is to cast pointers to protocol-specific structures.</u></li>
<li>From the kernel’s perspective, another reason for using pointers to generic socket address structures as arguments is that the kernel must take the caller’s pointer, cast it to a <code>struct sockaddr *</code>, and then look at the value of <code>sa_family</code> to determine the type of the structure.</li>
</ul>
<h4 id="ipv6-socket-address-structure">IPv6 Socket Address Structure<a class="headerlink" href="#ipv6-socket-address-structure" title="Permanent link">&para;</a></h4>
<p>The IPv6 socket address is defined by including the <code>&lt;netinet/in.h&gt;</code> header:</p>
<div class="codehilite"><pre><span class="k">struct</span> <span class="n">in6_addr</span> <span class="p">{</span>
  <span class="kt">uint8_t</span>  <span class="n">s6_addr</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>          <span class="cm">/* 128-bit IPv6 address */</span>
                                 <span class="cm">/* network byte ordered */</span>
<span class="p">};</span>

<span class="cp">#define SIN6_LEN      </span><span class="cm">/* required for compile-time tests */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">sockaddr_in6</span> <span class="p">{</span>
  <span class="kt">uint8_t</span>         <span class="n">sin6_len</span><span class="p">;</span>      <span class="cm">/* length of this struct (28) */</span>
  <span class="n">sa_family_t</span>     <span class="n">sin6_family</span><span class="p">;</span>   <span class="cm">/* AF_INET6 */</span>
  <span class="n">in_port_t</span>       <span class="n">sin6_port</span><span class="p">;</span>     <span class="cm">/* transport layer port# */</span>
                                 <span class="cm">/* network byte ordered */</span>
  <span class="kt">uint32_t</span>        <span class="n">sin6_flowinfo</span><span class="p">;</span> <span class="cm">/* flow information, undefined */</span>
  <span class="k">struct</span> <span class="n">in6_addr</span> <span class="n">sin6_addr</span><span class="p">;</span>     <span class="cm">/* IPv6 address */</span>
                                 <span class="cm">/* network byte ordered */</span>
  <span class="kt">uint32_t</span>        <span class="n">sin6_scope_id</span><span class="p">;</span> <span class="cm">/* set of interfaces for a scope */</span>
<span class="p">};</span>
</pre></div>


<ul>
<li>The <code>SIN6_LEN</code> constant must be defined if the system supports the length member for socket address structures.</li>
<li>The IPv6 family is <code>AF_INET6</code>, whereas the IPv4 family is <code>AF_INET</code></li>
<li>The members in this structure are ordered so that if the <code>sockaddr_in6</code> structure is 64-bit aligned, so is the 128-bit <code>sin6_addr</code> member.</li>
<li>The <code>sin6_flowinfo</code> member is divided into two fields:<ul>
<li>The low-order 20 bits are the flow label</li>
<li>The high-order 12 bits are reserved</li>
</ul>
</li>
<li>The <code>sin6_scope_id</code> identifies the scope zone in which a scoped address is meaningful, most commonly an interface index for a link-local address</li>
</ul>
<h4 id="new-generic-socket-address-structure">New Generic Socket Address Structure<a class="headerlink" href="#new-generic-socket-address-structure" title="Permanent link">&para;</a></h4>
<p>A new generic socket address structure was defined as part of the IPv6 sockets API, to overcome some of the shortcomings of the existing <code>struct sockaddr</code>. Unlike the <code>struct sockaddr</code>, the new <code>struct sockaddr_storage</code> is large enough to hold any socket address type supported by the system. The <code>sockaddr_storage</code> structure is defined by including the <code>&lt;netinet/in.h&gt;</code> header:</p>
<div class="codehilite"><pre><span class="k">struct</span> <span class="n">sockaddr_storage</span> <span class="p">{</span>
  <span class="kt">uint8_t</span>      <span class="n">ss_len</span><span class="p">;</span>       <span class="cm">/* length of this struct (implementation dependent) */</span>
  <span class="n">sa_family_t</span>  <span class="n">ss_family</span><span class="p">;</span>    <span class="cm">/* address family: AF_xxx value */</span>
  <span class="cm">/* implementation-dependent elements to provide:</span>
<span class="cm">   * a) alignment sufficient to fulfill the alignment requirements of</span>
<span class="cm">   *    all socket address types that the system supports.</span>
<span class="cm">   * b) enough storage to hold any type of socket address that the</span>
<span class="cm">   *    system supports.</span>
<span class="cm">   */</span>
<span class="p">};</span>
</pre></div>


<p>The <code>sockaddr_storage</code> type provides a generic socket address structure that is different from <code>struct sockaddr</code> in two ways:</p>
<ol>
<li>If any socket address structures that the system supports have alignment requirements, the <code>sockaddr_storage</code> provides the strictest alignment requirement.</li>
<li>The <code>sockaddr_storage</code> is large enough to contain any socket address structure that the system supports.</li>
</ol>
<p>The fields of the <code>sockaddr_storage</code> structure are opaque to the user, except for <code>ss_family</code> and <code>ss_len</code> (if present). The <code>sockaddr_storage</code> must be cast or copied to the appropriate socket address structure for the address given in <code>ss_family</code> to access any other fields.</p>
<h4 id="comparison-of-socket-address-structures">Comparison of Socket Address Structures<a class="headerlink" href="#comparison-of-socket-address-structures" title="Permanent link">&para;</a></h4>
<p>In this figure, we assume that:</p>
<ul>
<li>Socket address structures all contain a one-byte length field</li>
<li>The family field also occupies one byte</li>
<li>Any field that must be at least some number of bits is exactly that number of bits</li>
</ul>
<p><a href="../figure_3.6.png" title="Figure 3.6 Comparison of various socket address structures."><img alt="Figure 3.6 Comparison of various socket address structures." src="../figure_3.6_600.png" /></a></p>
<p>To handle variable-length structures, whenever we pass a pointer to a socket address structure as an argument to one of the socket functions, we pass its length as another argument.</p>
<h3 id="value-result-arguments">Value-Result Arguments<a class="headerlink" href="#value-result-arguments" title="Permanent link">&para;</a></h3>
<p>When a socket address structure is passed to any socket function, it is always passed by reference (a pointer to the structure is passed). The length of the structure is also passed as an argument.</p>
<p>The way in which the length is passed depends on which direction the structure is being passed:</p>
<ol>
<li>From the <strong>process to the kernel</strong></li>
<li>From the <strong>kernel to the process</strong></li>
</ol>
<h4 id="from-process-to-kernel">From process to kernel<a class="headerlink" href="#from-process-to-kernel" title="Permanent link">&para;</a></h4>
<p><code>bind</code>, <code>connect</code>, and <code>sendto</code> functions pass a socket address structure from the process to the kernel.</p>
<p>Arumgents to these functions:</p>
<ul>
<li>The pointer to the socket address structure</li>
<li>The integer size of the structure</li>
</ul>
<div class="codehilite"><pre><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">serv</span><span class="p">;</span>

<span class="cm">/* fill in serv{} */</span>
<span class="n">connect</span> <span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="p">(</span><span class="n">SA</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">serv</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serv</span><span class="p">));</span>
</pre></div>


<p><a href="../figure_3.7.png" title="Figure 3.7 Socket address structure passed from process to kernel."><img alt="Figure 3.7 Socket address structure passed from process to kernel." src="../figure_3.7.png" /></a></p>
<p>The datatype for the size of a socket address structure is actually <code>socklen_t</code> and not <code>int</code>, but the POSIX specification recommends that <code>socklen_t</code> be defined as <code>uint32_t</code>.</p>
<h4 id="from-kernel-to-process">From kernel to process<a class="headerlink" href="#from-kernel-to-process" title="Permanent link">&para;</a></h4>
<p><code>accept</code>, <code>recvfrom</code>, <code>getsockname</code>, and <code>getpeername</code> functions pass a socket address structure from the kernel to the process.</p>
<p>Arguments to these functions:</p>
<ul>
<li>The pointer to the socket address structure</li>
<li>The pointer to an integer containing the size of the structure.</li>
</ul>
<div class="codehilite"><pre><span class="k">struct</span> <span class="n">sockaddr_un</span>  <span class="n">cli</span><span class="p">;</span>   <span class="cm">/* Unix domain */</span>
<span class="kt">socklen_t</span>  <span class="n">len</span><span class="p">;</span>

<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cli</span><span class="p">);</span>         <span class="cm">/* len is a value */</span>
<span class="n">getpeername</span><span class="p">(</span><span class="n">unixfd</span><span class="p">,</span> <span class="p">(</span><span class="n">SA</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">cli</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
<span class="cm">/* len may have changed */</span>
</pre></div>


<p><a href="../figure_3.8.png" title="Figure 3.8 Socket address structure passed from kernel to process."><img alt="Figure 3.8 Socket address structure passed from kernel to process." src="../figure_3.8.png" /></a></p>
<p><strong>Value-result argument</strong> (Figure 3.8): the size changes from an integer to be a pointer to an integer because the size is both <u>a value when the function is called and a result when the function returns.</u></p>
<ul>
<li>As a <strong>value</strong>: it tells the kernel the size of the structure so that the kernel does not write past the end of the structure when filling it in</li>
<li>As a <strong>result</strong>: it tells the process how much information the kernel actually stored in the structure</li>
</ul>
<p>For two other functions that pass socket address structures, <code>recvmsg</code> and <code>sendmsg</code>, the length field is not a function argument but a structure member.</p>
<p>If the socket address structure is fixed-length, the value returned by the kernel will always be that fixed size: 16 for an IPv4 <code>sockaddr_in</code> and 28 for an IPv6 <code>sockaddr_in6</code>. But with a variable-length socket address structure (e.g., a Unix domain <code>sockaddr_un</code>), the value returned can be less than the maximum size of the structure.</p>
<p>Though the most common example of a value-result argument is the length of a returned socket address structure, we will encounter other value-result arguments in this text:</p>
<ul>
<li>The middle three arguments for the <code>select</code> function (Section 6.3)</li>
<li>The length argument for the <code>getsockopt</code> function (Section 7.2)</li>
<li>The <code>msg_namelen</code> and <code>msg_controllen</code> members of the <code>msghdr</code> structure, when used with <code>recvmsg</code> (Section 14.5)</li>
<li>The <code>ifc_len</code> member of the <code>ifconf</code> structure (Figure 17.2)</li>
<li>The first of the two length arguments for the <code>sysctl</code> function (Section 18.4)</li>
</ul>
<h3 id="byte-ordering-functions">Byte Ordering Functions<a class="headerlink" href="#byte-ordering-functions" title="Permanent link">&para;</a></h3>
<p>For a 16-bit integer that is made up of 2 bytes, there are two ways to store the two bytes in memory:</p>
<ul>
<li><strong>Little-endian</strong> order: low-order byte is at the starting address.</li>
<li><strong>Big-endian</strong> order: high-order byte is at the starting address.</li>
</ul>
<p><a href="../figure_3.9.png" title="Figure 3.9 Little-endian byte order and big-endian byte order for a 16-bit integer."><img alt="Figure 3.9 Little-endian byte order and big-endian byte order for a 16-bit integer." src="../figure_3.9_600.png" /></a></p>
<p>The figure shows the most significant bit (MSB) as the leftmost bit of the 16-bit value and the least significant bit (LSB) as the rightmost bit.</p>
<p>The terms "little-endian" and "big-endian" indicate which end of the multibyte value, the little end or the big end, is stored at the starting address of the value.</p>
<p><strong>Host byte order</strong> refer to the byte ordering used by a given system. The program below prints the host byte order:</p>
<p><small><a href="https://github.com/shichao-an/unpv13e/blob/master/intro/byteorder.c">byteorder.c</a></small></p>
<script src="https://gist.github.com/shichao-an/ee430bf440011d96f76a.js"></script>

<p>We store the two-byte value <code>0x0102</code> in the short integer and then look at the two consecutive bytes, <code>c[0]</code> (the address <em>A</em>) and <code>c[1]</code> (the address <em>A+1</em>) to determine the byte order.</p>
<p>The string <code>CPU_VENDOR_OS</code> is determined by the GNU <code>autoconf</code> program.</p>
<div class="codehilite"><pre>freebsd4 % byteorder
i386-unknown-freebsd4.8: little-endian

macosx % byteorder
powerpc-apple-darwin6.6: big-endian

freebsd5 % byteorder
sparc64-unknown-freebsd5.1: big-endian

aix % byteorder
powerpc-ibm-aix5.1.0.0: big-endian

hpux % byteorder
hppa1.1-hp-hpux11.11: big-endian

linux % byteorder
i586-pc-linux-gnu: little-endian

solaris % byteorder
sparc-sun-solaris2.9: big-endian
</pre></div>


<p>Networking protocols must specify a <strong>network byte order</strong>. The sending protocol stack and the receiving protocol stack must agree on the order in which the bytes of these multibyte fields will be transmitted. <u>The Internet protocols use big-endian byte ordering for these multibyte integers.</u></p>
<p>But, both history and the POSIX specification say that certain fields in the socket address structures must be maintained in network byte order. We use the following four functions to convert between these two byte orders:</p>
<p><small><a href="https://gist.github.com/shichao-an/27bb5bebddf78e36198e">unp_htons.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&lt;netinet/in.h&gt;</span><span class="cp"></span>

<span class="kt">uint16_t</span> <span class="nf">htons</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">host16bitvalue</span><span class="p">);</span>
<span class="kt">uint32_t</span> <span class="nf">htonl</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">host32bitvalue</span><span class="p">);</span>

<span class="cm">/* Both return: value in network byte order */</span>

<span class="kt">uint16_t</span> <span class="nf">ntohs</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">net16bitvalue</span><span class="p">);</span>
<span class="kt">uint32_t</span> <span class="nf">ntohl</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">net32bitvalue</span><span class="p">);</span>

<span class="cm">/* Both return: value in host byte order */</span>
</pre></div>


<ul>
<li><code>h</code> stands for <em>host</em></li>
<li><code>n</code> stands for <em>network</em></li>
<li><code>s</code> stands for <em>short</em> (16-bit value, e.g. TCP or UDP port number)</li>
<li><code>l</code> stands for <em>long</em> (32-bit value, e.g. IPv4 address)</li>
</ul>
<p>When using these functions, we do not care about the actual values (big-endian or little-endian) for the host byte order and the network byte order. What we must do is call the appropriate function to convert a given value between the host and network byte order. On those systems that have the same byte ordering as the Internet protocols (big-endian), these four functions are usually defined as null macros.</p>
<p>We use the term "byte" to mean an 8-bit quantity since almost all current computer systems use 8-bit bytes. Most Internet standards use the term <strong>octet</strong> instead of byte to mean an 8-bit quantity.</p>
<p>Bit ordering is an important convention in Internet standards, such as the the first 32 bits of the IPv4 header from RFC 791:</p>
<div class="codehilite"><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Version|  IHL |Type of Service|           Total Length         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div>


<p>This represents four bytes in the order in which they appear on the wire; the leftmost bit is the most significant. However, the numbering starts with zero assigned to the most significant bit.</p>
<h3 id="byte-manipulation-functions">Byte Manipulation Functions<a class="headerlink" href="#byte-manipulation-functions" title="Permanent link">&para;</a></h3>
<p>Two types functions differ in whether they deal with null-terminated C strings:</p>
<ul>
<li>The functions that operate on multibyte fields, without interpreting the data, and without assuming that the data is a null-terminated C string. These types of functions deal with socket address structures to manipulate fields such as IP addresses, which can contain bytes of 0, but are not C character strings.<ul>
<li>The functions whose names begin with <code>b</code> (for byte) (from 4.2BSD)</li>
<li>The functions whose names begin with <code>mem</code> (for memory) (from ANSI C)</li>
</ul>
</li>
<li>The functions that deal with null-terminated C character strings (beginning with <code>str</code> (for string), defined by including the <code>&lt;string.h&gt;</code> header)</li>
</ul>
<p><small><a href="https://gist.github.com/shichao-an/4871b3026c68dc6c4140">unp_bzero.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&lt;strings.h&gt;</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">bzero</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">bcopy</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">bcmp</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr2</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">);</span>

<span class="cm">/* Returns: 0 if equal, nonzero if unequal */</span>
</pre></div>


<p>The memory pointed to by the <code>const</code> pointer is read but not modified by the function.</p>
<ul>
<li><code>bzero</code> sets the specified number of bytes to 0 in the destination. We often use this function to initialize a socket address structure to 0.</li>
<li><code>bcopy</code> moves the specified number of bytes from the source to the destination.</li>
<li><code>bcmp</code> compares two arbitrary byte strings. The return value is zero if the two byte strings are identical; otherwise, it is nonzero</li>
</ul>
<p><small><a href="https://gist.github.com/shichao-an/c229d6cc4ac8d310567b">unp_memset.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">memset</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">memcpy</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">memcmp</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr2</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">);</span>

<span class="cm">/* Returns: 0 if equal, &lt;0 or &gt;0 if unequal (see text) */</span>
</pre></div>


<ul>
<li><code>memset</code> sets the specified number of bytes to the value <code>c</code> in the destination</li>
<li><code>memcpy</code> is similar to <code>bcopy</code>, but the order of the two pointer arguments is swapped</li>
<li><code>memcmp</code> compares two arbitrary byte strings</li>
</ul>
<p>Note:</p>
<ul>
<li>
<p>One way to remember the order of the two pointers for <code>memcpy</code> is to remember that they are written in the same left-to-right order as an assignment statement in C:</p>
<div class="codehilite"><pre>dest = src;
</pre></div>


</li>
<li>
<p>One way to remember the order of the final two arguments to <code>memset</code> is to realize that all of the ANSI C <code>memXXX</code> functions require a length argument, and it is always the final argument. The comparison is done assuming the two unequal bytes are <code>unsigned chars</code>.</p>
</li>
</ul>
<h3 id="inet_aton-inet_addr-and-inet_ntoa-functions"><code>inet_aton</code>, <code>inet_addr</code>, and <code>inet_ntoa</code> Functions<a class="headerlink" href="#inet_aton-inet_addr-and-inet_ntoa-functions" title="Permanent link">&para;</a></h3>
<p>These functions convert Internet addresses between ASCII strings (what humans prefer to use) and network byte ordered binary values (values that are stored in socket address structures).</p>
<p><small><a href="https://gist.github.com/shichao-an/af1102b95566ee43cde7">unp_inet_aton.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">inet_aton</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strptr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">in_addr</span> <span class="o">*</span><span class="n">addrptr</span><span class="p">);</span>
<span class="cm">/* Returns: 1 if string was valid, 0 on error */</span>

<span class="n">in_addr_t</span> <span class="nf">inet_addr</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strptr</span><span class="p">);</span>
<span class="cm">/* Returns: 32-bit binary network byte ordered IPv4 address; INADDR_NONE if error */</span>

<span class="kt">char</span> <span class="o">*</span><span class="nf">inet_ntoa</span><span class="p">(</span><span class="k">struct</span> <span class="n">in_addr</span> <span class="n">inaddr</span><span class="p">);</span>
<span class="cm">/* Returns: pointer to dotted-decimal string */</span>
</pre></div>


<ul>
<li><code>inet_aton</code>: converts the C character string pointed to by <em>strptr</em> into its 32-bit binary network byte ordered value, which is stored through the pointer <em>addrptr</em></li>
<li><code>inet_addr</code>: does the same conversion, returning the 32-bit binary network byte ordered value as the return value. It is deprecated and any new code should use <code>inet_aton</code> instead</li>
<li><code>inet_ntoa</code>: converts a 32-bit binary network byte ordered IPv4 address into its corresponding dotted-decimal string.<ul>
<li><u>The string pointed to by the return value of the function resides in static memory.</u> This means the function is not reentrant, which we will discuss in Section 11.18.</li>
<li>This function takes a structure as its argument, not a pointer to a structure. (Functions that take actual structures as arguments are rare. It is more common to pass a pointer to the structure.)</li>
</ul>
</li>
</ul>
<h3 id="inet_pton-and-inet_ntop-functions"><code>inet_pton</code> and <code>inet_ntop</code> Functions<a class="headerlink" href="#inet_pton-and-inet_ntop-functions" title="Permanent link">&para;</a></h3>
<p>These two functions are new with IPv6 and work with both IPv4 and IPv6 addresses. We use these two functions throughout the text. The letters "p" and "n" stand for <em>presentation</em> and <em>numeric</em>. The presentation format for an address is often an ASCII string and the numeric format is the binary value that goes into a socket address structure.</p>
<p><small><a href="https://gist.github.com/shichao-an/a4f313716c78362d0b49">unp_inet_pton.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">inet_pton</span><span class="p">(</span><span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strptr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addrptr</span><span class="p">);</span>
<span class="cm">/* Returns: 1 if OK, 0 if input not a valid presentation format, -1 on error */</span>

<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">inet_ntop</span><span class="p">(</span><span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addrptr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>
<span class="cm">/* Returns: pointer to result if OK, NULL on error */</span>
</pre></div>


<p>Arguments:</p>
<ul>
<li><em>family</em>: is either <code>AF_INET</code> or <code>AF_INET6</code>. If <em>family</em> is not supported, both functions return an error with <code>errno</code> set to <code>EAFNOSUPPORT</code>.</li>
</ul>
<p>Functions:</p>
<ul>
<li><code>inet_pton</code>: converts the string pointed to by <em>strptr</em>, storing the binary result through the pointer <em>addrptr</em>. If successful, the return value is 1. If the input string is not a valid presentation format for the specified <em>family</em>, 0 is returned.</li>
<li><code>inet_ntop</code> does the reverse conversion, from numeric (<em>addrptr</em>) to presentation (<em>strptr</em>).<ul>
<li><em>len</em> argument is the size of the destination. To help specify this size, the following two definitions are defined by including the <code>&lt;netinet/in.h&gt;</code> header.</li>
<li>If <em>len</em> is too small to hold the resulting presentation format, including the terminating null, a null pointer is returned and <code>errno</code> is set to <code>ENOSPC</code>.</li>
<li>The <em>strptr</em> argument to <code>inet_ntop</code> cannot be a null pointer. The caller must allocate memory for the destination and specify its size. On success, this pointer is the return value of the function.</li>
</ul>
</li>
</ul>
<p>Size definitions in <code>&lt;netinet/in.h&gt;</code> header for the <em>len</em> argument:</p>
<div class="codehilite"><pre><span class="cp">#define INET_ADDRSTRLEN       16       </span><span class="cm">/* for IPv4 dotted-decimal */</span><span class="cp"></span>
<span class="cp">#define INET6_ADDRSTRLEN      46       </span><span class="cm">/* for IPv6 hex string */</span><span class="cp"></span>
</pre></div>


<p>The following figure summarizes the five functions on address conversion functions:</p>
<p><a href="../figure_3.11.png" title="Figure 3.11 Summary of address conversion functions."><img alt="Figure 3.11 Summary of address conversion functions." src="../figure_3.11_600.png" /></a></p>
<p>Even if your system does not yet include support for IPv6, you can start using these newer functions by replacing calls of the form.</p>
<h4 id="replacing-inet_addr-to-inet_pton">Replacing <code>inet_addr</code> to <code>inet_pton</code><a class="headerlink" href="#replacing-inet_addr-to-inet_pton" title="Permanent link">&para;</a></h4>
<p>Replace:</p>
<div class="codehilite"><pre><span class="n">foo</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">inet_addr</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
</pre></div>


<p>with</p>
<div class="codehilite"><pre><span class="n">inet_pton</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">foo</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">);</span>
</pre></div>


<h4 id="replacing-inet_ntoa-to-inet_ntop">Replacing <code>inet_ntoa</code> to <code>inet_ntop</code><a class="headerlink" href="#replacing-inet_ntoa-to-inet_ntop" title="Permanent link">&para;</a></h4>
<p>Replace:</p>
<div class="codehilite"><pre>ptr = inet_ntoa(foo.sin_addr);
</pre></div>


<p>with</p>
<div class="codehilite"><pre><span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="n">INET_ADDRSTRLEN</span><span class="p">];</span>
<span class="n">ptr</span> <span class="o">=</span> <span class="n">inet_ntop</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">foo</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">str</span><span class="p">));</span>
</pre></div>


<h4 id="simple-definitions-of-inet_pton-and-inet_ntop-that-support-ipv4">Simple definitions of <code>inet_pton</code> and <code>inet_ntop</code> that support IPv4<a class="headerlink" href="#simple-definitions-of-inet_pton-and-inet_ntop-that-support-ipv4" title="Permanent link">&para;</a></h4>
<p><small><a href="https://github.com/shichao-an/unpv13e/blob/master/libfree/inet_pton_ipv4.c">libfree/inet_pton_ipv4.c</a></small></p>
<div class="codehilite"><pre><span class="kt">int</span>
<span class="nf">inet_pton</span><span class="p">(</span><span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strptr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addrptr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">family</span> <span class="o">==</span> <span class="n">AF_INET</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">in_addr</span>  <span class="n">in_val</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">inet_aton</span><span class="p">(</span><span class="n">strptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">in_val</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">memcpy</span><span class="p">(</span><span class="n">addrptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">in_val</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">in_addr</span><span class="p">));</span>
            <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">errno</span> <span class="o">=</span> <span class="n">EAFNOSUPPORT</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p><small><a href="https://github.com/shichao-an/unpv13e/blob/master/libfree/inet_ntop_ipv4.c">inet_ntop_ipv4.c</a></small></p>
<div class="codehilite"><pre><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span>
<span class="nf">inet_ntop</span><span class="p">(</span><span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addrptr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">u_char</span> <span class="o">*</span><span class="p">)</span> <span class="n">addrptr</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">family</span> <span class="o">==</span> <span class="n">AF_INET</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span>    <span class="n">temp</span><span class="p">[</span><span class="n">INET_ADDRSTRLEN</span><span class="p">];</span>

        <span class="n">snprintf</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">temp</span><span class="p">),</span> <span class="s">&quot;%d.%d.%d.%d&quot;</span><span class="p">,</span>
                 <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">errno</span> <span class="o">=</span> <span class="n">ENOSPC</span><span class="p">;</span>
            <span class="k">return</span> <span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">strcpy</span><span class="p">(</span><span class="n">strptr</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">strptr</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">errno</span> <span class="o">=</span> <span class="n">EAFNOSUPPORT</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<h3 id="sock_ntop-and-related-functions"><code>sock_ntop</code> and Related Functions<a class="headerlink" href="#sock_ntop-and-related-functions" title="Permanent link">&para;</a></h3>
<p>A basic problem with <code>inet_ntop</code> is that it requires the caller to pass a pointer to a binary address. This address is normally contained in a socket address structure, requiring the caller to know the format of the structure and the address family.</p>
<p>For IPv4:</p>
<div class="codehilite"><pre><span class="k">struct</span> <span class="n">sockaddr_in</span>   <span class="n">addr</span><span class="p">;</span>
<span class="n">inet_ntop</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">str</span><span class="p">));</span>
</pre></div>


<p>For IPv6:</p>
<div class="codehilite"><pre><span class="k">struct</span> <span class="n">sockaddr_in6</span>   <span class="n">addr6</span><span class="p">;</span>
<span class="n">inet_ntop</span><span class="p">(</span><span class="n">AF_INET6</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr6</span><span class="p">.</span><span class="n">sin6_addr</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">str</span><span class="p">));</span>
</pre></div>


<p>This (above) makes our code protocol-dependent.</p>
<p>To solve this, we will write our own function named <code>sock_ntop</code> that takes a pointer to a socket address structure, looks inside the structure, and calls the appropriate function to return the presentation format of the address.</p>
<p><small><a href="https://gist.github.com/shichao-an/b0f21ce69e2b8024022e">unp_sock_ntop.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&quot;unp.h&quot;</span><span class="cp"></span>

<span class="kt">char</span> <span class="o">*</span><span class="nf">sock_ntop</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">sockaddr</span><span class="p">,</span> <span class="kt">socklen_t</span> <span class="n">addrlen</span><span class="p">);</span>

<span class="cm">/* Returns: non-null pointer if OK, NULL on error */</span>
</pre></div>


<p><em>sockaddr</em> points to a socket address structure whose length is <em>addrlen</em>. The function uses its own static buffer to hold the result and a pointer to this buffer is the return value. Notice that <u>using static storage for the result prevents the function from being <strong>re-entrant</strong> or <strong>thread-safe</strong>.</u></p>
<h4 id="presentation-format-of-sock_ntop">Presentation format of <code>sock_ntop</code><a class="headerlink" href="#presentation-format-of-sock_ntop" title="Permanent link">&para;</a></h4>
<ul>
<li>IPv4: dotted-decimal form, followed by a terminator (colon), followed by the decimal port number, followed by a null character.<ul>
<li>The buffer size must be at least <code>INET_ADDRSTRLEN</code> plus 6 bytes for IPv4 (16 + 6 = 22)</li>
</ul>
</li>
<li>IPv6: hex string form of an IPv6 address surrounded by brackets, followed by a terminator (colon), followed by the decimal port number, followed by a
null character.<ul>
<li>The buffer size must be at least <code>INET6_ADDRSTRLEN</code> plus 8 bytes for IPv6 (46 + 8 = 54)</li>
</ul>
</li>
</ul>
<h4 id="sock_ntop-definition"><code>sock_ntop</code> definition<a class="headerlink" href="#sock_ntop-definition" title="Permanent link">&para;</a></h4>
<ul>
<li><a href="https://github.com/shichao-an/unpv13e/blob/master/lib/sock_ntop.c">lib/sock_ntop.c</a></li>
</ul>
<p>The source code for only the <code>AF_INET</code> case:</p>
<div class="codehilite"><pre><span class="kt">char</span> <span class="o">*</span>
<span class="nf">sock_ntop</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">sa</span><span class="p">,</span> <span class="kt">socklen_t</span> <span class="n">salen</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span>        <span class="n">portstr</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
    <span class="k">static</span> <span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>       <span class="cm">/* Unix domain is largest */</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">sa_family</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nl">AF_INET</span><span class="p">:</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">sockaddr_in</span>  <span class="o">*</span><span class="n">sin</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="p">)</span> <span class="n">sa</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">inet_ntop</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sin</span><span class="o">-&gt;</span><span class="n">sin_addr</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">str</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ntohs</span><span class="p">(</span><span class="n">sin</span><span class="o">-&gt;</span><span class="n">sin_port</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">snprintf</span><span class="p">(</span><span class="n">portstr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">portstr</span><span class="p">),</span> <span class="s">&quot;:%d&quot;</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">sin</span><span class="o">-&gt;</span><span class="n">sin_port</span><span class="p">));</span>
            <span class="n">strcat</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">portstr</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="cm">/* ... */</span>
</pre></div>


<h4 id="related-functions">Related functions<a class="headerlink" href="#related-functions" title="Permanent link">&para;</a></h4>
<p>There are a few other functions that we define to operate on socket address structures,
and these will simplify the portability of our code between IPv4 and IPv6.</p>
<p><small><a href="https://gist.github.com/shichao-an/f63ebf361581af641397">apue_sock_bind_wild.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&quot;unp.h&quot;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">sock_bind_wild</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">family</span><span class="p">);</span>
<span class="cm">/* Returns: 0 if OK, -1 on error */</span>

<span class="kt">int</span> <span class="nf">sock_cmp_addr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">sockaddr1</span><span class="p">,</span>
                  <span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">sockaddr2</span><span class="p">,</span> <span class="kt">socklen_t</span> <span class="n">addrlen</span><span class="p">);</span>
<span class="cm">/* Returns: 0 if addresses are of the same family and ports are equal,</span>
<span class="cm">   else nonzero</span>
<span class="cm">*/</span>

<span class="kt">int</span> <span class="nf">sock_cmp_port</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">sockaddr1</span><span class="p">,</span>
                  <span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">sockaddr2</span><span class="p">,</span> <span class="kt">socklen_t</span> <span class="n">addrlen</span><span class="p">);</span>
<span class="cm">/* Returns: 0 if addresses are of the same family and ports are equal,</span>
<span class="cm">   else nonzero</span>
<span class="cm">*/</span>

<span class="kt">int</span> <span class="nf">sock_get_port</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">sockaddr</span><span class="p">,</span> <span class="kt">socklen_t</span> <span class="n">addrlen</span><span class="p">);</span>
<span class="cm">/* Returns: non-negative port number for IPv4 or IPv6 address, else -1 */</span>

<span class="kt">char</span> <span class="o">*</span><span class="nf">sock_ntop_host</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">sockaddr</span><span class="p">,</span> <span class="kt">socklen_t</span> <span class="n">addrlen</span><span class="p">);</span>
<span class="cm">/* Returns: non-null pointer if OK, NULL on error */</span>

<span class="kt">void</span> <span class="nf">sock_set_addr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">sockaddr</span><span class="p">,</span> <span class="kt">socklen_t</span> <span class="n">addrlen</span><span class="p">,</span>
                   <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">sock_set_port</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">sockaddr</span><span class="p">,</span> <span class="kt">socklen_t</span> <span class="n">addrlen</span><span class="p">,</span>
                   <span class="kt">int</span> <span class="n">port</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">sock_set_wild</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">sockaddr</span><span class="p">,</span> <span class="kt">socklen_t</span> <span class="n">addrlen</span><span class="p">);</span>
</pre></div>


<ul>
<li><code>sock_bind_wild</code>: binds the wildcard address and an ephemeral port to a socket.</li>
<li><code>sock_cmp_addr</code>: compares the address portion of two socket address structures.</li>
<li><code>sock_cmp_port</code>: compares the port number of two socket address structures.</li>
<li><code>sock_get_port</code>: returns just the port number.</li>
<li><code>sock_ntop_host</code>: converts just the host portion of a socket address structure to presentation format (not the port number)</li>
<li><code>sock_set_addr</code>: sets just the address portion of a socket address structure to the value pointed to by <em>ptr</em>.</li>
<li><code>sock_set_port</code>: sets just the port number of a socket address structure.</li>
<li><code>sock_set_wild</code>: sets the address portion of a socket address structure to the wildcard</li>
</ul>
<h3 id="readn-writen-and-readline-functions"><code>readn</code>, <code>writen</code>, and <code>readline</code> Functions<a class="headerlink" href="#readn-writen-and-readline-functions" title="Permanent link">&para;</a></h3>
<p>Stream sockets (e.g., TCP sockets) exhibit a behavior with the <code>read</code> and <code>write</code> functions that differs from normal file I/O. A <code>read</code> or <code>write</code> on a stream socket might input or output fewer bytes than requested, but this is not an error condition. <u>The reason is that buffer limits might be reached for the socket in the kernel. All that is required to input or output the remaining bytes is for the caller to invoke the <code>read</code> or <code>write</code> function again.</u> This scenario is always a possibility on a stream socket with <code>read</code>, but is normally seen with <code>write</code> only if the socket is nonblocking.</p>
<p><small><a href="https://gist.github.com/shichao-an/26f53ad6de8d2e1a10b2">unp_readn.h</a></small></p>
<div class="codehilite"><pre><span class="cp">#include</span> <span class="cpf">&quot;unp.h&quot;</span><span class="cp"></span>

<span class="kt">ssize_t</span> <span class="nf">readn</span><span class="p">(</span><span class="kt">int</span> <span class="n">filedes</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buff</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">);</span>
<span class="kt">ssize_t</span> <span class="nf">writen</span><span class="p">(</span><span class="kt">int</span> <span class="n">filedes</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buff</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">);</span>
<span class="kt">ssize_t</span> <span class="nf">readline</span><span class="p">(</span><span class="kt">int</span> <span class="n">filedes</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buff</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">maxlen</span><span class="p">);</span>

<span class="cm">/* All return: number of bytes read or written, –1 on error */</span>
</pre></div>


<ul>
<li><a href="https://github.com/shichao-an/unpv13e/blob/master/lib/readn.c">lib/readn.c</a></li>
<li><a href="https://github.com/shichao-an/unpv13e/blob/master/lib/writen.c">lib/writen.c</a></li>
<li><a href="https://github.com/shichao-an/unpv13e/blob/master/test/readline1.c">test/readline1.c</a></li>
<li><a href="https://github.com/shichao-an/unpv13e/blob/master/lib/readline.c">lib/readline.c</a></li>
</ul>
<div class="codehilite"><pre><span class="cp">#include</span>    <span class="cpf">&quot;unp.h&quot;</span><span class="cp"></span>

<span class="kt">ssize_t</span>                     <span class="cm">/* Read &quot;n&quot; bytes from a descriptor. */</span>
<span class="n">readn</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">vptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">size_t</span>  <span class="n">nleft</span><span class="p">;</span>
    <span class="kt">ssize_t</span> <span class="n">nread</span><span class="p">;</span>
    <span class="kt">char</span>    <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>

    <span class="n">ptr</span> <span class="o">=</span> <span class="n">vptr</span><span class="p">;</span>
    <span class="n">nleft</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">nleft</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">nread</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">nleft</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EINTR</span><span class="p">)</span>
                <span class="n">nread</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>      <span class="cm">/* and call read() again */</span>
            <span class="k">else</span>
                <span class="nf">return</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nread</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>              <span class="cm">/* EOF */</span>

        <span class="n">nleft</span> <span class="o">-=</span> <span class="n">nread</span><span class="p">;</span>
        <span class="n">ptr</span>   <span class="o">+=</span> <span class="n">nread</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">nleft</span><span class="p">);</span>      <span class="cm">/* return &gt;= 0 */</span>
<span class="p">}</span>
</pre></div>


<p>Our three functions look for the error <code>EINTR</code> (the system call was interrupted by a caught signal) and continue reading or writing if the error occurs. We handle the error here, instead of forcing the caller to call <code>readn</code> or <code>writen</code> again, since the purpose of these three functions is to prevent the caller from having to handle a short count.</p>
<p>In Section 14.3, we will mention that the <code>MSG_WAITALL</code> flag can be used with the <code>recv</code> function to replace the need for a separate <code>readn</code> function.</p>
<p>In <em>test/readline1.c</em>, our <code>readline</code> function calls the system’s <code>read</code> function once for every byte of data. This is very inefficient, and why we’ve commented the code to state it is "PAINFULLY SLOW".</p>
<p>Our advice is to think in terms of buffers and not lines. Write your code to read buffers of data, and if a line is expected, check the buffer to see if it contains that line.</p>
<p><em>lib/readline.c</em> shows a faster version of the readline function, which uses its own buffering rather than stdio buffering. Most importantly, the state of readline’s internal buffer is exposed, so callers have visibility into exactly what has been received.</p>
<p>In <em>lib/readline.c</em>, the internal function <code>my_read</code> reads up to <code>MAXLINE</code> characters at a time and then returns them, one at a time. The only change to the <code>readline</code> function itself is to call <code>my_read</code> instead of <code>read</code>. A new function, <code>readlinebuf</code>, exposes the internal buffer state so that callers can check and see if more data was received beyond a single line.</p>
<p>Unfortunately, by using <code>static</code> variables in <code>readline.c</code> to maintain the state information across successive calls, the functions are not <strong>re-entrant</strong> or <strong>thread-safe</strong>.</p>
            </div>
        </div>

        <footer class="col-md-12">
            
        </footer>

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script>
        <script src="../../js/base.js"></script>
        <script src="../../custom.js"></script>
    </body>
</html>